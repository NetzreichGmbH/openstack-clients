/* tslint:disable */
/* eslint-disable */
/**
 * OpenStack Compute API
 * Compute API provided by Nova service
 *
 * The version of the OpenAPI document: 2.96
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * An extension object.
 * @export
 * @interface ExtensionShowResponse
 */
export interface ExtensionShowResponse {
    /**
     * 
     * @type {ExtensionsListResponseExtensionsInner}
     * @memberof ExtensionShowResponse
     */
    'extension'?: ExtensionsListResponseExtensionsInner;
}
/**
 * An extension object.
 * @export
 * @interface ExtensionsListResponse
 */
export interface ExtensionsListResponse {
    /**
     * 
     * @type {Array<ExtensionsListResponseExtensionsInner>}
     * @memberof ExtensionsListResponse
     */
    'extensions'?: Array<ExtensionsListResponseExtensionsInner>;
}
/**
 * An extension object.
 * @export
 * @interface ExtensionsListResponseExtensionsInner
 */
export interface ExtensionsListResponseExtensionsInner {
    /**
     * A short name by which this extension is also known.
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'alias'?: string;
    /**
     * Text describing this extension’s purpose.
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'description'?: string;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<ExtensionsListResponseExtensionsInnerLinksInner>}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'links'?: Array<ExtensionsListResponseExtensionsInnerLinksInner>;
    /**
     * Name of the extension.
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'name'?: string;
    /**
     * A URL pointing to the namespace for this extension.
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'namespace'?: string;
    /**
     * The date and time when the resource was updated.
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInner
     */
    'updated'?: string;
}
/**
 * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
 * @export
 * @interface ExtensionsListResponseExtensionsInnerLinksInner
 */
export interface ExtensionsListResponseExtensionsInnerLinksInner {
    /**
     * 
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInnerLinksInner
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof ExtensionsListResponseExtensionsInnerLinksInner
     */
    'rel'?: string;
}
/**
 * Single flavor details
 * @export
 * @interface FlavorShowResponse
 */
export interface FlavorShowResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorShowResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * 
 * @export
 * @interface FlavorUpdate255
 */
export interface FlavorUpdate255 {
    [key: string]: any;

    /**
     * 
     * @type {FlavorUpdate255Flavor}
     * @memberof FlavorUpdate255
     */
    'flavor': FlavorUpdate255Flavor;
}
/**
 * 
 * @export
 * @interface FlavorUpdate255Flavor
 */
export interface FlavorUpdate255Flavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorUpdate255Flavor
     */
    'description': any;
}
/**
 * Single flavor details
 * @export
 * @interface FlavorUpdateResponse
 */
export interface FlavorUpdateResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorUpdateResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * 
 * @export
 * @interface FlavorsActionAddTenantAccess
 */
export interface FlavorsActionAddTenantAccess {
    [key: string]: any;

    /**
     * 
     * @type {FlavorsActionAddTenantAccessAddTenantAccess}
     * @memberof FlavorsActionAddTenantAccess
     */
    'addTenantAccess': FlavorsActionAddTenantAccessAddTenantAccess;
}
/**
 * 
 * @export
 * @interface FlavorsActionAddTenantAccessAddTenantAccess
 */
export interface FlavorsActionAddTenantAccessAddTenantAccess {
    /**
     * 
     * @type {any}
     * @memberof FlavorsActionAddTenantAccessAddTenantAccess
     */
    'tenant': any;
}
/**
 * A list of objects, each with the keys flavor_id and tenant_id.
 * @export
 * @interface FlavorsActionAddtenantaccessResponse
 */
export interface FlavorsActionAddtenantaccessResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsActionAddtenantaccessResponse
     */
    'flavor_access'?: any;
}
/**
 * 
 * @export
 * @interface FlavorsActionRemoveTenantAccess
 */
export interface FlavorsActionRemoveTenantAccess {
    [key: string]: any;

    /**
     * 
     * @type {FlavorsActionAddTenantAccessAddTenantAccess}
     * @memberof FlavorsActionRemoveTenantAccess
     */
    'removeTenantAccess': FlavorsActionAddTenantAccessAddTenantAccess;
}
/**
 * A list of objects, each with the keys flavor_id and tenant_id.
 * @export
 * @interface FlavorsActionRemovetenantaccessResponse
 */
export interface FlavorsActionRemovetenantaccessResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsActionRemovetenantaccessResponse
     */
    'flavor_access'?: any;
}
/**
 * 
 * @export
 * @interface FlavorsCreate20
 */
export interface FlavorsCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {FlavorsCreate20Flavor}
     * @memberof FlavorsCreate20
     */
    'flavor': FlavorsCreate20Flavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreate20Flavor
 */
export interface FlavorsCreate20Flavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'ram': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'vcpus': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'disk': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'OS-FLV-EXT-DATA:ephemeral'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'swap'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate20Flavor
     */
    'rxtx_factor'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof FlavorsCreate20Flavor
     */
    'os-flavor-access:is_public'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}


/**
 * 
 * @export
 * @interface FlavorsCreate20FlavorOsFlavorAccessIsPublic
 */
export interface FlavorsCreate20FlavorOsFlavorAccessIsPublic {
}
/**
 * 
 * @export
 * @interface FlavorsCreate21
 */
export interface FlavorsCreate21 {
    [key: string]: any;

    /**
     * 
     * @type {FlavorsCreate21Flavor}
     * @memberof FlavorsCreate21
     */
    'flavor': FlavorsCreate21Flavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreate21Flavor
 */
export interface FlavorsCreate21Flavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'ram': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'vcpus': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'disk': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'OS-FLV-EXT-DATA:ephemeral'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'swap'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate21Flavor
     */
    'rxtx_factor'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof FlavorsCreate21Flavor
     */
    'os-flavor-access:is_public'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}


/**
 * 
 * @export
 * @interface FlavorsCreate255
 */
export interface FlavorsCreate255 {
    [key: string]: any;

    /**
     * 
     * @type {FlavorsCreate255Flavor}
     * @memberof FlavorsCreate255
     */
    'flavor': FlavorsCreate255Flavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreate255Flavor
 */
export interface FlavorsCreate255Flavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'ram': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'vcpus': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'disk': any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'OS-FLV-EXT-DATA:ephemeral'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'swap'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'rxtx_factor'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof FlavorsCreate255Flavor
     */
    'os-flavor-access:is_public'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreate255Flavor
     */
    'description'?: any;
}


/**
 * @type FlavorsCreateRequest
 * @export
 */
export type FlavorsCreateRequest = FlavorsCreate20 | FlavorsCreate21 | FlavorsCreate255;

/**
 * Single flavor details
 * @export
 * @interface FlavorsCreateResponse
 */
export interface FlavorsCreateResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorsCreateResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreateResponseFlavor
 */
export interface FlavorsCreateResponseFlavor {
    /**
     * The display name of a flavor.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'name'?: any;
    /**
     * The ID of the flavor. While people often make this look like an int, this is really a string.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'id'?: any;
    /**
     * The amount of RAM a flavor has, in MiB.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'ram'?: any;
    /**
     * The number of virtual CPUs that will be allocated to the server.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'vcpus'?: any;
    /**
     * The size of the root disk that will be created in GiB. If 0 the root disk will be set to exactly the size of the image used to deploy the instance. However, in this case the scheduler cannot select the compute host based on the virtual image size. Therefore, 0 should only be used for volume booted instances or for testing purposes. Volume-backed instances can be enforced for flavors with zero root disk via the os_compute_api:servers:create:zero_disk_flavor policy rule.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'disk'?: any;
    /**
     * The size of the ephemeral disk that will be created, in GiB. Ephemeral disks may be written over on server state changes. So should only be used as a scratch space for applications that are aware of its limitations. Defaults to 0.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'OS-FLV-EXT-DATA:ephemeral'?: any;
    /**
     * The size of a dedicated swap disk that will be allocated, in MiB. If 0 (the default), no dedicated swap disk will be created. Currently, the empty string (‘’) is used to represent 0. As of microversion 2.75 default return value of swap is 0 instead of empty string.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'swap'?: any;
    /**
     * The receive / transmit factor (as a float) that will be set on ports if the network backend supports the QOS extension. Otherwise it will be ignored. It defaults to 1.0.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'rxtx_factor'?: any;
    /**
     * Whether the flavor is public (available to all projects) or scoped to a set of projects. Default is True if not specified.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'os-flavor-access:is_public'?: FlavorsCreateResponseFlavorOsFlavorAccessisPublicEnum;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'extra_specs'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'links'?: any;
}

export const FlavorsCreateResponseFlavorOsFlavorAccessisPublicEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type FlavorsCreateResponseFlavorOsFlavorAccessisPublicEnum = typeof FlavorsCreateResponseFlavorOsFlavorAccessisPublicEnum[keyof typeof FlavorsCreateResponseFlavorOsFlavorAccessisPublicEnum];

/**
 * Detailed flavors list response
 * @export
 * @interface FlavorsDetailResponse
 */
export interface FlavorsDetailResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsDetailResponse
     */
    'flavors'?: any;
}
/**
 * @type FlavorsIdActionPost201Response
 * @export
 */
export type FlavorsIdActionPost201Response = FlavorsActionAddtenantaccessResponse | FlavorsActionRemovetenantaccessResponse;

/**
 * @type FlavorsIdActionPostRequest
 * @export
 */
export type FlavorsIdActionPostRequest = FlavorsActionAddTenantAccess | FlavorsActionRemoveTenantAccess;

/**
 * Flavors list response
 * @export
 * @interface FlavorsListResponse
 */
export interface FlavorsListResponse {
    /**
     * 
     * @type {Array<FlavorsListResponseFlavorsInner>}
     * @memberof FlavorsListResponse
     */
    'flavors'?: Array<FlavorsListResponseFlavorsInner>;
}
/**
 * 
 * @export
 * @interface FlavorsListResponseFlavorsInner
 */
export interface FlavorsListResponseFlavorsInner {
    /**
     * 
     * @type {string}
     * @memberof FlavorsListResponseFlavorsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlavorsListResponseFlavorsInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FlavorsListResponseFlavorsInner
     */
    'description'?: string;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<ExtensionsListResponseExtensionsInnerLinksInner>}
     * @memberof FlavorsListResponseFlavorsInner
     */
    'links'?: Array<ExtensionsListResponseExtensionsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface FlavorsOsExtraSpecsCreate
 */
export interface FlavorsOsExtraSpecsCreate {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof FlavorsOsExtraSpecsCreate
     */
    'extra_specs': any;
}
/**
 * A dictionary of the flavor’s extra-specs key-and-value pairs. It appears in the os-extra-specs’ “create” REQUEST body, as well as the os-extra-specs’ “create” and “list” RESPONSE body.
 * @export
 * @interface FlavorsOsExtraSpecsCreateResponse
 */
export interface FlavorsOsExtraSpecsCreateResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsOsExtraSpecsCreateResponse
     */
    'extra_specs'?: any;
}
/**
 * A dictionary of the flavor’s extra-specs key-and-value pairs. It appears in the os-extra-specs’ “create” REQUEST body, as well as the os-extra-specs’ “create” and “list” RESPONSE body.
 * @export
 * @interface FlavorsOsExtraSpecsListResponse
 */
export interface FlavorsOsExtraSpecsListResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsOsExtraSpecsListResponse
     */
    'extra_specs'?: any;
}
/**
 * A list of objects, each with the keys flavor_id and tenant_id.
 * @export
 * @interface FlavorsOsFlavorAccessListResponse
 */
export interface FlavorsOsFlavorAccessListResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsOsFlavorAccessListResponse
     */
    'flavor_access'?: any;
}
/**
 * 
 * @export
 * @interface ImagesMetadataCreate
 */
export interface ImagesMetadataCreate {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof ImagesMetadataCreate
     */
    'metadata': any;
}
/**
 * 
 * @export
 * @interface ImagesMetadataUpdate
 */
export interface ImagesMetadataUpdate {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof ImagesMetadataUpdate
     */
    'meta': any;
}
/**
 * 
 * @export
 * @interface ImagesMetadataUpdateAll
 */
export interface ImagesMetadataUpdateAll {
    /**
     * 
     * @type {any}
     * @memberof ImagesMetadataUpdateAll
     */
    'metadata': any;
}
/**
 * 
 * @export
 * @interface LimitsListResponse
 */
export interface LimitsListResponse {
    /**
     * 
     * @type {LimitsListResponseLimits}
     * @memberof LimitsListResponse
     */
    'limits'?: LimitsListResponseLimits;
}
/**
 * Data structure that contains both absolute limits within a deployment.
 * @export
 * @interface LimitsListResponseLimits
 */
export interface LimitsListResponseLimits {
    /**
     * 
     * @type {LimitsListResponseLimitsAbsolute}
     * @memberof LimitsListResponseLimits
     */
    'absolute'?: LimitsListResponseLimitsAbsolute;
}
/**
 * Name/value pairs that set quota limits within a deployment and Name/value pairs of resource usage.
 * @export
 * @interface LimitsListResponseLimitsAbsolute
 */
export interface LimitsListResponseLimitsAbsolute {
    [key: string]: any;

    /**
     * The number of allowed members for each server group.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxServerGroupMembers'?: any;
    /**
     * The number of allowed server groups for each tenant.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxServerGroups'?: any;
    /**
     * The number of allowed metadata items for each server.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxServerMetamaxServerMeta'?: any;
    /**
     * The number of allowed server cores for each tenant.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxTotalCores'?: any;
    /**
     * The number of allowed servers for each tenant.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxTotalInstances'?: any;
    /**
     * The number of allowed key pairs for each user.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxTotalKeypairs'?: any;
    /**
     * The amount of allowed server RAM, in MiB, for each tenant.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'maxTotalRAMSize'?: any;
    /**
     * The number of used server cores in each tenant. If reserved query parameter is specified and it is not 0, the number of reserved server cores are also included.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'totalCoresUsed'?: any;
    /**
     * The number of servers in each tenant. If reserved query parameter is specified and it is not 0, the number of reserved servers are also included.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'totalInstancesUsed'?: any;
    /**
     * The amount of used server RAM in each tenant. If reserved query parameter is specified and it is not 0, the amount of reserved server RAM is also included.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'totalRAMUsed'?: any;
    /**
     * The number of used server groups in each tenant. If reserved query parameter is specified and it is not 0, the number of reserved server groups are also included.
     * @type {any}
     * @memberof LimitsListResponseLimitsAbsolute
     */
    'totalServerGroupsUsed'?: any;
}
/**
 * Aggregate object.
 * @export
 * @interface OsAggregateShowResponse
 */
export interface OsAggregateShowResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregateShowResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * 
 * @export
 * @interface OsAggregateUpdate20
 */
export interface OsAggregateUpdate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregateUpdate20Aggregate}
     * @memberof OsAggregateUpdate20
     */
    'aggregate': OsAggregateUpdate20Aggregate;
}
/**
 * 
 * @export
 * @interface OsAggregateUpdate20Aggregate
 */
export interface OsAggregateUpdate20Aggregate {
    /**
     * 
     * @type {any}
     * @memberof OsAggregateUpdate20Aggregate
     */
    'name'?: any;
    /**
     * 
     * @type {OsAggregatesCreate20AggregateAvailabilityZone}
     * @memberof OsAggregateUpdate20Aggregate
     */
    'availability_zone'?: OsAggregatesCreate20AggregateAvailabilityZone;
}
/**
 * 
 * @export
 * @interface OsAggregateUpdate21
 */
export interface OsAggregateUpdate21 {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregateUpdate21Aggregate}
     * @memberof OsAggregateUpdate21
     */
    'aggregate': OsAggregateUpdate21Aggregate;
}
/**
 * 
 * @export
 * @interface OsAggregateUpdate21Aggregate
 */
export interface OsAggregateUpdate21Aggregate {
    /**
     * 
     * @type {any}
     * @memberof OsAggregateUpdate21Aggregate
     */
    'name'?: any;
    /**
     * 
     * @type {OsAggregatesCreate21AggregateAvailabilityZone}
     * @memberof OsAggregateUpdate21Aggregate
     */
    'availability_zone'?: OsAggregatesCreate21AggregateAvailabilityZone;
}
/**
 * @type OsAggregateUpdateRequest
 * @export
 */
export type OsAggregateUpdateRequest = OsAggregateUpdate20 | OsAggregateUpdate21;

/**
 * Aggregate object.
 * @export
 * @interface OsAggregateUpdateResponse
 */
export interface OsAggregateUpdateResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregateUpdateResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionAddHost
 */
export interface OsAggregatesActionAddHost {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregatesActionAddHostAddHost}
     * @memberof OsAggregatesActionAddHost
     */
    'add_host': OsAggregatesActionAddHostAddHost;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionAddHostAddHost
 */
export interface OsAggregatesActionAddHostAddHost {
    /**
     * 
     * @type {string}
     * @memberof OsAggregatesActionAddHostAddHost
     */
    'host': string;
}
/**
 * Aggregate object.
 * @export
 * @interface OsAggregatesActionAddHostResponse
 */
export interface OsAggregatesActionAddHostResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregatesActionAddHostResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionRemoveHost
 */
export interface OsAggregatesActionRemoveHost {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregatesActionRemoveHostRemoveHost}
     * @memberof OsAggregatesActionRemoveHost
     */
    'remove_host': OsAggregatesActionRemoveHostRemoveHost;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionRemoveHostRemoveHost
 */
export interface OsAggregatesActionRemoveHostRemoveHost {
    /**
     * 
     * @type {any}
     * @memberof OsAggregatesActionRemoveHostRemoveHost
     */
    'host': any;
}
/**
 * Aggregate object.
 * @export
 * @interface OsAggregatesActionRemoveHostResponse
 */
export interface OsAggregatesActionRemoveHostResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregatesActionRemoveHostResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionSetMetadata
 */
export interface OsAggregatesActionSetMetadata {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregatesActionSetMetadataSetMetadata}
     * @memberof OsAggregatesActionSetMetadata
     */
    'set_metadata': OsAggregatesActionSetMetadataSetMetadata;
}
/**
 * Aggregate object.
 * @export
 * @interface OsAggregatesActionSetMetadataResponse
 */
export interface OsAggregatesActionSetMetadataResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregatesActionSetMetadataResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesActionSetMetadataSetMetadata
 */
export interface OsAggregatesActionSetMetadataSetMetadata {
    /**
     * 
     * @type {any}
     * @memberof OsAggregatesActionSetMetadataSetMetadata
     */
    'metadata': any;
}
/**
 * 
 * @export
 * @interface OsAggregatesCreate20
 */
export interface OsAggregatesCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregatesCreate20Aggregate}
     * @memberof OsAggregatesCreate20
     */
    'aggregate': OsAggregatesCreate20Aggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesCreate20Aggregate
 */
export interface OsAggregatesCreate20Aggregate {
    /**
     * 
     * @type {any}
     * @memberof OsAggregatesCreate20Aggregate
     */
    'name': any;
    /**
     * 
     * @type {OsAggregatesCreate20AggregateAvailabilityZone}
     * @memberof OsAggregatesCreate20Aggregate
     */
    'availability_zone'?: OsAggregatesCreate20AggregateAvailabilityZone;
}
/**
 * @type OsAggregatesCreate20AggregateAvailabilityZone
 * @export
 */
export type OsAggregatesCreate20AggregateAvailabilityZone = any;

/**
 * 
 * @export
 * @interface OsAggregatesCreate21
 */
export interface OsAggregatesCreate21 {
    [key: string]: any;

    /**
     * 
     * @type {OsAggregatesCreate21Aggregate}
     * @memberof OsAggregatesCreate21
     */
    'aggregate': OsAggregatesCreate21Aggregate;
}
/**
 * 
 * @export
 * @interface OsAggregatesCreate21Aggregate
 */
export interface OsAggregatesCreate21Aggregate {
    /**
     * 
     * @type {any}
     * @memberof OsAggregatesCreate21Aggregate
     */
    'name': any;
    /**
     * 
     * @type {OsAggregatesCreate21AggregateAvailabilityZone}
     * @memberof OsAggregatesCreate21Aggregate
     */
    'availability_zone'?: OsAggregatesCreate21AggregateAvailabilityZone;
}
/**
 * @type OsAggregatesCreate21AggregateAvailabilityZone
 * @export
 */
export type OsAggregatesCreate21AggregateAvailabilityZone = any;

/**
 * @type OsAggregatesCreateRequest
 * @export
 */
export type OsAggregatesCreateRequest = OsAggregatesCreate20 | OsAggregatesCreate21;

/**
 * Aggregate object.
 * @export
 * @interface OsAggregatesCreateResponse
 */
export interface OsAggregatesCreateResponse {
    /**
     * 
     * @type {OsAggregatesCreateResponseAggregate}
     * @memberof OsAggregatesCreateResponse
     */
    'aggregate'?: OsAggregatesCreateResponseAggregate;
}
/**
 * The host aggregate object
 * @export
 * @interface OsAggregatesCreateResponseAggregate
 */
export interface OsAggregatesCreateResponseAggregate {
    /**
     * The availability zone of the host aggregate.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'availability_zone'?: any;
    /**
     * The date and time when the resource was created.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'created_at'?: any;
    /**
     * A boolean indicates whether this aggregate is deleted or not, if it has not been deleted, false will appear.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'deleted'?: any;
    /**
     * The date and time when the resource was deleted. If the resource has not been deleted yet, this field will be null.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'deleted_at'?: any;
    /**
     * The ID of the host aggregate.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'metadata'?: any;
    /**
     * A list of host ids in this aggregate.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'hosts'?: any;
    /**
     * The date and time when the resource was updated, if the resource has not been updated, this field will show as null.
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'updated_at'?: any;
    /**
     * The UUID of the host aggregate. New in version 2.41
     * @type {any}
     * @memberof OsAggregatesCreateResponseAggregate
     */
    'uuid'?: any;
}
/**
 * @type OsAggregatesIdActionPost201Response
 * @export
 */
export type OsAggregatesIdActionPost201Response = OsAggregatesActionAddHostResponse | OsAggregatesActionRemoveHostResponse | OsAggregatesActionSetMetadataResponse;

/**
 * @type OsAggregatesIdActionPostRequest
 * @export
 */
export type OsAggregatesIdActionPostRequest = OsAggregatesActionAddHost | OsAggregatesActionRemoveHost | OsAggregatesActionSetMetadata;

/**
 * 
 * @export
 * @interface OsAggregatesImagesImages
 */
export interface OsAggregatesImagesImages {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsAggregatesImagesImages
     */
    'cache': any;
}
/**
 * The list of existing aggregates.
 * @export
 * @interface OsAggregatesListResponse
 */
export interface OsAggregatesListResponse {
    /**
     * The list of existing aggregates.
     * @type {any}
     * @memberof OsAggregatesListResponse
     */
    'aggregates'?: any;
}
/**
 * 
 * @export
 * @interface OsAssistedVolumeSnapshotsCreate
 */
export interface OsAssistedVolumeSnapshotsCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsAssistedVolumeSnapshotsCreateSnapshot}
     * @memberof OsAssistedVolumeSnapshotsCreate
     */
    'snapshot': OsAssistedVolumeSnapshotsCreateSnapshot;
}
/**
 * A partial representation of a snapshot that is used to create a snapshot.
 * @export
 * @interface OsAssistedVolumeSnapshotsCreateResponse
 */
export interface OsAssistedVolumeSnapshotsCreateResponse {
    /**
     * 
     * @type {OsAssistedVolumeSnapshotsCreateResponseSnapshot}
     * @memberof OsAssistedVolumeSnapshotsCreateResponse
     */
    'snapshot'?: OsAssistedVolumeSnapshotsCreateResponseSnapshot;
}
/**
 * 
 * @export
 * @interface OsAssistedVolumeSnapshotsCreateResponseSnapshot
 */
export interface OsAssistedVolumeSnapshotsCreateResponseSnapshot {
    /**
     * Its the same arbitrary string which was sent in request body.
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateResponseSnapshot
     */
    'id'?: any;
    /**
     * The source volume ID.
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateResponseSnapshot
     */
    'volumeId'?: any;
}
/**
 * 
 * @export
 * @interface OsAssistedVolumeSnapshotsCreateSnapshot
 */
export interface OsAssistedVolumeSnapshotsCreateSnapshot {
    /**
     * 
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshot
     */
    'volume_id': any;
    /**
     * 
     * @type {OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshot
     */
    'create_info': OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo;
}
/**
 * 
 * @export
 * @interface OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo
 */
export interface OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo {
    /**
     * 
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo
     */
    'snapshot_id': any;
    /**
     * 
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo
     */
    'type': OsAssistedVolumeSnapshotsCreateSnapshotCreateInfoTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo
     */
    'new_file': any;
    /**
     * 
     * @type {any}
     * @memberof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfo
     */
    'id'?: any;
}

export const OsAssistedVolumeSnapshotsCreateSnapshotCreateInfoTypeEnum = {
    Qcow2: 'qcow2'
} as const;

export type OsAssistedVolumeSnapshotsCreateSnapshotCreateInfoTypeEnum = typeof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfoTypeEnum[keyof typeof OsAssistedVolumeSnapshotsCreateSnapshotCreateInfoTypeEnum];

/**
 * 
 * @export
 * @interface OsAvailabilityZoneDetailResponse
 */
export interface OsAvailabilityZoneDetailResponse {
    /**
     * The list of availability zone information.
     * @type {any}
     * @memberof OsAvailabilityZoneDetailResponse
     */
    'availabilityZoneInfo'?: any;
}
/**
 * 
 * @export
 * @interface OsAvailabilityZoneListResponse
 */
export interface OsAvailabilityZoneListResponse {
    /**
     * The list of availability zone information.
     * @type {any}
     * @memberof OsAvailabilityZoneListResponse
     */
    'availabilityZoneInfo'?: any;
}
/**
 * Empty body for add_interface action
 * @export
 * @interface OsBaremetalNodesActionAddInterfaceRequest
 */
export interface OsBaremetalNodesActionAddInterfaceRequest {
    /**
     * 
     * @type {any}
     * @memberof OsBaremetalNodesActionAddInterfaceRequest
     */
    'add_interface'?: any;
}
/**
 * Empty body for remove_interface action
 * @export
 * @interface OsBaremetalNodesActionRemoveInterfaceRequest
 */
export interface OsBaremetalNodesActionRemoveInterfaceRequest {
    /**
     * 
     * @type {any}
     * @memberof OsBaremetalNodesActionRemoveInterfaceRequest
     */
    'remove_interface'?: any;
}
/**
 * @type OsBaremetalNodesIdActionPost201Response
 * @export
 */
export type OsBaremetalNodesIdActionPost201Response = any;

/**
 * @type OsBaremetalNodesIdActionPostRequest
 * @export
 */
export type OsBaremetalNodesIdActionPostRequest = OsBaremetalNodesActionAddInterfaceRequest | OsBaremetalNodesActionRemoveInterfaceRequest;

/**
 * Show Console Connection Information Response
 * @export
 * @interface OsConsoleAuthTokenShowResponse
 */
export interface OsConsoleAuthTokenShowResponse {
    /**
     * 
     * @type {OsConsoleAuthTokenShowResponseConsole}
     * @memberof OsConsoleAuthTokenShowResponse
     */
    'console'?: OsConsoleAuthTokenShowResponseConsole;
}
/**
 * The console object.
 * @export
 * @interface OsConsoleAuthTokenShowResponseConsole
 */
export interface OsConsoleAuthTokenShowResponseConsole {
    /**
     * The UUID of the server.
     * @type {any}
     * @memberof OsConsoleAuthTokenShowResponseConsole
     */
    'instance_uuid': any;
    /**
     * The name or ID of the host.
     * @type {any}
     * @memberof OsConsoleAuthTokenShowResponseConsole
     */
    'host'?: any;
    /**
     * The port number.
     * @type {any}
     * @memberof OsConsoleAuthTokenShowResponseConsole
     */
    'port': any;
    /**
     * The id representing the internal access path.
     * @type {any}
     * @memberof OsConsoleAuthTokenShowResponseConsole
     */
    'internal_access_path'?: any;
}
/**
 * Empty body for reserve action
 * @export
 * @interface OsFixedIpsActionReserveRequest
 */
export interface OsFixedIpsActionReserveRequest {
    /**
     * 
     * @type {any}
     * @memberof OsFixedIpsActionReserveRequest
     */
    'reserve'?: any;
}
/**
 * Empty body for unreserve action
 * @export
 * @interface OsFixedIpsActionUnreserveRequest
 */
export interface OsFixedIpsActionUnreserveRequest {
    /**
     * 
     * @type {any}
     * @memberof OsFixedIpsActionUnreserveRequest
     */
    'unreserve'?: any;
}
/**
 * @type OsFixedIpsIdActionPost201Response
 * @export
 */
export type OsFixedIpsIdActionPost201Response = any;

/**
 * @type OsFixedIpsIdActionPostRequest
 * @export
 */
export type OsFixedIpsIdActionPostRequest = OsFixedIpsActionReserveRequest | OsFixedIpsActionUnreserveRequest;

/**
 * 
 * @export
 * @interface OsHostUpdate
 */
export interface OsHostUpdate {
    /**
     * 
     * @type {any}
     * @memberof OsHostUpdate
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHostUpdate
     */
    'maintenance_mode'?: any;
}
/**
 * 
 * @export
 * @interface OsHypervisorShowResponse
 */
export interface OsHypervisorShowResponse {
    /**
     * 
     * @type {OsHypervisorShowResponseHypervisor}
     * @memberof OsHypervisorShowResponse
     */
    'hypervisor'?: OsHypervisorShowResponseHypervisor;
}
/**
 * The hypervisor object.
 * @export
 * @interface OsHypervisorShowResponseHypervisor
 */
export interface OsHypervisorShowResponseHypervisor {
    /**
     * A dictionary that contains cpu information like arch, model, vendor, features and topology. The content of this field is hypervisor specific.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'cpu_info'?: any;
    /**
     * The current_workload is the number of tasks the hypervisor is responsible for. This will be equal or greater than the number of active VMs on the system (it can be greater when VMs are being deleted and the hypervisor is still cleaning up). Available until version 2.87
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'current_workload'?: any;
    /**
     * The actual free disk on this hypervisor(in GiB). If allocation ratios used for overcommit are configured, this may be negative. This is intentional as it provides insight into the amount by which the disk is overcommitted. Available until version 2.87
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'disk_available_least'?: any;
    /**
     * The IP address of the hypervisor’s host.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'host_ip'?: any;
    /**
     * The free disk remaining on this hypervisor(in GiB). This does not take allocation ratios used for overcommit into account so this value may be negative. Available until version 2.87
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'free_disk_gb'?: any;
    /**
     * The free RAM in this hypervisor(in MiB). This does not take allocation ratios used for overcommit into account so this value may be negative. Available until version 2.87
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'free_ram_mb'?: any;
    /**
     * The hypervisor host name provided by the Nova virt driver. For the Ironic driver, it is the Ironic node uuid.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'hypervisor_hostname'?: any;
    /**
     * The hypervisor type.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'hypervisor_type'?: any;
    /**
     * The hypervisor version.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'hypervisor_version'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'local_gb'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'local_gb_used'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'memory_mb'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'memory_mb_used'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'running_vms'?: any;
    /**
     * 
     * @type {OsHypervisorShowResponseHypervisorService}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'service'?: OsHypervisorShowResponseHypervisorService;
    /**
     * The total uptime of the hypervisor and information about average load. Only reported for active hosts where the virt driver supports this feature.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'uptime'?: any;
    /**
     * The number of vCPU in this hypervisor. This does not take allocation ratios used for overcommit into account so there may be disparity between this and the used count.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'vcpus'?: any;
    /**
     * The number of vCPU used in this hypervisor.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'vcpus_used'?: any;
    /**
     * The id of the hypervisor. From version 2.53 it is a string as UUID
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'id'?: any;
    /**
     * The state of the hypervisor.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'state'?: OsHypervisorShowResponseHypervisorStateEnum;
    /**
     * The status of the hypervisor.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'status'?: OsHypervisorShowResponseHypervisorStatusEnum;
    /**
     * A list of server objects. This field has become mandatory in microversion 2.75. If no servers is on hypervisor then empty list is returned. New in version 2.53
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisor
     */
    'servers'?: any;
}

export const OsHypervisorShowResponseHypervisorStateEnum = {
    Up: 'up',
    Down: 'down'
} as const;

export type OsHypervisorShowResponseHypervisorStateEnum = typeof OsHypervisorShowResponseHypervisorStateEnum[keyof typeof OsHypervisorShowResponseHypervisorStateEnum];
export const OsHypervisorShowResponseHypervisorStatusEnum = {
    Disabled: 'disabled',
    Enabled: 'enabled'
} as const;

export type OsHypervisorShowResponseHypervisorStatusEnum = typeof OsHypervisorShowResponseHypervisorStatusEnum[keyof typeof OsHypervisorShowResponseHypervisorStatusEnum];

/**
 * The hypervisor service object.
 * @export
 * @interface OsHypervisorShowResponseHypervisorService
 */
export interface OsHypervisorShowResponseHypervisorService {
    /**
     * The name of the host.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisorService
     */
    'host'?: any;
    /**
     * The id of the service.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisorService
     */
    'id'?: any;
    /**
     * The disable reason of the service, null if the service is enabled or disabled without reason provided.
     * @type {any}
     * @memberof OsHypervisorShowResponseHypervisorService
     */
    'disabled_reason'?: any;
}
/**
 * 
 * @export
 * @interface OsHypervisorsDetailResponse
 */
export interface OsHypervisorsDetailResponse {
    /**
     * An array of hypervisor information.
     * @type {any}
     * @memberof OsHypervisorsDetailResponse
     */
    'hypervisors'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsHypervisorsDetailResponse
     */
    'hypervisor_links'?: any;
}
/**
 * 
 * @export
 * @interface OsHypervisorsListResponse
 */
export interface OsHypervisorsListResponse {
    /**
     * An array of hypervisor information.
     * @type {any}
     * @memberof OsHypervisorsListResponse
     */
    'hypervisors'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsHypervisorsListResponse
     */
    'hypervisor_links'?: any;
}
/**
 * The object of instance usage audit log information.
 * @export
 * @interface OsInstanceUsageAuditLogListResponse
 */
export interface OsInstanceUsageAuditLogListResponse {
    /**
     * A list of the hosts whose instance audit tasks have not run.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'hosts_not_run'?: any;
    /**
     * The object of instance usage audit logs.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'log'?: any;
    /**
     * The number of errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'errors'?: any;
    /**
     * The number of instances.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'instances'?: any;
    /**
     * The log message of the instance usage audit task.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'message'?: any;
    /**
     * The state of the instance usage audit task. DONE or RUNNING.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'state'?: OsInstanceUsageAuditLogListResponseStateEnum;
    /**
     * The number of the hosts.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'num_hosts'?: any;
    /**
     * The number of the hosts whose instance audit tasks have been done.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'num_hosts_done'?: any;
    /**
     * The number of the hosts whose instance audit tasks have not run.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'num_hosts_not_run'?: any;
    /**
     * The number of the hosts whose instance audit tasks are running.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'num_hosts_running'?: any;
    /**
     * The overall status of instance audit tasks.M of N hosts done. K errors.The M value is the number of hosts whose instance audit tasks have been done in the period. The N value is the number of all hosts. The K value is the number of hosts whose instance audit tasks cause errors. If instance audit tasks have been done at all hosts in the period, the overall status is as follows:ALL hosts done. K errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'overall_status'?: any;
    /**
     * The beginning time of the instance usage audit period. For example, 2016-05-01 00:00:00.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'period_beginning'?: any;
    /**
     * The ending time of the instance usage audit period. For example, 2016-06-01 00:00:00.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'period_ending'?: any;
    /**
     * The total number of instance audit task errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'total_errors'?: any;
    /**
     * The total number of VM instances in the period.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogListResponse
     */
    'total_instances'?: any;
}

export const OsInstanceUsageAuditLogListResponseStateEnum = {
    Done: 'DONE',
    Running: 'RUNNING'
} as const;

export type OsInstanceUsageAuditLogListResponseStateEnum = typeof OsInstanceUsageAuditLogListResponseStateEnum[keyof typeof OsInstanceUsageAuditLogListResponseStateEnum];

/**
 * The object of instance usage audit log information.
 * @export
 * @interface OsInstanceUsageAuditLogShowResponse
 */
export interface OsInstanceUsageAuditLogShowResponse {
    /**
     * A list of the hosts whose instance audit tasks have not run.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'hosts_not_run'?: any;
    /**
     * The object of instance usage audit logs.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'log'?: any;
    /**
     * The number of errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'errors'?: any;
    /**
     * The number of instances.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'instances'?: any;
    /**
     * The log message of the instance usage audit task.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'message'?: any;
    /**
     * The state of the instance usage audit task. DONE or RUNNING.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'state'?: OsInstanceUsageAuditLogShowResponseStateEnum;
    /**
     * The number of the hosts.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'num_hosts'?: any;
    /**
     * The number of the hosts whose instance audit tasks have been done.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'num_hosts_done'?: any;
    /**
     * The number of the hosts whose instance audit tasks have not run.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'num_hosts_not_run'?: any;
    /**
     * The number of the hosts whose instance audit tasks are running.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'num_hosts_running'?: any;
    /**
     * The overall status of instance audit tasks.M of N hosts done. K errors.The M value is the number of hosts whose instance audit tasks have been done in the period. The N value is the number of all hosts. The K value is the number of hosts whose instance audit tasks cause errors. If instance audit tasks have been done at all hosts in the period, the overall status is as follows:ALL hosts done. K errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'overall_status'?: any;
    /**
     * The beginning time of the instance usage audit period. For example, 2016-05-01 00:00:00.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'period_beginning'?: any;
    /**
     * The ending time of the instance usage audit period. For example, 2016-06-01 00:00:00.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'period_ending'?: any;
    /**
     * The total number of instance audit task errors.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'total_errors'?: any;
    /**
     * The total number of VM instances in the period.
     * @type {any}
     * @memberof OsInstanceUsageAuditLogShowResponse
     */
    'total_instances'?: any;
}

export const OsInstanceUsageAuditLogShowResponseStateEnum = {
    Done: 'DONE',
    Running: 'RUNNING'
} as const;

export type OsInstanceUsageAuditLogShowResponseStateEnum = typeof OsInstanceUsageAuditLogShowResponseStateEnum[keyof typeof OsInstanceUsageAuditLogShowResponseStateEnum];

/**
 * Keypair object
 * @export
 * @interface OsKeypairShowResponse
 */
export interface OsKeypairShowResponse {
    /**
     * 
     * @type {OsKeypairShowResponseKeypair}
     * @memberof OsKeypairShowResponse
     */
    'keypair'?: OsKeypairShowResponseKeypair;
}
/**
 * Keypair object
 * @export
 * @interface OsKeypairShowResponseKeypair
 */
export interface OsKeypairShowResponseKeypair {
    /**
     * The user_id for a keypair.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'user_id'?: any;
    /**
     * A boolean indicates whether this keypair is deleted or not. The value is always false (not deleted).
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'deleted'?: any;
    /**
     * The date and time when the resource was created.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'created_at'?: any;
    /**
     * It is always null.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'deleted_at'?: any;
    /**
     * It is always null.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'updated_at'?: any;
    /**
     * The keypair ID.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'id'?: any;
    /**
     * The name for the keypair
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'name'?: any;
    /**
     * The keypair public key.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'public_key'?: any;
    /**
     * The fingerprint for the keypair.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'fingerprint'?: any;
    /**
     * The type of the keypair. Allowed values are ssh or x509.
     * @type {any}
     * @memberof OsKeypairShowResponseKeypair
     */
    'type'?: any;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate
 */
export interface OsKeypairsCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsKeypairsCreateKeypair}
     * @memberof OsKeypairsCreate
     */
    'keypair': OsKeypairsCreateKeypair;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate20
 */
export interface OsKeypairsCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsKeypairsCreate20Keypair}
     * @memberof OsKeypairsCreate20
     */
    'keypair': OsKeypairsCreate20Keypair;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate20Keypair
 */
export interface OsKeypairsCreate20Keypair {
    /**
     * 
     * @type {any}
     * @memberof OsKeypairsCreate20Keypair
     */
    'name': any;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate20Keypair
     */
    'public_key'?: string;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate21
 */
export interface OsKeypairsCreate21 {
    [key: string]: any;

    /**
     * 
     * @type {OsKeypairsCreate21Keypair}
     * @memberof OsKeypairsCreate21
     */
    'keypair': OsKeypairsCreate21Keypair;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate210
 */
export interface OsKeypairsCreate210 {
    [key: string]: any;

    /**
     * 
     * @type {OsKeypairsCreate210Keypair}
     * @memberof OsKeypairsCreate210
     */
    'keypair': OsKeypairsCreate210Keypair;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate210Keypair
 */
export interface OsKeypairsCreate210Keypair {
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate210Keypair
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof OsKeypairsCreate210Keypair
     */
    'type'?: OsKeypairsCreate210KeypairTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate210Keypair
     */
    'public_key'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate210Keypair
     */
    'user_id'?: string;
}

export const OsKeypairsCreate210KeypairTypeEnum = {
    Ssh: 'ssh',
    X509: 'x509'
} as const;

export type OsKeypairsCreate210KeypairTypeEnum = typeof OsKeypairsCreate210KeypairTypeEnum[keyof typeof OsKeypairsCreate210KeypairTypeEnum];

/**
 * 
 * @export
 * @interface OsKeypairsCreate21Keypair
 */
export interface OsKeypairsCreate21Keypair {
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate21Keypair
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate21Keypair
     */
    'public_key'?: string;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate292
 */
export interface OsKeypairsCreate292 {
    [key: string]: any;

    /**
     * 
     * @type {OsKeypairsCreate292Keypair}
     * @memberof OsKeypairsCreate292
     */
    'keypair': OsKeypairsCreate292Keypair;
}
/**
 * 
 * @export
 * @interface OsKeypairsCreate292Keypair
 */
export interface OsKeypairsCreate292Keypair {
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate292Keypair
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof OsKeypairsCreate292Keypair
     */
    'type'?: OsKeypairsCreate292KeypairTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate292Keypair
     */
    'public_key': string;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreate292Keypair
     */
    'user_id'?: string;
}

export const OsKeypairsCreate292KeypairTypeEnum = {
    Ssh: 'ssh',
    X509: 'x509'
} as const;

export type OsKeypairsCreate292KeypairTypeEnum = typeof OsKeypairsCreate292KeypairTypeEnum[keyof typeof OsKeypairsCreate292KeypairTypeEnum];

/**
 * 
 * @export
 * @interface OsKeypairsCreateKeypair
 */
export interface OsKeypairsCreateKeypair {
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreateKeypair
     */
    'name': string;
    /**
     * 
     * @type {any}
     * @memberof OsKeypairsCreateKeypair
     */
    'type'?: OsKeypairsCreateKeypairTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OsKeypairsCreateKeypair
     */
    'public_key'?: string;
}

export const OsKeypairsCreateKeypairTypeEnum = {
    Ssh: 'ssh',
    X509: 'x509'
} as const;

export type OsKeypairsCreateKeypairTypeEnum = typeof OsKeypairsCreateKeypairTypeEnum[keyof typeof OsKeypairsCreateKeypairTypeEnum];

/**
 * @type OsKeypairsCreateRequest
 * @export
 */
export type OsKeypairsCreateRequest = OsKeypairsCreate | OsKeypairsCreate20 | OsKeypairsCreate21 | OsKeypairsCreate210 | OsKeypairsCreate292;

/**
 * Keypair object
 * @export
 * @interface OsKeypairsCreateResponse
 */
export interface OsKeypairsCreateResponse {
    /**
     * 
     * @type {OsKeypairsCreateResponseKeypair}
     * @memberof OsKeypairsCreateResponse
     */
    'keypair'?: OsKeypairsCreateResponseKeypair;
}
/**
 * Keypair object
 * @export
 * @interface OsKeypairsCreateResponseKeypair
 */
export interface OsKeypairsCreateResponseKeypair {
    /**
     * The user_id for a keypair.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'user_id'?: any;
    /**
     * A boolean indicates whether this keypair is deleted or not. The value is always false (not deleted).
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'deleted'?: any;
    /**
     * The date and time when the resource was created.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'created_at'?: any;
    /**
     * It is always null.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'deleted_at'?: any;
    /**
     * It is always null.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'updated_at'?: any;
    /**
     * The keypair ID.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'id'?: any;
    /**
     * The name for the keypair
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'name'?: any;
    /**
     * The keypair public key.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'public_key'?: any;
    /**
     * The fingerprint for the keypair.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'fingerprint'?: any;
    /**
     * The type of the keypair. Allowed values are ssh or x509.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'type'?: any;
    /**
     * If you do not provide a public key on create, a new keypair will be built for you, and the private key will be returned during the initial create call. Make sure to save this, as there is no way to get this private key again in the future.
     * @type {any}
     * @memberof OsKeypairsCreateResponseKeypair
     */
    'private_key'?: any;
}
/**
 * 
 * @export
 * @interface OsKeypairsListResponse
 */
export interface OsKeypairsListResponse {
    /**
     * Array of Keypair objects
     * @type {any}
     * @memberof OsKeypairsListResponse
     */
    'keypairs'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsKeypairsListResponse
     */
    'keypairs_links'?: any;
}
/**
 * List of migration objects
 * @export
 * @interface OsMigrationsListResponse
 */
export interface OsMigrationsListResponse {
    /**
     * 
     * @type {any}
     * @memberof OsMigrationsListResponse
     */
    'migrations'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsMigrationsListResponse
     */
    'migrations_links'?: any;
}
/**
 * Empty body for associate_host action
 * @export
 * @interface OsNetworksActionAssociateHostRequest
 */
export interface OsNetworksActionAssociateHostRequest {
    /**
     * 
     * @type {any}
     * @memberof OsNetworksActionAssociateHostRequest
     */
    'associate_host'?: any;
}
/**
 * Empty body for disassociate_host action
 * @export
 * @interface OsNetworksActionDisassociateHostRequest
 */
export interface OsNetworksActionDisassociateHostRequest {
    /**
     * 
     * @type {any}
     * @memberof OsNetworksActionDisassociateHostRequest
     */
    'disassociate_host'?: any;
}
/**
 * Empty body for disassociate_project action
 * @export
 * @interface OsNetworksActionDisassociateProjectRequest
 */
export interface OsNetworksActionDisassociateProjectRequest {
    /**
     * 
     * @type {any}
     * @memberof OsNetworksActionDisassociateProjectRequest
     */
    'disassociate_project'?: any;
}
/**
 * Empty body for disassociate action
 * @export
 * @interface OsNetworksActionDisassociateRequest
 */
export interface OsNetworksActionDisassociateRequest {
    /**
     * 
     * @type {any}
     * @memberof OsNetworksActionDisassociateRequest
     */
    'disassociate'?: any;
}
/**
 * @type OsNetworksIdActionPost201Response
 * @export
 */
export type OsNetworksIdActionPost201Response = any;

/**
 * @type OsNetworksIdActionPostRequest
 * @export
 */
export type OsNetworksIdActionPostRequest = OsNetworksActionAssociateHostRequest | OsNetworksActionDisassociateHostRequest | OsNetworksActionDisassociateProjectRequest | OsNetworksActionDisassociateRequest;

/**
 * 
 * @export
 * @interface OsQuotaClassSetShowResponse
 */
export interface OsQuotaClassSetShowResponse {
    /**
     * 
     * @type {OsQuotaClassSetShowResponseQuotaClassSet}
     * @memberof OsQuotaClassSetShowResponse
     */
    'quota_class_set'?: OsQuotaClassSetShowResponseQuotaClassSet;
}
/**
 * Quota Class Set object
 * @export
 * @interface OsQuotaClassSetShowResponseQuotaClassSet
 */
export interface OsQuotaClassSetShowResponseQuotaClassSet {
    /**
     * The ID of the quota class. Nova supports the default Quota Class only.
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'instances'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'cores'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'ram'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'floating_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'metadata_items'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'key_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'security_group_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'injected_files'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'injected_file_content_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'injected_file_path_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'server_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'server_group_members'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetShowResponseQuotaClassSet
     */
    'networks'?: any;
}
/**
 * 
 * @export
 * @interface OsQuotaClassSetUpdate
 */
export interface OsQuotaClassSetUpdate {
    [key: string]: any;

    /**
     * 
     * @type {OsQuotaClassSetUpdateQuotaClassSet}
     * @memberof OsQuotaClassSetUpdate
     */
    'quota_class_set': OsQuotaClassSetUpdateQuotaClassSet;
}
/**
 * 
 * @export
 * @interface OsQuotaClassSetUpdateQuotaClassSet
 */
export interface OsQuotaClassSetUpdateQuotaClassSet {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'instances'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'cores'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'ram'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'floating_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'metadata_items'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'key_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'security_group_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'injected_files'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'injected_file_content_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'injected_file_path_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'server_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'server_group_members'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaClassSetUpdateQuotaClassSet
     */
    'networks'?: any;
}
/**
 * 
 * @export
 * @interface OsQuotaSetShowResponse
 */
export interface OsQuotaSetShowResponse {
    /**
     * 
     * @type {OsQuotaSetShowResponseQuotaSet}
     * @memberof OsQuotaSetShowResponse
     */
    'quota_set'?: OsQuotaSetShowResponseQuotaSet;
}
/**
 * Quota Set object
 * @export
 * @interface OsQuotaSetShowResponseQuotaSet
 */
export interface OsQuotaSetShowResponseQuotaSet {
    /**
     * The UUID of the tenant/user the quotas listed for.
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'instances'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'cores'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'ram'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'floating_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'metadata_items'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'key_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'security_group_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'injected_files'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'injected_file_content_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'injected_file_path_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'server_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'server_group_members'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetShowResponseQuotaSet
     */
    'networks'?: any;
}
/**
 * 
 * @export
 * @interface OsQuotaSetUpdate
 */
export interface OsQuotaSetUpdate {
    [key: string]: any;

    /**
     * 
     * @type {OsQuotaSetUpdateQuotaSet}
     * @memberof OsQuotaSetUpdate
     */
    'quota_set': OsQuotaSetUpdateQuotaSet;
}
/**
 * 
 * @export
 * @interface OsQuotaSetUpdateQuotaSet
 */
export interface OsQuotaSetUpdateQuotaSet {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'instances'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'cores'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'ram'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'floating_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'metadata_items'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'key_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'security_group_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'injected_files'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'injected_file_content_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'injected_file_path_bytes'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'server_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'server_group_members'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'networks'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsQuotaSetUpdateQuotaSet
     */
    'force'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}


/**
 * 
 * @export
 * @interface OsQuotaSetUpdateResponse
 */
export interface OsQuotaSetUpdateResponse {
    /**
     * 
     * @type {OsQuotaSetShowResponseQuotaSet}
     * @memberof OsQuotaSetUpdateResponse
     */
    'quota_set'?: OsQuotaSetShowResponseQuotaSet;
}
/**
 * 
 * @export
 * @interface OsQuotaSetsDefaultsResponse
 */
export interface OsQuotaSetsDefaultsResponse {
    /**
     * 
     * @type {OsQuotaSetShowResponseQuotaSet}
     * @memberof OsQuotaSetsDefaultsResponse
     */
    'quota_set'?: OsQuotaSetShowResponseQuotaSet;
}
/**
 * 
 * @export
 * @interface OsQuotaSetsDetailResponse
 */
export interface OsQuotaSetsDetailResponse {
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSet}
     * @memberof OsQuotaSetsDetailResponse
     */
    'quota_set'?: OsQuotaSetsDetailResponseQuotaSet;
}
/**
 * A quota_set object.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSet
 */
export interface OsQuotaSetsDetailResponseQuotaSet {
    /**
     * The UUID of the tenant/user the quotas listed for.
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'id'?: any;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetInstances}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'instances'?: OsQuotaSetsDetailResponseQuotaSetInstances;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetCores}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'cores'?: OsQuotaSetsDetailResponseQuotaSetCores;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetRam}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'ram'?: OsQuotaSetsDetailResponseQuotaSetRam;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetFloatingIps}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'floating_ips'?: OsQuotaSetsDetailResponseQuotaSetFloatingIps;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetFixedIps}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'fixed_ips'?: OsQuotaSetsDetailResponseQuotaSetFixedIps;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetMetadataItems}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'metadata_items'?: OsQuotaSetsDetailResponseQuotaSetMetadataItems;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetCores}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'key_pairs'?: OsQuotaSetsDetailResponseQuotaSetCores;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetSecurityGroups}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'security_groups'?: OsQuotaSetsDetailResponseQuotaSetSecurityGroups;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'security_group_rules'?: OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetInjectedFiles}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'injected_files'?: OsQuotaSetsDetailResponseQuotaSetInjectedFiles;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'injected_files_content_bytes'?: OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'injected_files_path_bytes'?: OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetServerGroups}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'server_groups'?: OsQuotaSetsDetailResponseQuotaSetServerGroups;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetServerGroupMembers}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'server_group_members'?: OsQuotaSetsDetailResponseQuotaSetServerGroupMembers;
    /**
     * 
     * @type {OsQuotaSetsDetailResponseQuotaSetNetworks}
     * @memberof OsQuotaSetsDetailResponseQuotaSet
     */
    'networks'?: OsQuotaSetsDetailResponseQuotaSetNetworks;
}
/**
 * The object of detailed key pairs quota, including in_use, limit and reserved number of key pairs.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetCores
 */
export interface OsQuotaSetsDetailResponseQuotaSetCores {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetCores
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetCores
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetCores
     */
    'reserved'?: any;
}
/**
 * The object of detailed fixed ips quota, including in_use, limit and reserved number of fixed ips.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetFixedIps
 */
export interface OsQuotaSetsDetailResponseQuotaSetFixedIps {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFixedIps
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFixedIps
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFixedIps
     */
    'reserved'?: any;
}
/**
 * The object of detailed floating ips quota, including in_use, limit and reserved number of floating ips.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetFloatingIps
 */
export interface OsQuotaSetsDetailResponseQuotaSetFloatingIps {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFloatingIps
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFloatingIps
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetFloatingIps
     */
    'reserved'?: any;
}
/**
 * The object of detailed injected files quota, including in_use, limit and reserved number of injected files.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetInjectedFiles
 */
export interface OsQuotaSetsDetailResponseQuotaSetInjectedFiles {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFiles
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFiles
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFiles
     */
    'reserved'?: any;
}
/**
 * The object of detailed injected file content bytes quota, including in_use, limit and reserved number of injected file content bytes.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes
 */
export interface OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesContentBytes
     */
    'reserved'?: any;
}
/**
 * The object of detailed injected file path bytes quota, including in_use, limit and reserved number of injected file path bytes.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes
 */
export interface OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInjectedFilesPathBytes
     */
    'reserved'?: any;
}
/**
 * The object of detailed servers quota, including in_use, limit and reserved number of instances.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetInstances
 */
export interface OsQuotaSetsDetailResponseQuotaSetInstances {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInstances
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInstances
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetInstances
     */
    'reserved'?: any;
}
/**
 * The object of detailed key metadata items quota, including in_use, limit and reserved number of metadata items.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetMetadataItems
 */
export interface OsQuotaSetsDetailResponseQuotaSetMetadataItems {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetMetadataItems
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetMetadataItems
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetMetadataItems
     */
    'reserved'?: any;
}
/**
 * The number of private networks that can be created per project.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetNetworks
 */
export interface OsQuotaSetsDetailResponseQuotaSetNetworks {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetNetworks
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetNetworks
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetNetworks
     */
    'reserved'?: any;
}
/**
 * The object of detailed key ram quota, including in_use, limit and reserved number of ram.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetRam
 */
export interface OsQuotaSetsDetailResponseQuotaSetRam {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetRam
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetRam
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetRam
     */
    'reserved'?: any;
}
/**
 * The object of detailed security group rules quota, including in_use, limit and reserved number of security group rules.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules
 */
export interface OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroupRules
     */
    'reserved'?: any;
}
/**
 * The object of detailed security groups, including in_use, limit and reserved number of security groups.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetSecurityGroups
 */
export interface OsQuotaSetsDetailResponseQuotaSetSecurityGroups {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroups
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroups
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetSecurityGroups
     */
    'reserved'?: any;
}
/**
 * The object of detailed server group members, including in_use, limit and reserved number of server group members.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetServerGroupMembers
 */
export interface OsQuotaSetsDetailResponseQuotaSetServerGroupMembers {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroupMembers
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroupMembers
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroupMembers
     */
    'reserved'?: any;
}
/**
 * The object of detailed server groups, including in_use, limit and reserved number of server groups.
 * @export
 * @interface OsQuotaSetsDetailResponseQuotaSetServerGroups
 */
export interface OsQuotaSetsDetailResponseQuotaSetServerGroups {
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroups
     */
    'in_use'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroups
     */
    'limit'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsQuotaSetsDetailResponseQuotaSetServerGroups
     */
    'reserved'?: any;
}
/**
 * 
 * @export
 * @interface OsSecurityGroupRulesCreate
 */
export interface OsSecurityGroupRulesCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsSecurityGroupRulesCreateSecurityGroupRule}
     * @memberof OsSecurityGroupRulesCreate
     */
    'security_group_rule': OsSecurityGroupRulesCreateSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface OsSecurityGroupRulesCreateSecurityGroupRule
 */
export interface OsSecurityGroupRulesCreateSecurityGroupRule {
    /**
     * 
     * @type {OsSecurityGroupRulesCreateSecurityGroupRuleGroupId}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'group_id'?: OsSecurityGroupRulesCreateSecurityGroupRuleGroupId;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'parent_group_id': any;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'to_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'from_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'ip_protocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupRulesCreateSecurityGroupRule
     */
    'cidr'?: any;
}
/**
 * @type OsSecurityGroupRulesCreateSecurityGroupRuleGroupId
 * @export
 */
export type OsSecurityGroupRulesCreateSecurityGroupRuleGroupId = any;

/**
 * 
 * @export
 * @interface OsSecurityGroupUpdate
 */
export interface OsSecurityGroupUpdate {
    /**
     * 
     * @type {OsSecurityGroupsCreateSecurityGroup}
     * @memberof OsSecurityGroupUpdate
     */
    'security_group': OsSecurityGroupsCreateSecurityGroup;
}
/**
 * 
 * @export
 * @interface OsSecurityGroupsCreate
 */
export interface OsSecurityGroupsCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsSecurityGroupsCreateSecurityGroup}
     * @memberof OsSecurityGroupsCreate
     */
    'security_group': OsSecurityGroupsCreateSecurityGroup;
}
/**
 * 
 * @export
 * @interface OsSecurityGroupsCreateSecurityGroup
 */
export interface OsSecurityGroupsCreateSecurityGroup {
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupsCreateSecurityGroup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof OsSecurityGroupsCreateSecurityGroup
     */
    'description': any;
}
/**
 * 
 * @export
 * @interface OsServerExternalEventsCreate20
 */
export interface OsServerExternalEventsCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsServerExternalEventsCreate20
     */
    'events': any;
}
/**
 * 
 * @export
 * @interface OsServerExternalEventsCreate251
 */
export interface OsServerExternalEventsCreate251 {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsServerExternalEventsCreate251
     */
    'events': any;
}
/**
 * 
 * @export
 * @interface OsServerExternalEventsCreate276
 */
export interface OsServerExternalEventsCreate276 {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsServerExternalEventsCreate276
     */
    'events': any;
}
/**
 * 
 * @export
 * @interface OsServerExternalEventsCreate282
 */
export interface OsServerExternalEventsCreate282 {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsServerExternalEventsCreate282
     */
    'events': any;
}
/**
 * 
 * @export
 * @interface OsServerExternalEventsCreate293
 */
export interface OsServerExternalEventsCreate293 {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsServerExternalEventsCreate293
     */
    'events': any;
}
/**
 * @type OsServerExternalEventsCreateRequest
 * @export
 */
export type OsServerExternalEventsCreateRequest = OsServerExternalEventsCreate20 | OsServerExternalEventsCreate251 | OsServerExternalEventsCreate276 | OsServerExternalEventsCreate282 | OsServerExternalEventsCreate293;

/**
 * 
 * @export
 * @interface OsServerExternalEventsCreateResponse
 */
export interface OsServerExternalEventsCreateResponse {
    /**
     * List of external events to process.
     * @type {any}
     * @memberof OsServerExternalEventsCreateResponse
     */
    'events'?: any;
}
/**
 * 
 * @export
 * @interface OsServerGroupShowResponse
 */
export interface OsServerGroupShowResponse {
    /**
     * 
     * @type {OsServerGroupsCreateResponseServerGroup}
     * @memberof OsServerGroupShowResponse
     */
    'server_group'?: OsServerGroupsCreateResponseServerGroup;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate20
 */
export interface OsServerGroupsCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsServerGroupsCreate20ServerGroup}
     * @memberof OsServerGroupsCreate20
     */
    'server_group': OsServerGroupsCreate20ServerGroup;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate20ServerGroup
 */
export interface OsServerGroupsCreate20ServerGroup {
    /**
     * 
     * @type {any}
     * @memberof OsServerGroupsCreate20ServerGroup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof OsServerGroupsCreate20ServerGroup
     */
    'policies': any;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate215
 */
export interface OsServerGroupsCreate215 {
    [key: string]: any;

    /**
     * 
     * @type {OsServerGroupsCreate20ServerGroup}
     * @memberof OsServerGroupsCreate215
     */
    'server_group': OsServerGroupsCreate20ServerGroup;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate264
 */
export interface OsServerGroupsCreate264 {
    [key: string]: any;

    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroup}
     * @memberof OsServerGroupsCreate264
     */
    'server_group': OsServerGroupsCreate264ServerGroup;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate264ServerGroup
 */
export interface OsServerGroupsCreate264ServerGroup {
    /**
     * 
     * @type {any}
     * @memberof OsServerGroupsCreate264ServerGroup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof OsServerGroupsCreate264ServerGroup
     */
    'policy': OsServerGroupsCreate264ServerGroupPolicyEnum;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRules}
     * @memberof OsServerGroupsCreate264ServerGroup
     */
    'rules'?: OsServerGroupsCreate264ServerGroupRules;
}

export const OsServerGroupsCreate264ServerGroupPolicyEnum = {
    AntiAffinity: 'anti-affinity',
    Affinity: 'affinity',
    SoftAntiAffinity: 'soft-anti-affinity',
    SoftAffinity: 'soft-affinity'
} as const;

export type OsServerGroupsCreate264ServerGroupPolicyEnum = typeof OsServerGroupsCreate264ServerGroupPolicyEnum[keyof typeof OsServerGroupsCreate264ServerGroupPolicyEnum];

/**
 * 
 * @export
 * @interface OsServerGroupsCreate264ServerGroupRules
 */
export interface OsServerGroupsCreate264ServerGroupRules {
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsServerGroupsCreate264ServerGroupRules
     */
    'max_server_per_host'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost
 */
export interface OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost {
}
/**
 * @type OsServerGroupsCreateRequest
 * @export
 */
export type OsServerGroupsCreateRequest = OsServerGroupsCreate20 | OsServerGroupsCreate215 | OsServerGroupsCreate264;

/**
 * 
 * @export
 * @interface OsServerGroupsCreateResponse
 */
export interface OsServerGroupsCreateResponse {
    /**
     * 
     * @type {OsServerGroupsCreateResponseServerGroup}
     * @memberof OsServerGroupsCreateResponse
     */
    'server_group'?: OsServerGroupsCreateResponseServerGroup;
}
/**
 * 
 * @export
 * @interface OsServerGroupsCreateResponseServerGroup
 */
export interface OsServerGroupsCreateResponseServerGroup {
    /**
     * The UUID of the server group.
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'id'?: any;
    /**
     * The list of members in the server group
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'members'?: any;
    /**
     * Metadata key and value pairs. The maximum size for each metadata key and value pair is 255 bytes. It’s always empty and only used for keeping compatibility.
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'metadata'?: any;
    /**
     * A name identifying the server group
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'name'?: any;
    /**
     * A list of exactly one policy name to associate with the server group.
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'policies'?: any;
    /**
     * The policy field represents the name of the policy
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'policy'?: OsServerGroupsCreateResponseServerGroupPolicyEnum;
    /**
     * The project ID who owns the server group.
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'project_id'?: any;
    /**
     * 
     * @type {OsServerGroupsCreateResponseServerGroupRules}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'rules'?: OsServerGroupsCreateResponseServerGroupRules;
    /**
     * The user ID who owns the server group
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroup
     */
    'user_id'?: any;
}

export const OsServerGroupsCreateResponseServerGroupPolicyEnum = {
    AntiAffinity: 'anti-affinity',
    Affinity: 'affinity',
    SoftAntiAffinity: 'soft-anti-affinity',
    SoftAffinity: 'soft-affinity'
} as const;

export type OsServerGroupsCreateResponseServerGroupPolicyEnum = typeof OsServerGroupsCreateResponseServerGroupPolicyEnum[keyof typeof OsServerGroupsCreateResponseServerGroupPolicyEnum];

/**
 * The rules field, which is a dict, can be applied to the policy. Currently, only the max_server_per_host rule is supported for the anti-affinity policy. The max_server_per_host rule allows specifying how many members of the anti-affinity group can reside on the same compute host. If not specified, only one member from the same anti-affinity group can reside on a given host.
 * @export
 * @interface OsServerGroupsCreateResponseServerGroupRules
 */
export interface OsServerGroupsCreateResponseServerGroupRules {
    /**
     * 
     * @type {any}
     * @memberof OsServerGroupsCreateResponseServerGroupRules
     */
    'max_server_per_host'?: any;
}
/**
 * 
 * @export
 * @interface OsServerGroupsListResponse
 */
export interface OsServerGroupsListResponse {
    /**
     * The list of existing server groups.
     * @type {any}
     * @memberof OsServerGroupsListResponse
     */
    'server_groups'?: any;
}
/**
 * 
 * @export
 * @interface OsServiceUpdate20
 */
export interface OsServiceUpdate20 {
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate20
     */
    'host': any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate20
     */
    'binary': any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate20
     */
    'disabled_reason'?: any;
}
/**
 * 
 * @export
 * @interface OsServiceUpdate211
 */
export interface OsServiceUpdate211 {
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate211
     */
    'host': any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate211
     */
    'binary': any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate211
     */
    'disabled_reason'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate211
     */
    'forced_down'?: OsServiceUpdate211ForcedDownEnum;
}

export const OsServiceUpdate211ForcedDownEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type OsServiceUpdate211ForcedDownEnum = typeof OsServiceUpdate211ForcedDownEnum[keyof typeof OsServiceUpdate211ForcedDownEnum];

/**
 * 
 * @export
 * @interface OsServiceUpdate253
 */
export interface OsServiceUpdate253 {
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate253
     */
    'status'?: OsServiceUpdate253StatusEnum;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate253
     */
    'disabled_reason'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsServiceUpdate253
     */
    'forced_down'?: OsServiceUpdate253ForcedDownEnum;
}

export const OsServiceUpdate253StatusEnum = {
    Enabled: 'enabled',
    Disabled: 'disabled'
} as const;

export type OsServiceUpdate253StatusEnum = typeof OsServiceUpdate253StatusEnum[keyof typeof OsServiceUpdate253StatusEnum];
export const OsServiceUpdate253ForcedDownEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type OsServiceUpdate253ForcedDownEnum = typeof OsServiceUpdate253ForcedDownEnum[keyof typeof OsServiceUpdate253ForcedDownEnum];

/**
 * @type OsServiceUpdateRequest
 * @export
 */
export type OsServiceUpdateRequest = OsServiceUpdate20 | OsServiceUpdate211 | OsServiceUpdate253;

/**
 * 
 * @export
 * @interface OsServiceUpdateResponse
 */
export interface OsServiceUpdateResponse {
    /**
     * 
     * @type {OsServiceUpdateResponseService}
     * @memberof OsServiceUpdateResponse
     */
    'service'?: OsServiceUpdateResponseService;
}
/**
 * 
 * @export
 * @interface OsServiceUpdateResponseService
 */
export interface OsServiceUpdateResponseService {
    /**
     * The availability zone of service
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'zone'?: any;
    /**
     * Binary name of service
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'binary'?: any;
    /**
     * Disabled reason of service
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'disabled_reason'?: any;
    /**
     * The name of the host where service runs
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'host'?: any;
    /**
     * Id of the resource
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'id'?: any;
    /**
     * Whether or not this service was forced down manually by an administrator after the service was fenced
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'forced_down'?: any;
    /**
     * Service name
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'name'?: any;
    /**
     * State of service
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'state'?: any;
    /**
     * Status of service
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'status'?: OsServiceUpdateResponseServiceStatusEnum;
    /**
     * The date and time when the resource was updated
     * @type {any}
     * @memberof OsServiceUpdateResponseService
     */
    'updated_at'?: any;
}

export const OsServiceUpdateResponseServiceStatusEnum = {
    Disabled: 'disabled',
    Enabled: 'enabled'
} as const;

export type OsServiceUpdateResponseServiceStatusEnum = typeof OsServiceUpdateResponseServiceStatusEnum[keyof typeof OsServiceUpdateResponseServiceStatusEnum];

/**
 * 
 * @export
 * @interface OsServicesListResponse
 */
export interface OsServicesListResponse {
    /**
     * A list of service objects.
     * @type {any}
     * @memberof OsServicesListResponse
     */
    'services'?: any;
}
/**
 * 
 * @export
 * @interface OsSimpleTenantUsageListResponse
 */
export interface OsSimpleTenantUsageListResponse {
    /**
     * A list of the tenant usage objects.
     * @type {any}
     * @memberof OsSimpleTenantUsageListResponse
     */
    'tenant_usages'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsSimpleTenantUsageListResponse
     */
    'tenant_usages_links'?: any;
}
/**
 * 
 * @export
 * @interface OsSimpleTenantUsageShowResponse
 */
export interface OsSimpleTenantUsageShowResponse {
    /**
     * A list of the tenant usage objects.
     * @type {any}
     * @memberof OsSimpleTenantUsageShowResponse
     */
    'tenant_usages'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof OsSimpleTenantUsageShowResponse
     */
    'tenant_usages_links'?: any;
}
/**
 * 
 * @export
 * @interface OsSnapshotsCreate
 */
export interface OsSnapshotsCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsSnapshotsCreateSnapshot}
     * @memberof OsSnapshotsCreate
     */
    'snapshot': OsSnapshotsCreateSnapshot;
}
/**
 * 
 * @export
 * @interface OsSnapshotsCreateSnapshot
 */
export interface OsSnapshotsCreateSnapshot {
    /**
     * 
     * @type {string}
     * @memberof OsSnapshotsCreateSnapshot
     */
    'volume_id': string;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsSnapshotsCreateSnapshot
     */
    'force'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {string}
     * @memberof OsSnapshotsCreateSnapshot
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsSnapshotsCreateSnapshot
     */
    'display_description'?: string;
}


/**
 * 
 * @export
 * @interface OsVolumesBootActionActionConfirmResize
 */
export interface OsVolumesBootActionActionConfirmResize {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionConfirmResize
     */
    'confirmResize': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionCreateImage20
 */
export interface OsVolumesBootActionActionCreateImage20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionCreateImage20CreateImage}
     * @memberof OsVolumesBootActionActionCreateImage20
     */
    'createImage': OsVolumesBootActionActionCreateImage20CreateImage;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionCreateImage20CreateImage
 */
export interface OsVolumesBootActionActionCreateImage20CreateImage {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionCreateImage20CreateImage
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionCreateImage20CreateImage
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionCreateImage21
 */
export interface OsVolumesBootActionActionCreateImage21 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionCreateImage20CreateImage}
     * @memberof OsVolumesBootActionActionCreateImage21
     */
    'createImage': OsVolumesBootActionActionCreateImage20CreateImage;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionReboot
 */
export interface OsVolumesBootActionActionReboot {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebootReboot}
     * @memberof OsVolumesBootActionActionReboot
     */
    'reboot': OsVolumesBootActionActionRebootReboot;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebootReboot
 */
export interface OsVolumesBootActionActionRebootReboot {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebootReboot
     */
    'type': OsVolumesBootActionActionRebootRebootTypeEnum;
}

export const OsVolumesBootActionActionRebootRebootTypeEnum = {
    Hard: 'HARD',
    Hard2: 'Hard',
    Hard3: 'hard',
    Soft: 'SOFT',
    Soft2: 'Soft',
    Soft3: 'soft'
} as const;

export type OsVolumesBootActionActionRebootRebootTypeEnum = typeof OsVolumesBootActionActionRebootRebootTypeEnum[keyof typeof OsVolumesBootActionActionRebootRebootTypeEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild20
 */
export interface OsVolumesBootActionActionRebuild20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild20Rebuild}
     * @memberof OsVolumesBootActionActionRebuild20
     */
    'rebuild': OsVolumesBootActionActionRebuild20Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild20Rebuild
 */
export interface OsVolumesBootActionActionRebuild20Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild20RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild20Rebuild
     */
    'personality'?: any;
}

export const OsVolumesBootActionActionRebuild20RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild20RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild20RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild20RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild21
 */
export interface OsVolumesBootActionActionRebuild21 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild21Rebuild}
     * @memberof OsVolumesBootActionActionRebuild21
     */
    'rebuild': OsVolumesBootActionActionRebuild21Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild219
 */
export interface OsVolumesBootActionActionRebuild219 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild219Rebuild}
     * @memberof OsVolumesBootActionActionRebuild219
     */
    'rebuild': OsVolumesBootActionActionRebuild219Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild219Rebuild
 */
export interface OsVolumesBootActionActionRebuild219Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild219RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild219Rebuild
     */
    'description'?: any;
}

export const OsVolumesBootActionActionRebuild219RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild219RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild219RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild219RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild21Rebuild
 */
export interface OsVolumesBootActionActionRebuild21Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild21RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild21Rebuild
     */
    'personality'?: any;
}

export const OsVolumesBootActionActionRebuild21RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild21RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild21RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild21RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild254
 */
export interface OsVolumesBootActionActionRebuild254 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254Rebuild}
     * @memberof OsVolumesBootActionActionRebuild254
     */
    'rebuild': OsVolumesBootActionActionRebuild254Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild254Rebuild
 */
export interface OsVolumesBootActionActionRebuild254Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild254RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof OsVolumesBootActionActionRebuild254Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
}

export const OsVolumesBootActionActionRebuild254RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild254RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild254RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild254RebuildOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootActionActionRebuild254RebuildKeyName
 * @export
 */
export type OsVolumesBootActionActionRebuild254RebuildKeyName = any;

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild257
 */
export interface OsVolumesBootActionActionRebuild257 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild257Rebuild}
     * @memberof OsVolumesBootActionActionRebuild257
     */
    'rebuild': OsVolumesBootActionActionRebuild257Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild257Rebuild
 */
export interface OsVolumesBootActionActionRebuild257Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild257RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof OsVolumesBootActionActionRebuild257Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
}

export const OsVolumesBootActionActionRebuild257RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild257RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild257RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild257RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild263
 */
export interface OsVolumesBootActionActionRebuild263 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild263Rebuild}
     * @memberof OsVolumesBootActionActionRebuild263
     */
    'rebuild': OsVolumesBootActionActionRebuild263Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild263Rebuild
 */
export interface OsVolumesBootActionActionRebuild263Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild263RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild263Rebuild
     */
    'trusted_image_certificates'?: any;
}

export const OsVolumesBootActionActionRebuild263RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild263RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild263RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild263RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild290
 */
export interface OsVolumesBootActionActionRebuild290 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild290Rebuild}
     * @memberof OsVolumesBootActionActionRebuild290
     */
    'rebuild': OsVolumesBootActionActionRebuild290Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild290Rebuild
 */
export interface OsVolumesBootActionActionRebuild290Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild290RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild290Rebuild
     */
    'hostname'?: any;
}

export const OsVolumesBootActionActionRebuild290RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild290RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild290RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild290RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild294
 */
export interface OsVolumesBootActionActionRebuild294 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionRebuild294Rebuild}
     * @memberof OsVolumesBootActionActionRebuild294
     */
    'rebuild': OsVolumesBootActionActionRebuild294Rebuild;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRebuild294Rebuild
 */
export interface OsVolumesBootActionActionRebuild294Rebuild {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'preserve_ephemeral'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionRebuild294RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionActionRebuild294Rebuild
     */
    'hostname'?: string;
}

export const OsVolumesBootActionActionRebuild294RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionRebuild294RebuildOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionRebuild294RebuildOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionRebuild294RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionResize
 */
export interface OsVolumesBootActionActionResize {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionActionResizeResize}
     * @memberof OsVolumesBootActionActionResize
     */
    'resize': OsVolumesBootActionActionResizeResize;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionResizeResize
 */
export interface OsVolumesBootActionActionResizeResize {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionResizeResize
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionResizeResize
     */
    'OS-DCF:diskConfig'?: OsVolumesBootActionActionResizeResizeOSDCFdiskConfigEnum;
}

export const OsVolumesBootActionActionResizeResizeOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootActionActionResizeResizeOSDCFdiskConfigEnum = typeof OsVolumesBootActionActionResizeResizeOSDCFdiskConfigEnum[keyof typeof OsVolumesBootActionActionResizeResizeOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionActionRevertResize
 */
export interface OsVolumesBootActionActionRevertResize {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionRevertResize
     */
    'revertResize': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionActionTriggerCrashDump
 */
export interface OsVolumesBootActionActionTriggerCrashDump {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionActionTriggerCrashDump
     */
    'trigger_crash_dump': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionAddFixedIp
 */
export interface OsVolumesBootActionAddFixedIp {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionAddFixedIpAddFixedIp}
     * @memberof OsVolumesBootActionAddFixedIp
     */
    'addFixedIp': OsVolumesBootActionAddFixedIpAddFixedIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionAddFixedIpAddFixedIp
 */
export interface OsVolumesBootActionAddFixedIpAddFixedIp {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionAddFixedIpAddFixedIp
     */
    'networkId': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionAddFloatingIp
 */
export interface OsVolumesBootActionAddFloatingIp {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionAddFloatingIpAddFloatingIp}
     * @memberof OsVolumesBootActionAddFloatingIp
     */
    'addFloatingIp': OsVolumesBootActionAddFloatingIpAddFloatingIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionAddFloatingIpAddFloatingIp
 */
export interface OsVolumesBootActionAddFloatingIpAddFloatingIp {
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp}
     * @memberof OsVolumesBootActionAddFloatingIpAddFloatingIp
     */
    'address': OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp}
     * @memberof OsVolumesBootActionAddFloatingIpAddFloatingIp
     */
    'fixed_address'?: OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionAddsecuritygroup
 */
export interface OsVolumesBootActionAddsecuritygroup {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionAddsecuritygroup
     */
    'name'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionChangePassword
 */
export interface OsVolumesBootActionChangePassword {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionChangePasswordChangePassword}
     * @memberof OsVolumesBootActionChangePassword
     */
    'changePassword': OsVolumesBootActionChangePasswordChangePassword;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionChangePasswordChangePassword
 */
export interface OsVolumesBootActionChangePasswordChangePassword {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionChangePasswordChangePassword
     */
    'adminPass': string;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionCreateBackup20
 */
export interface OsVolumesBootActionCreateBackup20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionCreateBackup20CreateBackup}
     * @memberof OsVolumesBootActionCreateBackup20
     */
    'createBackup': OsVolumesBootActionCreateBackup20CreateBackup;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionCreateBackup20CreateBackup
 */
export interface OsVolumesBootActionCreateBackup20CreateBackup {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionCreateBackup20CreateBackup
     */
    'name': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionCreateBackup20CreateBackup
     */
    'backup_type': string;
    /**
     * 
     * @type {OsVolumesBootActionCreateBackup20CreateBackupRotation}
     * @memberof OsVolumesBootActionCreateBackup20CreateBackup
     */
    'rotation': OsVolumesBootActionCreateBackup20CreateBackupRotation;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionCreateBackup20CreateBackup
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionCreateBackup20CreateBackupRotation
 */
export interface OsVolumesBootActionCreateBackup20CreateBackupRotation {
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionCreateBackup21
 */
export interface OsVolumesBootActionCreateBackup21 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionCreateBackup21CreateBackup}
     * @memberof OsVolumesBootActionCreateBackup21
     */
    'createBackup': OsVolumesBootActionCreateBackup21CreateBackup;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionCreateBackup21CreateBackup
 */
export interface OsVolumesBootActionCreateBackup21CreateBackup {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionCreateBackup21CreateBackup
     */
    'name': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionCreateBackup21CreateBackup
     */
    'backup_type': string;
    /**
     * 
     * @type {OsVolumesBootActionCreateBackup20CreateBackupRotation}
     * @memberof OsVolumesBootActionCreateBackup21CreateBackup
     */
    'rotation': OsVolumesBootActionCreateBackup20CreateBackupRotation;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionCreateBackup21CreateBackup
     */
    'metadata'?: any;
}
/**
 * @type OsVolumesBootActionCreatebackupRequest
 * @export
 */
export type OsVolumesBootActionCreatebackupRequest = OsVolumesBootActionCreateBackup20 | OsVolumesBootActionCreateBackup21;

/**
 * @type OsVolumesBootActionCreateimageRequest
 * @export
 */
export type OsVolumesBootActionCreateimageRequest = OsVolumesBootActionActionCreateImage20 | OsVolumesBootActionActionCreateImage21;

/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate20
 */
export interface OsVolumesBootActionEvacuate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionEvacuate20Evacuate}
     * @memberof OsVolumesBootActionEvacuate20
     */
    'evacuate': OsVolumesBootActionEvacuate20Evacuate;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate20Evacuate
 */
export interface OsVolumesBootActionEvacuate20Evacuate {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate20Evacuate
     */
    'host'?: string;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionEvacuate20Evacuate
     */
    'onSharedStorage': FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate20Evacuate
     */
    'adminPass'?: string;
}


/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate214
 */
export interface OsVolumesBootActionEvacuate214 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionEvacuate214Evacuate}
     * @memberof OsVolumesBootActionEvacuate214
     */
    'evacuate': OsVolumesBootActionEvacuate214Evacuate;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate214Evacuate
 */
export interface OsVolumesBootActionEvacuate214Evacuate {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate214Evacuate
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate214Evacuate
     */
    'adminPass'?: string;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate229
 */
export interface OsVolumesBootActionEvacuate229 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionEvacuate229Evacuate}
     * @memberof OsVolumesBootActionEvacuate229
     */
    'evacuate': OsVolumesBootActionEvacuate229Evacuate;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate229Evacuate
 */
export interface OsVolumesBootActionEvacuate229Evacuate {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate229Evacuate
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionEvacuate229Evacuate
     */
    'adminPass'?: string;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionEvacuate229Evacuate
     */
    'force'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}


/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate268
 */
export interface OsVolumesBootActionEvacuate268 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionEvacuate268Evacuate}
     * @memberof OsVolumesBootActionEvacuate268
     */
    'evacuate': OsVolumesBootActionEvacuate268Evacuate;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate268Evacuate
 */
export interface OsVolumesBootActionEvacuate268Evacuate {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionEvacuate268Evacuate
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionEvacuate268Evacuate
     */
    'adminPass'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionEvacuate295
 */
export interface OsVolumesBootActionEvacuate295 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionEvacuate268Evacuate}
     * @memberof OsVolumesBootActionEvacuate295
     */
    'evacuate': OsVolumesBootActionEvacuate268Evacuate;
}
/**
 * @type OsVolumesBootActionEvacuateRequest
 * @export
 */
export type OsVolumesBootActionEvacuateRequest = OsVolumesBootActionEvacuate20 | OsVolumesBootActionEvacuate214 | OsVolumesBootActionEvacuate229 | OsVolumesBootActionEvacuate268 | OsVolumesBootActionEvacuate295;

/**
 * 
 * @export
 * @interface OsVolumesBootActionForceDelete
 */
export interface OsVolumesBootActionForceDelete {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionForceDelete
     */
    'forceDelete': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetConsoleOutput
 */
export interface OsVolumesBootActionGetConsoleOutput {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput}
     * @memberof OsVolumesBootActionGetConsoleOutput
     */
    'os-getConsoleOutput': OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput
 */
export interface OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput
     */
    'length'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetSerialConsole
 */
export interface OsVolumesBootActionGetSerialConsole {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionGetSerialConsoleOsGetSerialConsole}
     * @memberof OsVolumesBootActionGetSerialConsole
     */
    'os-getSerialConsole': OsVolumesBootActionGetSerialConsoleOsGetSerialConsole;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetSerialConsoleOsGetSerialConsole
 */
export interface OsVolumesBootActionGetSerialConsoleOsGetSerialConsole {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionGetSerialConsoleOsGetSerialConsole
     */
    'type': OsVolumesBootActionGetSerialConsoleOsGetSerialConsoleTypeEnum;
}

export const OsVolumesBootActionGetSerialConsoleOsGetSerialConsoleTypeEnum = {
    Serial: 'serial'
} as const;

export type OsVolumesBootActionGetSerialConsoleOsGetSerialConsoleTypeEnum = typeof OsVolumesBootActionGetSerialConsoleOsGetSerialConsoleTypeEnum[keyof typeof OsVolumesBootActionGetSerialConsoleOsGetSerialConsoleTypeEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionGetSpiceConsole
 */
export interface OsVolumesBootActionGetSpiceConsole {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole}
     * @memberof OsVolumesBootActionGetSpiceConsole
     */
    'os-getSPICEConsole': OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole
 */
export interface OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole
     */
    'type': OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsoleTypeEnum;
}

export const OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsoleTypeEnum = {
    SpiceHtml5: 'spice-html5'
} as const;

export type OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsoleTypeEnum = typeof OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsoleTypeEnum[keyof typeof OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsoleTypeEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionGetVncConsole
 */
export interface OsVolumesBootActionGetVncConsole {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionGetVncConsoleOsGetVNCConsole}
     * @memberof OsVolumesBootActionGetVncConsole
     */
    'os-getVNCConsole': OsVolumesBootActionGetVncConsoleOsGetVNCConsole;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionGetVncConsoleOsGetVNCConsole
 */
export interface OsVolumesBootActionGetVncConsoleOsGetVNCConsole {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionGetVncConsoleOsGetVNCConsole
     */
    'type': OsVolumesBootActionGetVncConsoleOsGetVNCConsoleTypeEnum;
}

export const OsVolumesBootActionGetVncConsoleOsGetVNCConsoleTypeEnum = {
    Novnc: 'novnc',
    Xvpvnc: 'xvpvnc'
} as const;

export type OsVolumesBootActionGetVncConsoleOsGetVNCConsoleTypeEnum = typeof OsVolumesBootActionGetVncConsoleOsGetVNCConsoleTypeEnum[keyof typeof OsVolumesBootActionGetVncConsoleOsGetVNCConsoleTypeEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionInjectNetworkInfo
 */
export interface OsVolumesBootActionInjectNetworkInfo {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionInjectNetworkInfo
     */
    'injectNetworkInfo': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionLock21
 */
export interface OsVolumesBootActionLock21 {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionLock21
     */
    'lock': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionLock273
 */
export interface OsVolumesBootActionLock273 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionLock273Lock}
     * @memberof OsVolumesBootActionLock273
     */
    'lock': OsVolumesBootActionLock273Lock;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionLock273Lock
 */
export interface OsVolumesBootActionLock273Lock {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionLock273Lock
     */
    'locked_reason'?: any;
}
/**
 * @type OsVolumesBootActionLockRequest
 * @export
 */
export type OsVolumesBootActionLockRequest = OsVolumesBootActionLock21 | OsVolumesBootActionLock273;

/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrate256
 */
export interface OsVolumesBootActionMigrate256 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionMigrate256Migrate}
     * @memberof OsVolumesBootActionMigrate256
     */
    'migrate': OsVolumesBootActionMigrate256Migrate;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrate256Migrate
 */
export interface OsVolumesBootActionMigrate256Migrate {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrate256Migrate
     */
    'host'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive20
 */
export interface OsVolumesBootActionMigrateLive20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionMigrateLive20OsMigrateLive}
     * @memberof OsVolumesBootActionMigrateLive20
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive20OsMigrateLive;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive20OsMigrateLive
 */
export interface OsVolumesBootActionMigrateLive20OsMigrateLive {
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionMigrateLive20OsMigrateLive
     */
    'block_migration': FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionMigrateLive20OsMigrateLive
     */
    'disk_over_commit': FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrateLive20OsMigrateLive
     */
    'host': any;
}


/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive225
 */
export interface OsVolumesBootActionMigrateLive225 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionMigrateLive225OsMigrateLive}
     * @memberof OsVolumesBootActionMigrateLive225
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive225OsMigrateLive;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive225OsMigrateLive
 */
export interface OsVolumesBootActionMigrateLive225OsMigrateLive {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrateLive225OsMigrateLive
     */
    'block_migration': OsVolumesBootActionMigrateLive225OsMigrateLiveBlockMigrationEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrateLive225OsMigrateLive
     */
    'host': any;
}

export const OsVolumesBootActionMigrateLive225OsMigrateLiveBlockMigrationEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false',
    Auto: 'auto'
} as const;

export type OsVolumesBootActionMigrateLive225OsMigrateLiveBlockMigrationEnum = typeof OsVolumesBootActionMigrateLive225OsMigrateLiveBlockMigrationEnum[keyof typeof OsVolumesBootActionMigrateLive225OsMigrateLiveBlockMigrationEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive230
 */
export interface OsVolumesBootActionMigrateLive230 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionMigrateLive230OsMigrateLive}
     * @memberof OsVolumesBootActionMigrateLive230
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive230OsMigrateLive;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive230OsMigrateLive
 */
export interface OsVolumesBootActionMigrateLive230OsMigrateLive {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrateLive230OsMigrateLive
     */
    'block_migration': OsVolumesBootActionMigrateLive230OsMigrateLiveBlockMigrationEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionMigrateLive230OsMigrateLive
     */
    'host': any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootActionMigrateLive230OsMigrateLive
     */
    'force'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}

export const OsVolumesBootActionMigrateLive230OsMigrateLiveBlockMigrationEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false',
    Auto: 'auto'
} as const;

export type OsVolumesBootActionMigrateLive230OsMigrateLiveBlockMigrationEnum = typeof OsVolumesBootActionMigrateLive230OsMigrateLiveBlockMigrationEnum[keyof typeof OsVolumesBootActionMigrateLive230OsMigrateLiveBlockMigrationEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootActionMigrateLive268
 */
export interface OsVolumesBootActionMigrateLive268 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionMigrateLive225OsMigrateLive}
     * @memberof OsVolumesBootActionMigrateLive268
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive225OsMigrateLive;
}
/**
 * Empty body for os-getRDPConsole action
 * @export
 * @interface OsVolumesBootActionOsGetrdpconsoleRequest
 */
export interface OsVolumesBootActionOsGetrdpconsoleRequest {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionOsGetrdpconsoleRequest
     */
    'os-getRDPConsole'?: any;
}
/**
 * @type OsVolumesBootActionOsMigrateliveRequest
 * @export
 */
export type OsVolumesBootActionOsMigrateliveRequest = OsVolumesBootActionMigrateLive20 | OsVolumesBootActionMigrateLive225 | OsVolumesBootActionMigrateLive230 | OsVolumesBootActionMigrateLive268;

/**
 * 
 * @export
 * @interface OsVolumesBootActionPause
 */
export interface OsVolumesBootActionPause {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionPause
     */
    'pause': any;
}
/**
 * @type OsVolumesBootActionRebuildRequest
 * @export
 */
export type OsVolumesBootActionRebuildRequest = OsVolumesBootActionActionRebuild20 | OsVolumesBootActionActionRebuild21 | OsVolumesBootActionActionRebuild219 | OsVolumesBootActionActionRebuild254 | OsVolumesBootActionActionRebuild257 | OsVolumesBootActionActionRebuild263 | OsVolumesBootActionActionRebuild290 | OsVolumesBootActionActionRebuild294;

/**
 * 
 * @export
 * @interface OsVolumesBootActionRemoveFixedIp
 */
export interface OsVolumesBootActionRemoveFixedIp {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp}
     * @memberof OsVolumesBootActionRemoveFixedIp
     */
    'removeFixedIp': OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRemoveFloatingIp
 */
export interface OsVolumesBootActionRemoveFloatingIp {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp}
     * @memberof OsVolumesBootActionRemoveFloatingIp
     */
    'removeFloatingIp': OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp
 */
export interface OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp {
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp}
     * @memberof OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp
     */
    'address': OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRemovesecuritygroup
 */
export interface OsVolumesBootActionRemovesecuritygroup {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionRemovesecuritygroup
     */
    'name'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRescue
 */
export interface OsVolumesBootActionRescue {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionRescueRescue}
     * @memberof OsVolumesBootActionRescue
     */
    'rescue': OsVolumesBootActionRescueRescue;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRescueRescue
 */
export interface OsVolumesBootActionRescueRescue {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionRescueRescue
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionRescueRescue
     */
    'rescue_image_ref'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionResetState
 */
export interface OsVolumesBootActionResetState {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionResetStateOsResetState}
     * @memberof OsVolumesBootActionResetState
     */
    'os-resetState': OsVolumesBootActionResetStateOsResetState;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionResetStateOsResetState
 */
export interface OsVolumesBootActionResetStateOsResetState {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionResetStateOsResetState
     */
    'state': OsVolumesBootActionResetStateOsResetStateStateEnum;
}

export const OsVolumesBootActionResetStateOsResetStateStateEnum = {
    Active: 'active',
    Error: 'error'
} as const;

export type OsVolumesBootActionResetStateOsResetStateStateEnum = typeof OsVolumesBootActionResetStateOsResetStateStateEnum[keyof typeof OsVolumesBootActionResetStateOsResetStateStateEnum];

/**
 * Empty body for resetNetwork action
 * @export
 * @interface OsVolumesBootActionResetnetworkRequest
 */
export interface OsVolumesBootActionResetnetworkRequest {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionResetnetworkRequest
     */
    'resetNetwork'?: any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionRestore
 */
export interface OsVolumesBootActionRestore {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionRestore
     */
    'restore': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionResume
 */
export interface OsVolumesBootActionResume {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionResume
     */
    'resume': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionShelve
 */
export interface OsVolumesBootActionShelve {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionShelve
     */
    'shelve': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionShelveOffload
 */
export interface OsVolumesBootActionShelveOffload {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionShelveOffload
     */
    'shelveOffload': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionStartServer
 */
export interface OsVolumesBootActionStartServer {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionStartServer
     */
    'os-start': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionStopServer
 */
export interface OsVolumesBootActionStopServer {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionStopServer
     */
    'os-stop': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionSuspend
 */
export interface OsVolumesBootActionSuspend {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionSuspend
     */
    'suspend': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnlock21
 */
export interface OsVolumesBootActionUnlock21 {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionUnlock21
     */
    'unlock': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnpause
 */
export interface OsVolumesBootActionUnpause {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionUnpause
     */
    'unpause': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnrescue
 */
export interface OsVolumesBootActionUnrescue {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionUnrescue
     */
    'unrescue': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnshelve21
 */
export interface OsVolumesBootActionUnshelve21 {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionUnshelve21
     */
    'unshelve': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnshelve277
 */
export interface OsVolumesBootActionUnshelve277 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionUnshelve277Unshelve}
     * @memberof OsVolumesBootActionUnshelve277
     */
    'unshelve': OsVolumesBootActionUnshelve277Unshelve;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnshelve277Unshelve
 */
export interface OsVolumesBootActionUnshelve277Unshelve {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootActionUnshelve277Unshelve
     */
    'availability_zone': any;
}
/**
 * 
 * @export
 * @interface OsVolumesBootActionUnshelve291
 */
export interface OsVolumesBootActionUnshelve291 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootActionUnshelve291Unshelve}
     * @memberof OsVolumesBootActionUnshelve291
     */
    'unshelve': OsVolumesBootActionUnshelve291Unshelve;
}
/**
 * @type OsVolumesBootActionUnshelve291Unshelve
 * @export
 */
export type OsVolumesBootActionUnshelve291Unshelve = OsVolumesBootActionUnshelve291UnshelveOneOf | any;

/**
 * 
 * @export
 * @interface OsVolumesBootActionUnshelve291UnshelveOneOf
 */
export interface OsVolumesBootActionUnshelve291UnshelveOneOf {
    /**
     * 
     * @type {OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone}
     * @memberof OsVolumesBootActionUnshelve291UnshelveOneOf
     */
    'availability_zone'?: OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootActionUnshelve291UnshelveOneOf
     */
    'host'?: string;
}
/**
 * @type OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone
 * @export
 */
export type OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone = any;

/**
 * @type OsVolumesBootActionUnshelveRequest
 * @export
 */
export type OsVolumesBootActionUnshelveRequest = OsVolumesBootActionUnshelve21 | OsVolumesBootActionUnshelve277 | OsVolumesBootActionUnshelve291;

/**
 * 
 * @export
 * @interface OsVolumesBootCreate20
 */
export interface OsVolumesBootCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate20Server}
     * @memberof OsVolumesBootCreate20
     */
    'server': OsVolumesBootCreate20Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate20
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate20
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate20OsSchedulerHints
 */
export interface OsVolumesBootCreate20OsSchedulerHints {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'group'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHintsDifferentHost}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'different_host'?: OsVolumesBootCreate20OsSchedulerHintsDifferentHost;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'same_host'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'query'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'target_cell'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'different_cell'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'build_near_host_ip'?: OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20OsSchedulerHints
     */
    'cidr'?: any;
}
/**
 * @type OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp
 * @export
 */
export type OsVolumesBootCreate20OsSchedulerHintsBuildNearHostIp = any;

/**
 * @type OsVolumesBootCreate20OsSchedulerHintsDifferentHost
 * @export
 */
export type OsVolumesBootCreate20OsSchedulerHintsDifferentHost = any;

/**
 * 
 * @export
 * @interface OsVolumesBootCreate20Server
 */
export interface OsVolumesBootCreate20Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate20Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate20Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate20ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate20Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate20Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate20Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate20Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate20Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof OsVolumesBootCreate20Server
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
}

export const OsVolumesBootCreate20ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate20ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate20ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate20ServerOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootCreate20ServerImageRef
 * @export
 */
export type OsVolumesBootCreate20ServerImageRef = any;

/**
 * @type OsVolumesBootCreate20ServerUserData
 * @export
 */
export type OsVolumesBootCreate20ServerUserData = any;

/**
 * 
 * @export
 * @interface OsVolumesBootCreate21
 */
export interface OsVolumesBootCreate21 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate21Server}
     * @memberof OsVolumesBootCreate21
     */
    'server': OsVolumesBootCreate21Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate21
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate21
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate219
 */
export interface OsVolumesBootCreate219 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate219Server}
     * @memberof OsVolumesBootCreate219
     */
    'server': OsVolumesBootCreate219Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate219
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate219
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate219Server
 */
export interface OsVolumesBootCreate219Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate219Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate219Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate219ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate219Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate219Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate219Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate219Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate219Server
     */
    'description'?: any;
}

export const OsVolumesBootCreate219ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate219ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate219ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate219ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate21Server
 */
export interface OsVolumesBootCreate21Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate21Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate21Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate21ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate21Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate21Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate21Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate21Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate21Server
     */
    'user_data'?: any;
}

export const OsVolumesBootCreate21ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate21ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate21ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate21ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate232
 */
export interface OsVolumesBootCreate232 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate232Server}
     * @memberof OsVolumesBootCreate232
     */
    'server': OsVolumesBootCreate232Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate232
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate232
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate232Server
 */
export interface OsVolumesBootCreate232Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate232Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate232Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate232ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate232Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate232Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate232Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate232Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate232Server
     */
    'description'?: any;
}

export const OsVolumesBootCreate232ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate232ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate232ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate232ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate233
 */
export interface OsVolumesBootCreate233 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate233Server}
     * @memberof OsVolumesBootCreate233
     */
    'server': OsVolumesBootCreate233Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate233
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate233
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate233Server
 */
export interface OsVolumesBootCreate233Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate233Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate233Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate233ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate233Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate233Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate233Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate233Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate233Server
     */
    'description'?: any;
}

export const OsVolumesBootCreate233ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate233ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate233ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate233ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate237
 */
export interface OsVolumesBootCreate237 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate237Server}
     * @memberof OsVolumesBootCreate237
     */
    'server': OsVolumesBootCreate237Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate237
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate237
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate237Server
 */
export interface OsVolumesBootCreate237Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate237Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate237Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate237ServerNetworks}
     * @memberof OsVolumesBootCreate237Server
     */
    'networks': OsVolumesBootCreate237ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate237ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate237Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate237Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate237Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate237Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate237Server
     */
    'description'?: any;
}

export const OsVolumesBootCreate237ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate237ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate237ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate237ServerOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootCreate237ServerNetworks
 * @export
 */
export type OsVolumesBootCreate237ServerNetworks = any;

/**
 * 
 * @export
 * @interface OsVolumesBootCreate242
 */
export interface OsVolumesBootCreate242 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate242Server}
     * @memberof OsVolumesBootCreate242
     */
    'server': OsVolumesBootCreate242Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate242
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate242
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate242Server
 */
export interface OsVolumesBootCreate242Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate242Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate242Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate242Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate242ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate242Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate242Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate242Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate242Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate242Server
     */
    'description'?: any;
}

export const OsVolumesBootCreate242ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate242ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate242ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate242ServerOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootCreate242ServerNetworks
 * @export
 */
export type OsVolumesBootCreate242ServerNetworks = any;

/**
 * 
 * @export
 * @interface OsVolumesBootCreate252
 */
export interface OsVolumesBootCreate252 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate252Server}
     * @memberof OsVolumesBootCreate252
     */
    'server': OsVolumesBootCreate252Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate252
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate252
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate252Server
 */
export interface OsVolumesBootCreate252Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate252Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate252Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate252Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate252ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate252Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate252Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate252Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate252Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate252Server
     */
    'tags'?: any;
}

export const OsVolumesBootCreate252ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate252ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate252ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate252ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate257
 */
export interface OsVolumesBootCreate257 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate257Server}
     * @memberof OsVolumesBootCreate257
     */
    'server': OsVolumesBootCreate257Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate257
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate257
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate257Server
 */
export interface OsVolumesBootCreate257Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate257Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate257Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate257Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate257ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate257Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate257Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate257Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate257Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate257Server
     */
    'tags'?: any;
}

export const OsVolumesBootCreate257ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate257ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate257ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate257ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate263
 */
export interface OsVolumesBootCreate263 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate263Server}
     * @memberof OsVolumesBootCreate263
     */
    'server': OsVolumesBootCreate263Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate263
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate263
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate263Server
 */
export interface OsVolumesBootCreate263Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate263Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate263Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate263Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate263ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate263Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate263Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate263Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate263Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate263Server
     */
    'trusted_image_certificates'?: any;
}

export const OsVolumesBootCreate263ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate263ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate263ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate263ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate267
 */
export interface OsVolumesBootCreate267 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate267Server}
     * @memberof OsVolumesBootCreate267
     */
    'server': OsVolumesBootCreate267Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate267
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate267
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate267Server
 */
export interface OsVolumesBootCreate267Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate267Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate267Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate267Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate267ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate267Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate267Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate267Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate267Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate267Server
     */
    'trusted_image_certificates'?: any;
}

export const OsVolumesBootCreate267ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate267ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate267ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate267ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate274
 */
export interface OsVolumesBootCreate274 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate274Server}
     * @memberof OsVolumesBootCreate274
     */
    'server': OsVolumesBootCreate274Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate274
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate274
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate274Server
 */
export interface OsVolumesBootCreate274Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate274Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate274Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate274Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate274ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate274Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate274Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate274Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate274Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate274Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate274Server
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate274Server
     */
    'hypervisor_hostname'?: string;
}

export const OsVolumesBootCreate274ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate274ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate274ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate274ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate290
 */
export interface OsVolumesBootCreate290 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate290Server}
     * @memberof OsVolumesBootCreate290
     */
    'server': OsVolumesBootCreate290Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate290
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate290
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate290Server
 */
export interface OsVolumesBootCreate290Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate290Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate290Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate290Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate290ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate290Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate290Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate290Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate290Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate290Server
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate290Server
     */
    'hypervisor_hostname'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate290Server
     */
    'hostname'?: any;
}

export const OsVolumesBootCreate290ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate290ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate290ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate290ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootCreate294
 */
export interface OsVolumesBootCreate294 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootCreate294Server}
     * @memberof OsVolumesBootCreate294
     */
    'server': OsVolumesBootCreate294Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate294
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof OsVolumesBootCreate294
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface OsVolumesBootCreate294Server
 */
export interface OsVolumesBootCreate294Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof OsVolumesBootCreate294Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate294Server
     */
    'adminPass'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof OsVolumesBootCreate294Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootCreate294ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate294Server
     */
    'config_drive'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate294Server
     */
    'min_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost}
     * @memberof OsVolumesBootCreate294Server
     */
    'max_count'?: OsServerGroupsCreate264ServerGroupRulesMaxServerPerHost;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof OsVolumesBootCreate294Server
     */
    'return_reservation_id'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootCreate294Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate294Server
     */
    'host'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate294Server
     */
    'hypervisor_hostname'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootCreate294Server
     */
    'hostname'?: string;
}

export const OsVolumesBootCreate294ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootCreate294ServerOSDCFdiskConfigEnum = typeof OsVolumesBootCreate294ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootCreate294ServerOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootCreateRequest
 * @export
 */
export type OsVolumesBootCreateRequest = OsVolumesBootCreate20 | OsVolumesBootCreate21 | OsVolumesBootCreate219 | OsVolumesBootCreate232 | OsVolumesBootCreate233 | OsVolumesBootCreate237 | OsVolumesBootCreate242 | OsVolumesBootCreate252 | OsVolumesBootCreate257 | OsVolumesBootCreate263 | OsVolumesBootCreate267 | OsVolumesBootCreate274 | OsVolumesBootCreate290 | OsVolumesBootCreate294;

/**
 * @type OsVolumesBootIdActionPost201Response
 * @export
 */
export type OsVolumesBootIdActionPost201Response = any;

/**
 * @type OsVolumesBootIdActionPost202Response
 * @export
 */
export type OsVolumesBootIdActionPost202Response = any;

/**
 * @type OsVolumesBootIdActionPostRequest
 * @export
 */
export type OsVolumesBootIdActionPostRequest = OsVolumesBootActionActionConfirmResize | OsVolumesBootActionActionReboot | OsVolumesBootActionActionResize | OsVolumesBootActionActionRevertResize | OsVolumesBootActionActionTriggerCrashDump | OsVolumesBootActionAddFixedIp | OsVolumesBootActionAddFloatingIp | OsVolumesBootActionAddsecuritygroup | OsVolumesBootActionChangePassword | OsVolumesBootActionCreatebackupRequest | OsVolumesBootActionCreateimageRequest | OsVolumesBootActionEvacuateRequest | OsVolumesBootActionForceDelete | OsVolumesBootActionGetConsoleOutput | OsVolumesBootActionGetSerialConsole | OsVolumesBootActionGetSpiceConsole | OsVolumesBootActionGetVncConsole | OsVolumesBootActionInjectNetworkInfo | OsVolumesBootActionLockRequest | OsVolumesBootActionMigrate256 | OsVolumesBootActionOsGetrdpconsoleRequest | OsVolumesBootActionOsMigrateliveRequest | OsVolumesBootActionPause | OsVolumesBootActionRebuildRequest | OsVolumesBootActionRemoveFixedIp | OsVolumesBootActionRemoveFloatingIp | OsVolumesBootActionRemovesecuritygroup | OsVolumesBootActionRescue | OsVolumesBootActionResetState | OsVolumesBootActionResetnetworkRequest | OsVolumesBootActionRestore | OsVolumesBootActionResume | OsVolumesBootActionShelve | OsVolumesBootActionShelveOffload | OsVolumesBootActionStartServer | OsVolumesBootActionStopServer | OsVolumesBootActionSuspend | OsVolumesBootActionUnlock21 | OsVolumesBootActionUnpause | OsVolumesBootActionUnrescue | OsVolumesBootActionUnshelveRequest;

/**
 * 
 * @export
 * @interface OsVolumesBootUpdate20
 */
export interface OsVolumesBootUpdate20 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootUpdate20Server}
     * @memberof OsVolumesBootUpdate20
     */
    'server': OsVolumesBootUpdate20Server;
}
/**
 * 
 * @export
 * @interface OsVolumesBootUpdate20Server
 */
export interface OsVolumesBootUpdate20Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate20Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate20Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootUpdate20ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate20Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate20Server
     */
    'accessIPv6'?: any;
}

export const OsVolumesBootUpdate20ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootUpdate20ServerOSDCFdiskConfigEnum = typeof OsVolumesBootUpdate20ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootUpdate20ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootUpdate21
 */
export interface OsVolumesBootUpdate21 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootUpdate21Server}
     * @memberof OsVolumesBootUpdate21
     */
    'server': OsVolumesBootUpdate21Server;
}
/**
 * 
 * @export
 * @interface OsVolumesBootUpdate219
 */
export interface OsVolumesBootUpdate219 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootUpdate219Server}
     * @memberof OsVolumesBootUpdate219
     */
    'server': OsVolumesBootUpdate219Server;
}
/**
 * 
 * @export
 * @interface OsVolumesBootUpdate219Server
 */
export interface OsVolumesBootUpdate219Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate219Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate219Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootUpdate219ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate219Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate219Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate219Server
     */
    'description'?: any;
}

export const OsVolumesBootUpdate219ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootUpdate219ServerOSDCFdiskConfigEnum = typeof OsVolumesBootUpdate219ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootUpdate219ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootUpdate21Server
 */
export interface OsVolumesBootUpdate21Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate21Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate21Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootUpdate21ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate21Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate21Server
     */
    'accessIPv6'?: any;
}

export const OsVolumesBootUpdate21ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootUpdate21ServerOSDCFdiskConfigEnum = typeof OsVolumesBootUpdate21ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootUpdate21ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootUpdate290
 */
export interface OsVolumesBootUpdate290 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootUpdate290Server}
     * @memberof OsVolumesBootUpdate290
     */
    'server': OsVolumesBootUpdate290Server;
}
/**
 * 
 * @export
 * @interface OsVolumesBootUpdate290Server
 */
export interface OsVolumesBootUpdate290Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootUpdate290ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate290Server
     */
    'hostname'?: any;
}

export const OsVolumesBootUpdate290ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootUpdate290ServerOSDCFdiskConfigEnum = typeof OsVolumesBootUpdate290ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootUpdate290ServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface OsVolumesBootUpdate294
 */
export interface OsVolumesBootUpdate294 {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesBootUpdate294Server}
     * @memberof OsVolumesBootUpdate294
     */
    'server': OsVolumesBootUpdate294Server;
}
/**
 * 
 * @export
 * @interface OsVolumesBootUpdate294Server
 */
export interface OsVolumesBootUpdate294Server {
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate294Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate294Server
     */
    'OS-DCF:diskConfig'?: OsVolumesBootUpdate294ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate294Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate294Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesBootUpdate294Server
     */
    'description'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesBootUpdate294Server
     */
    'hostname'?: string;
}

export const OsVolumesBootUpdate294ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type OsVolumesBootUpdate294ServerOSDCFdiskConfigEnum = typeof OsVolumesBootUpdate294ServerOSDCFdiskConfigEnum[keyof typeof OsVolumesBootUpdate294ServerOSDCFdiskConfigEnum];

/**
 * @type OsVolumesBootUpdateRequest
 * @export
 */
export type OsVolumesBootUpdateRequest = OsVolumesBootUpdate20 | OsVolumesBootUpdate21 | OsVolumesBootUpdate219 | OsVolumesBootUpdate290 | OsVolumesBootUpdate294;

/**
 * 
 * @export
 * @interface OsVolumesCreate
 */
export interface OsVolumesCreate {
    [key: string]: any;

    /**
     * 
     * @type {OsVolumesCreateVolume}
     * @memberof OsVolumesCreate
     */
    'volume': OsVolumesCreateVolume;
}
/**
 * 
 * @export
 * @interface OsVolumesCreateVolume
 */
export interface OsVolumesCreateVolume {
    /**
     * 
     * @type {string}
     * @memberof OsVolumesCreateVolume
     */
    'volume_type'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesCreateVolume
     */
    'metadata'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesCreateVolume
     */
    'snapshot_id'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsVolumesCreateVolume
     */
    'size': any;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesCreateVolume
     */
    'availability_zone'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesCreateVolume
     */
    'display_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsVolumesCreateVolume
     */
    'display_description'?: string;
}
/**
 * 
 * @export
 * @interface ServerShowResponse
 */
export interface ServerShowResponse {
    /**
     * 
     * @type {ServerShowResponseServer}
     * @memberof ServerShowResponse
     */
    'server'?: ServerShowResponseServer;
}
/**
 * Server object
 * @export
 * @interface ServerShowResponseServer
 */
export interface ServerShowResponseServer {
    /**
     * IPv4 address that should be used to access this server. May be automatically set by the provider.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'accessIPv4'?: any;
    /**
     * IPv6 address that should be used to access this server. May be automatically set by the provider.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'accessIPv6'?: any;
    /**
     * A dictionary of addresses this server can be accessed through. The dictionary contains keys such as ``private`` and ``public``, each containing a list of dictionaries for addresses of that type. The addresses are contained in a dictionary with keys ``addr`` and ``version``, which is either 4 or 6 depending on the protocol of the IP address.
     * @type {{ [key: string]: any; }}
     * @memberof ServerShowResponseServer
     */
    'addresses'?: { [key: string]: any; };
    /**
     * A list of an attached volumes. Each item in the list contains at least an \'id\' key to identify the specific volumes.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'os-extended-volumes:volumes_attached'?: any;
    /**
     * The name of the availability zone this server is a part of.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-AZ:availability_zone'?: any;
    /**
     * The name of the compute host on which this instance is running. Appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:host'?: any;
    /**
     * Indicates whether a configuration drive enables metadata injection. Not all cloud providers enable this feature.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'config_drive'?: any;
    /**
     * Timestamp of when the server was created.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'created'?: any;
    /**
     * The description of the server. Before microversion 2.19 this was set to the server name.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'description'?: any;
    /**
     * The disk configuration. Either AUTO or MANUAL.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-DCF:diskConfig'?: ServerShowResponseServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {ServerShowResponseServerFault}
     * @memberof ServerShowResponseServer
     */
    'fault'?: ServerShowResponseServerFault;
    /**
     * 
     * @type {ServerShowResponseServerFlavor}
     * @memberof ServerShowResponseServer
     */
    'flavor'?: ServerShowResponseServerFlavor;
    /**
     * An ID representing the host of this server.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'hostId'?: any;
    /**
     * The host status.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'host_status'?: ServerShowResponseServerHostStatusEnum;
    /**
     * The hostname set on the instance when it is booted. By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:hostname'?: any;
    /**
     * The hypervisor host name. Appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:hypervisor_hostname'?: any;
    /**
     * Id of the server
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'id'?: any;
    /**
     * 
     * @type {ServerShowResponseServerImage}
     * @memberof ServerShowResponseServer
     */
    'image'?: ServerShowResponseServerImage;
    /**
     * The instance name. The Compute API generates the instance name from the instance name template. Appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:instance_name'?: any;
    /**
     * True if the instance is locked otherwise False.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'locked'?: any;
    /**
     * The UUID of the kernel image when using an AMI. Will be null if not. By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:kernel_id'?: any;
    /**
     * The name of an associated keypair
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'key_name'?: any;
    /**
     * When servers are launched via multiple create, this is the sequence in which the servers were launched. By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:launch_index'?: any;
    /**
     * The timestamp when the server was launched.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-SRV-USG:launched_at'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'links'?: any;
    /**
     * A dictionary of metadata key-and-value pairs, which is maintained for backward compatibility.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'metadata'?: any;
    /**
     * Name
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'name'?: any;
    /**
     * The power state of this server. This is an enum value that is mapped as:  - 0: NOSTATE  - 1: RUNNING  - 3: PAUSED  - 4: SHUTDOWN  - 6: CRASHED  - 7: SUSPENDED 
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-STS:power_state'?: any;
    /**
     * While the server is building, this value represents the percentage of completion. Once it is completed, it will be 100.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'progress'?: any;
    /**
     * The ID of the project this server is associated with.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'tenant_id'?: any;
    /**
     * The UUID of the ramdisk image when using an AMI. Will be null if not. By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:ramdisk_id'?: any;
    /**
     * The reservation id for the server. This is an id that can be useful in tracking groups of servers created with multiple create, that will all have the same reservation_id. By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:reservation_id'?: any;
    /**
     * The root device name for the instance By default, it appears in the response for administrative users only.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:root_device_name'?: any;
    /**
     * One or more security groups objects.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'security_groups'?: any;
    /**
     * The UUIDs of the server groups to which the server belongs. Currently this can contain at most one entry.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'server_groups'?: any;
    /**
     * The state this server is in. Valid values include ``ACTIVE``, ``BUILDING``, ``DELETED``, ``ERROR``, ``HARD_REBOOT``, ``PASSWORD``, ``PAUSED``, ``REBOOT``, ``REBUILD``, ``RESCUED``, ``RESIZED``, ``REVERT_RESIZE``, ``SHUTOFF``, ``SOFT_DELETED``, ``STOPPED``, ``SUSPENDED``, ``UNKNOWN``, or ``VERIFY_RESIZE``.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'status'?: any;
    /**
     * A list of tags. The maximum count of tags in this list is 50.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'tags'?: any;
    /**
     * The task state of this server.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-STS:task_state'?: any;
    /**
     * The timestamp when the server was terminated (if it has been).
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-SRV-USG:terminated_at'?: any;
    /**
     * A list of trusted certificate IDs, that were used during image signature verification to verify the signing certificate. The list is restricted to a maximum of 50 IDs. The value is null if trusted certificate IDs are not set.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'trusted_image_certificates'?: any;
    /**
     * Timestamp of when this server was last updated.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'updated'?: any;
    /**
     * Configuration information or scripts to use upon launch. Must be Base64 encoded.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-SRV-ATTR:user_data'?: any;
    /**
     * The ID of the owners of this server.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'user_id'?: any;
    /**
     * The VM state of this server.
     * @type {any}
     * @memberof ServerShowResponseServer
     */
    'OS-EXT-STS:vm_state'?: any;
}

export const ServerShowResponseServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServerShowResponseServerOSDCFdiskConfigEnum = typeof ServerShowResponseServerOSDCFdiskConfigEnum[keyof typeof ServerShowResponseServerOSDCFdiskConfigEnum];
export const ServerShowResponseServerHostStatusEnum = {
    Up: 'UP',
    Down: 'DOWN',
    Maintenance: 'MAINTENANCE',
    Unknown: 'UNKNOWN',
    Empty: '',
    Null: 'null'
} as const;

export type ServerShowResponseServerHostStatusEnum = typeof ServerShowResponseServerHostStatusEnum[keyof typeof ServerShowResponseServerHostStatusEnum];

/**
 * A fault object. Only available when the server status is ERROR or DELETED and a fault occurred.
 * @export
 * @interface ServerShowResponseServerFault
 */
export interface ServerShowResponseServerFault {
    /**
     * The error response code.
     * @type {any}
     * @memberof ServerShowResponseServerFault
     */
    'code'?: any;
    /**
     * The date and time when the exception was raised.
     * @type {any}
     * @memberof ServerShowResponseServerFault
     */
    'created'?: any;
    /**
     * The error message.
     * @type {any}
     * @memberof ServerShowResponseServerFault
     */
    'message'?: any;
    /**
     * The stack trace. It is available if the response code is not 500 or you have the administrator privilege
     * @type {any}
     * @memberof ServerShowResponseServerFault
     */
    'details'?: any;
}
/**
 * The flavor property as returned from server.
 * @export
 * @interface ServerShowResponseServerFlavor
 */
export interface ServerShowResponseServerFlavor {
    /**
     * The ID of the flavor. While people often make this look like an int, this is really a string.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'id'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'links'?: any;
    /**
     * The number of virtual CPUs that were allocated to the server.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'vcpus'?: any;
    /**
     * The amount of RAM a flavor has, in MiB.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'ram'?: any;
    /**
     * The size of the root disk that was created in GiB.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'disk'?: any;
    /**
     * The size of the ephemeral disk that was created, in GiB.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'ephemeral'?: any;
    /**
     * The size of a dedicated swap disk that was allocated, in MiB.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'swap'?: any;
    /**
     * The display name of a flavor.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'original_name'?: any;
    /**
     * A dictionary of the flavor’s extra-specs key-and-value pairs. This will only be included if the user is allowed by policy to index flavor extra_specs.
     * @type {any}
     * @memberof ServerShowResponseServerFlavor
     */
    'extra_specs'?: any;
}
/**
 * The image property as returned from server.
 * @export
 * @interface ServerShowResponseServerImage
 */
export interface ServerShowResponseServerImage {
    /**
     * The image ID
     * @type {any}
     * @memberof ServerShowResponseServerImage
     */
    'id'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServerShowResponseServerImage
     */
    'links'?: any;
}
/**
 * 
 * @export
 * @interface ServerUpdate20
 */
export interface ServerUpdate20 {
    /**
     * 
     * @type {OsVolumesBootUpdate20Server}
     * @memberof ServerUpdate20
     */
    'server': OsVolumesBootUpdate20Server;
}
/**
 * 
 * @export
 * @interface ServerUpdate21
 */
export interface ServerUpdate21 {
    /**
     * 
     * @type {OsVolumesBootUpdate21Server}
     * @memberof ServerUpdate21
     */
    'server': OsVolumesBootUpdate21Server;
}
/**
 * 
 * @export
 * @interface ServerUpdate219
 */
export interface ServerUpdate219 {
    /**
     * 
     * @type {OsVolumesBootUpdate219Server}
     * @memberof ServerUpdate219
     */
    'server': OsVolumesBootUpdate219Server;
}
/**
 * 
 * @export
 * @interface ServerUpdate290
 */
export interface ServerUpdate290 {
    /**
     * 
     * @type {OsVolumesBootUpdate290Server}
     * @memberof ServerUpdate290
     */
    'server': OsVolumesBootUpdate290Server;
}
/**
 * 
 * @export
 * @interface ServerUpdate294
 */
export interface ServerUpdate294 {
    /**
     * 
     * @type {ServerUpdate294Server}
     * @memberof ServerUpdate294
     */
    'server': ServerUpdate294Server;
}
/**
 * 
 * @export
 * @interface ServerUpdate294Server
 */
export interface ServerUpdate294Server {
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'OS-DCF:diskConfig'?: ServerUpdate294ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServerUpdate294Server
     */
    'hostname'?: any;
}

export const ServerUpdate294ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServerUpdate294ServerOSDCFdiskConfigEnum = typeof ServerUpdate294ServerOSDCFdiskConfigEnum[keyof typeof ServerUpdate294ServerOSDCFdiskConfigEnum];

/**
 * @type ServerUpdateRequest
 * @export
 */
export type ServerUpdateRequest = ServerUpdate20 | ServerUpdate21 | ServerUpdate219 | ServerUpdate290 | ServerUpdate294;

/**
 * 
 * @export
 * @interface ServerUpdateResponse
 */
export interface ServerUpdateResponse {
    /**
     * 
     * @type {ServerShowResponseServer}
     * @memberof ServerUpdateResponse
     */
    'server'?: ServerShowResponseServer;
}
/**
 * 
 * @export
 * @interface ServersActionActionConfirmResize
 */
export interface ServersActionActionConfirmResize {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionConfirmResize
     */
    'confirmResize': any;
}
/**
 * 
 * @export
 * @interface ServersActionActionCreateImage20
 */
export interface ServersActionActionCreateImage20 {
    /**
     * 
     * @type {OsVolumesBootActionActionCreateImage20CreateImage}
     * @memberof ServersActionActionCreateImage20
     */
    'createImage': OsVolumesBootActionActionCreateImage20CreateImage;
}
/**
 * 
 * @export
 * @interface ServersActionActionCreateImage21
 */
export interface ServersActionActionCreateImage21 {
    /**
     * 
     * @type {OsVolumesBootActionActionCreateImage20CreateImage}
     * @memberof ServersActionActionCreateImage21
     */
    'createImage': OsVolumesBootActionActionCreateImage20CreateImage;
}
/**
 * 
 * @export
 * @interface ServersActionActionReboot
 */
export interface ServersActionActionReboot {
    /**
     * 
     * @type {OsVolumesBootActionActionRebootReboot}
     * @memberof ServersActionActionReboot
     */
    'reboot': OsVolumesBootActionActionRebootReboot;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild20
 */
export interface ServersActionActionRebuild20 {
    /**
     * 
     * @type {ServersActionActionRebuild20Rebuild}
     * @memberof ServersActionActionRebuild20
     */
    'rebuild': ServersActionActionRebuild20Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild20Rebuild
 */
export interface ServersActionActionRebuild20Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild20RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild20RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild20Rebuild
     */
    'personality'?: any;
}

export const ServersActionActionRebuild20RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild20RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild20RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild20RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild20RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild20RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild20RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild20RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild21
 */
export interface ServersActionActionRebuild21 {
    /**
     * 
     * @type {ServersActionActionRebuild21Rebuild}
     * @memberof ServersActionActionRebuild21
     */
    'rebuild': ServersActionActionRebuild21Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild219
 */
export interface ServersActionActionRebuild219 {
    /**
     * 
     * @type {ServersActionActionRebuild219Rebuild}
     * @memberof ServersActionActionRebuild219
     */
    'rebuild': ServersActionActionRebuild219Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild219Rebuild
 */
export interface ServersActionActionRebuild219Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild219RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild219RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild219Rebuild
     */
    'description'?: any;
}

export const ServersActionActionRebuild219RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild219RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild219RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild219RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild219RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild219RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild219RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild219RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild21Rebuild
 */
export interface ServersActionActionRebuild21Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild21RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild21RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild21Rebuild
     */
    'personality'?: any;
}

export const ServersActionActionRebuild21RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild21RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild21RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild21RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild21RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild21RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild21RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild21RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild254
 */
export interface ServersActionActionRebuild254 {
    /**
     * 
     * @type {ServersActionActionRebuild254Rebuild}
     * @memberof ServersActionActionRebuild254
     */
    'rebuild': ServersActionActionRebuild254Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild254Rebuild
 */
export interface ServersActionActionRebuild254Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild254RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild254RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof ServersActionActionRebuild254Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
}

export const ServersActionActionRebuild254RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild254RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild254RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild254RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild254RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild254RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild254RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild254RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild257
 */
export interface ServersActionActionRebuild257 {
    /**
     * 
     * @type {ServersActionActionRebuild257Rebuild}
     * @memberof ServersActionActionRebuild257
     */
    'rebuild': ServersActionActionRebuild257Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild257Rebuild
 */
export interface ServersActionActionRebuild257Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild257RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild257RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof ServersActionActionRebuild257Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
}

export const ServersActionActionRebuild257RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild257RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild257RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild257RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild257RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild257RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild257RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild257RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild263
 */
export interface ServersActionActionRebuild263 {
    /**
     * 
     * @type {ServersActionActionRebuild263Rebuild}
     * @memberof ServersActionActionRebuild263
     */
    'rebuild': ServersActionActionRebuild263Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild263Rebuild
 */
export interface ServersActionActionRebuild263Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild263RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild263RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild263Rebuild
     */
    'trusted_image_certificates'?: any;
}

export const ServersActionActionRebuild263RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild263RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild263RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild263RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild263RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild263RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild263RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild263RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild290
 */
export interface ServersActionActionRebuild290 {
    /**
     * 
     * @type {ServersActionActionRebuild290Rebuild}
     * @memberof ServersActionActionRebuild290
     */
    'rebuild': ServersActionActionRebuild290Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild290Rebuild
 */
export interface ServersActionActionRebuild290Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild290RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild290RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild290Rebuild
     */
    'hostname'?: any;
}

export const ServersActionActionRebuild290RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild290RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild290RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild290RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild290RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild290RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild290RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild290RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionRebuild294
 */
export interface ServersActionActionRebuild294 {
    /**
     * 
     * @type {ServersActionActionRebuild294Rebuild}
     * @memberof ServersActionActionRebuild294
     */
    'rebuild': ServersActionActionRebuild294Rebuild;
}
/**
 * 
 * @export
 * @interface ServersActionActionRebuild294Rebuild
 */
export interface ServersActionActionRebuild294Rebuild {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'imageRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'preserve_ephemeral'?: ServersActionActionRebuild294RebuildPreserveEphemeralEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'OS-DCF:diskConfig'?: ServersActionActionRebuild294RebuildOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'description'?: any;
    /**
     * 
     * @type {OsVolumesBootActionActionRebuild254RebuildKeyName}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'key_name'?: OsVolumesBootActionActionRebuild254RebuildKeyName;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRebuild294Rebuild
     */
    'hostname'?: any;
}

export const ServersActionActionRebuild294RebuildPreserveEphemeralEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionActionRebuild294RebuildPreserveEphemeralEnum = typeof ServersActionActionRebuild294RebuildPreserveEphemeralEnum[keyof typeof ServersActionActionRebuild294RebuildPreserveEphemeralEnum];
export const ServersActionActionRebuild294RebuildOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersActionActionRebuild294RebuildOSDCFdiskConfigEnum = typeof ServersActionActionRebuild294RebuildOSDCFdiskConfigEnum[keyof typeof ServersActionActionRebuild294RebuildOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersActionActionResize
 */
export interface ServersActionActionResize {
    /**
     * 
     * @type {OsVolumesBootActionActionResizeResize}
     * @memberof ServersActionActionResize
     */
    'resize': OsVolumesBootActionActionResizeResize;
}
/**
 * 
 * @export
 * @interface ServersActionActionRevertResize
 */
export interface ServersActionActionRevertResize {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionRevertResize
     */
    'revertResize': any;
}
/**
 * 
 * @export
 * @interface ServersActionActionTriggerCrashDump
 */
export interface ServersActionActionTriggerCrashDump {
    /**
     * 
     * @type {any}
     * @memberof ServersActionActionTriggerCrashDump
     */
    'trigger_crash_dump': any;
}
/**
 * 
 * @export
 * @interface ServersActionAddFixedIp
 */
export interface ServersActionAddFixedIp {
    /**
     * 
     * @type {OsVolumesBootActionAddFixedIpAddFixedIp}
     * @memberof ServersActionAddFixedIp
     */
    'addFixedIp': OsVolumesBootActionAddFixedIpAddFixedIp;
}
/**
 * 
 * @export
 * @interface ServersActionAddFloatingIp
 */
export interface ServersActionAddFloatingIp {
    /**
     * 
     * @type {OsVolumesBootActionAddFloatingIpAddFloatingIp}
     * @memberof ServersActionAddFloatingIp
     */
    'addFloatingIp': OsVolumesBootActionAddFloatingIpAddFloatingIp;
}
/**
 * 
 * @export
 * @interface ServersActionAddsecuritygroup
 */
export interface ServersActionAddsecuritygroup {
    /**
     * 
     * @type {any}
     * @memberof ServersActionAddsecuritygroup
     */
    'name'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionChangePassword
 */
export interface ServersActionChangePassword {
    /**
     * 
     * @type {ServersActionChangePasswordChangePassword}
     * @memberof ServersActionChangePassword
     */
    'changePassword': ServersActionChangePasswordChangePassword;
}
/**
 * 
 * @export
 * @interface ServersActionChangePasswordChangePassword
 */
export interface ServersActionChangePasswordChangePassword {
    /**
     * 
     * @type {any}
     * @memberof ServersActionChangePasswordChangePassword
     */
    'adminPass': any;
}
/**
 * 
 * @export
 * @interface ServersActionCreateBackup20
 */
export interface ServersActionCreateBackup20 {
    /**
     * 
     * @type {ServersActionCreateBackup20CreateBackup}
     * @memberof ServersActionCreateBackup20
     */
    'createBackup': ServersActionCreateBackup20CreateBackup;
}
/**
 * 
 * @export
 * @interface ServersActionCreateBackup20CreateBackup
 */
export interface ServersActionCreateBackup20CreateBackup {
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup20CreateBackup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup20CreateBackup
     */
    'backup_type': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup20CreateBackup
     */
    'rotation': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup20CreateBackup
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionCreateBackup21
 */
export interface ServersActionCreateBackup21 {
    /**
     * 
     * @type {ServersActionCreateBackup21CreateBackup}
     * @memberof ServersActionCreateBackup21
     */
    'createBackup': ServersActionCreateBackup21CreateBackup;
}
/**
 * 
 * @export
 * @interface ServersActionCreateBackup21CreateBackup
 */
export interface ServersActionCreateBackup21CreateBackup {
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup21CreateBackup
     */
    'name': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup21CreateBackup
     */
    'backup_type': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup21CreateBackup
     */
    'rotation': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionCreateBackup21CreateBackup
     */
    'metadata'?: any;
}
/**
 * @type ServersActionCreatebackupRequest
 * @export
 */
export type ServersActionCreatebackupRequest = ServersActionCreateBackup20 | ServersActionCreateBackup21;

/**
 * 
 * @export
 * @interface ServersActionCreatebackupResponse
 */
export interface ServersActionCreatebackupResponse {
    /**
     * The UUID for the resulting image snapshot.
     * @type {any}
     * @memberof ServersActionCreatebackupResponse
     */
    'image_id'?: any;
}
/**
 * @type ServersActionCreateimageRequest
 * @export
 */
export type ServersActionCreateimageRequest = ServersActionActionCreateImage20 | ServersActionActionCreateImage21;

/**
 * 
 * @export
 * @interface ServersActionCreateimageResponse
 */
export interface ServersActionCreateimageResponse {
    /**
     * The UUID for the resulting image snapshot.
     * @type {any}
     * @memberof ServersActionCreateimageResponse
     */
    'image_id'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionEvacuate20
 */
export interface ServersActionEvacuate20 {
    /**
     * 
     * @type {ServersActionEvacuate20Evacuate}
     * @memberof ServersActionEvacuate20
     */
    'evacuate': ServersActionEvacuate20Evacuate;
}
/**
 * 
 * @export
 * @interface ServersActionEvacuate20Evacuate
 */
export interface ServersActionEvacuate20Evacuate {
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate20Evacuate
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate20Evacuate
     */
    'onSharedStorage': ServersActionEvacuate20EvacuateOnSharedStorageEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate20Evacuate
     */
    'adminPass'?: any;
}

export const ServersActionEvacuate20EvacuateOnSharedStorageEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionEvacuate20EvacuateOnSharedStorageEnum = typeof ServersActionEvacuate20EvacuateOnSharedStorageEnum[keyof typeof ServersActionEvacuate20EvacuateOnSharedStorageEnum];

/**
 * 
 * @export
 * @interface ServersActionEvacuate214
 */
export interface ServersActionEvacuate214 {
    /**
     * 
     * @type {OsVolumesBootActionEvacuate268Evacuate}
     * @memberof ServersActionEvacuate214
     */
    'evacuate': OsVolumesBootActionEvacuate268Evacuate;
}
/**
 * 
 * @export
 * @interface ServersActionEvacuate229
 */
export interface ServersActionEvacuate229 {
    /**
     * 
     * @type {ServersActionEvacuate229Evacuate}
     * @memberof ServersActionEvacuate229
     */
    'evacuate': ServersActionEvacuate229Evacuate;
}
/**
 * 
 * @export
 * @interface ServersActionEvacuate229Evacuate
 */
export interface ServersActionEvacuate229Evacuate {
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate229Evacuate
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate229Evacuate
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionEvacuate229Evacuate
     */
    'force'?: ServersActionEvacuate229EvacuateForceEnum;
}

export const ServersActionEvacuate229EvacuateForceEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionEvacuate229EvacuateForceEnum = typeof ServersActionEvacuate229EvacuateForceEnum[keyof typeof ServersActionEvacuate229EvacuateForceEnum];

/**
 * 
 * @export
 * @interface ServersActionEvacuate268
 */
export interface ServersActionEvacuate268 {
    /**
     * 
     * @type {OsVolumesBootActionEvacuate268Evacuate}
     * @memberof ServersActionEvacuate268
     */
    'evacuate': OsVolumesBootActionEvacuate268Evacuate;
}
/**
 * 
 * @export
 * @interface ServersActionEvacuate295
 */
export interface ServersActionEvacuate295 {
    /**
     * 
     * @type {OsVolumesBootActionEvacuate268Evacuate}
     * @memberof ServersActionEvacuate295
     */
    'evacuate': OsVolumesBootActionEvacuate268Evacuate;
}
/**
 * @type ServersActionEvacuateRequest
 * @export
 */
export type ServersActionEvacuateRequest = ServersActionEvacuate20 | ServersActionEvacuate214 | ServersActionEvacuate229 | ServersActionEvacuate268 | ServersActionEvacuate295;

/**
 * 
 * @export
 * @interface ServersActionEvacuateResponse
 */
export interface ServersActionEvacuateResponse {
    /**
     * An administrative password to access moved instance. If you set enable_instance_password configuration option to False, the API wouldn’t return the adminPass field in response.
     * @type {any}
     * @memberof ServersActionEvacuateResponse
     */
    'adminPass'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionForceDelete
 */
export interface ServersActionForceDelete {
    /**
     * 
     * @type {any}
     * @memberof ServersActionForceDelete
     */
    'forceDelete': any;
}
/**
 * 
 * @export
 * @interface ServersActionGetConsoleOutput
 */
export interface ServersActionGetConsoleOutput {
    /**
     * 
     * @type {OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput}
     * @memberof ServersActionGetConsoleOutput
     */
    'os-getConsoleOutput': OsVolumesBootActionGetConsoleOutputOsGetConsoleOutput;
}
/**
 * 
 * @export
 * @interface ServersActionGetSerialConsole
 */
export interface ServersActionGetSerialConsole {
    /**
     * 
     * @type {OsVolumesBootActionGetSerialConsoleOsGetSerialConsole}
     * @memberof ServersActionGetSerialConsole
     */
    'os-getSerialConsole': OsVolumesBootActionGetSerialConsoleOsGetSerialConsole;
}
/**
 * 
 * @export
 * @interface ServersActionGetSpiceConsole
 */
export interface ServersActionGetSpiceConsole {
    /**
     * 
     * @type {OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole}
     * @memberof ServersActionGetSpiceConsole
     */
    'os-getSPICEConsole': OsVolumesBootActionGetSpiceConsoleOsGetSPICEConsole;
}
/**
 * 
 * @export
 * @interface ServersActionGetVncConsole
 */
export interface ServersActionGetVncConsole {
    /**
     * 
     * @type {OsVolumesBootActionGetVncConsoleOsGetVNCConsole}
     * @memberof ServersActionGetVncConsole
     */
    'os-getVNCConsole': OsVolumesBootActionGetVncConsoleOsGetVNCConsole;
}
/**
 * 
 * @export
 * @interface ServersActionInjectNetworkInfo
 */
export interface ServersActionInjectNetworkInfo {
    /**
     * 
     * @type {any}
     * @memberof ServersActionInjectNetworkInfo
     */
    'injectNetworkInfo': any;
}
/**
 * 
 * @export
 * @interface ServersActionLock21
 */
export interface ServersActionLock21 {
    /**
     * 
     * @type {any}
     * @memberof ServersActionLock21
     */
    'lock': any;
}
/**
 * 
 * @export
 * @interface ServersActionLock273
 */
export interface ServersActionLock273 {
    /**
     * 
     * @type {OsVolumesBootActionLock273Lock}
     * @memberof ServersActionLock273
     */
    'lock': OsVolumesBootActionLock273Lock;
}
/**
 * @type ServersActionLockRequest
 * @export
 */
export type ServersActionLockRequest = ServersActionLock21 | ServersActionLock273;

/**
 * 
 * @export
 * @interface ServersActionMigrate256
 */
export interface ServersActionMigrate256 {
    /**
     * 
     * @type {OsVolumesBootActionMigrate256Migrate}
     * @memberof ServersActionMigrate256
     */
    'migrate': OsVolumesBootActionMigrate256Migrate;
}
/**
 * 
 * @export
 * @interface ServersActionMigrateLive20
 */
export interface ServersActionMigrateLive20 {
    /**
     * 
     * @type {ServersActionMigrateLive20OsMigrateLive}
     * @memberof ServersActionMigrateLive20
     */
    'os-migrateLive': ServersActionMigrateLive20OsMigrateLive;
}
/**
 * 
 * @export
 * @interface ServersActionMigrateLive20OsMigrateLive
 */
export interface ServersActionMigrateLive20OsMigrateLive {
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive20OsMigrateLive
     */
    'block_migration': ServersActionMigrateLive20OsMigrateLiveBlockMigrationEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive20OsMigrateLive
     */
    'disk_over_commit': ServersActionMigrateLive20OsMigrateLiveDiskOverCommitEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive20OsMigrateLive
     */
    'host': any;
}

export const ServersActionMigrateLive20OsMigrateLiveBlockMigrationEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionMigrateLive20OsMigrateLiveBlockMigrationEnum = typeof ServersActionMigrateLive20OsMigrateLiveBlockMigrationEnum[keyof typeof ServersActionMigrateLive20OsMigrateLiveBlockMigrationEnum];
export const ServersActionMigrateLive20OsMigrateLiveDiskOverCommitEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionMigrateLive20OsMigrateLiveDiskOverCommitEnum = typeof ServersActionMigrateLive20OsMigrateLiveDiskOverCommitEnum[keyof typeof ServersActionMigrateLive20OsMigrateLiveDiskOverCommitEnum];

/**
 * 
 * @export
 * @interface ServersActionMigrateLive225
 */
export interface ServersActionMigrateLive225 {
    /**
     * 
     * @type {OsVolumesBootActionMigrateLive225OsMigrateLive}
     * @memberof ServersActionMigrateLive225
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive225OsMigrateLive;
}
/**
 * 
 * @export
 * @interface ServersActionMigrateLive230
 */
export interface ServersActionMigrateLive230 {
    /**
     * 
     * @type {ServersActionMigrateLive230OsMigrateLive}
     * @memberof ServersActionMigrateLive230
     */
    'os-migrateLive': ServersActionMigrateLive230OsMigrateLive;
}
/**
 * 
 * @export
 * @interface ServersActionMigrateLive230OsMigrateLive
 */
export interface ServersActionMigrateLive230OsMigrateLive {
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive230OsMigrateLive
     */
    'block_migration': ServersActionMigrateLive230OsMigrateLiveBlockMigrationEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive230OsMigrateLive
     */
    'host': any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionMigrateLive230OsMigrateLive
     */
    'force'?: ServersActionMigrateLive230OsMigrateLiveForceEnum;
}

export const ServersActionMigrateLive230OsMigrateLiveBlockMigrationEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false',
    Auto: 'auto'
} as const;

export type ServersActionMigrateLive230OsMigrateLiveBlockMigrationEnum = typeof ServersActionMigrateLive230OsMigrateLiveBlockMigrationEnum[keyof typeof ServersActionMigrateLive230OsMigrateLiveBlockMigrationEnum];
export const ServersActionMigrateLive230OsMigrateLiveForceEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersActionMigrateLive230OsMigrateLiveForceEnum = typeof ServersActionMigrateLive230OsMigrateLiveForceEnum[keyof typeof ServersActionMigrateLive230OsMigrateLiveForceEnum];

/**
 * 
 * @export
 * @interface ServersActionMigrateLive268
 */
export interface ServersActionMigrateLive268 {
    /**
     * 
     * @type {OsVolumesBootActionMigrateLive225OsMigrateLive}
     * @memberof ServersActionMigrateLive268
     */
    'os-migrateLive': OsVolumesBootActionMigrateLive225OsMigrateLive;
}
/**
 * The console output as a string. Control characters will be escaped to create a valid JSON string.
 * @export
 * @interface ServersActionOsGetconsoleoutputResponse
 */
export interface ServersActionOsGetconsoleoutputResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersActionOsGetconsoleoutputResponse
     */
    'output'?: any;
}
/**
 * Empty body for os-getRDPConsole action
 * @export
 * @interface ServersActionOsGetrdpconsoleRequest
 */
export interface ServersActionOsGetrdpconsoleRequest {
    /**
     * 
     * @type {any}
     * @memberof ServersActionOsGetrdpconsoleRequest
     */
    'os-getRDPConsole'?: any;
}
/**
 * The remote console object.
 * @export
 * @interface ServersActionOsGetrdpconsoleResponse
 */
export interface ServersActionOsGetrdpconsoleResponse {
    /**
     * 
     * @type {ServersActionOsGetvncconsoleResponseConsole}
     * @memberof ServersActionOsGetrdpconsoleResponse
     */
    'console'?: ServersActionOsGetvncconsoleResponseConsole;
}
/**
 * The remote console object.
 * @export
 * @interface ServersActionOsGetserialconsoleResponse
 */
export interface ServersActionOsGetserialconsoleResponse {
    /**
     * 
     * @type {ServersActionOsGetvncconsoleResponseConsole}
     * @memberof ServersActionOsGetserialconsoleResponse
     */
    'console'?: ServersActionOsGetvncconsoleResponseConsole;
}
/**
 * The remote console object.
 * @export
 * @interface ServersActionOsGetspiceconsoleResponse
 */
export interface ServersActionOsGetspiceconsoleResponse {
    /**
     * 
     * @type {ServersActionOsGetvncconsoleResponseConsole}
     * @memberof ServersActionOsGetspiceconsoleResponse
     */
    'console'?: ServersActionOsGetvncconsoleResponseConsole;
}
/**
 * The remote console object.
 * @export
 * @interface ServersActionOsGetvncconsoleResponse
 */
export interface ServersActionOsGetvncconsoleResponse {
    /**
     * 
     * @type {ServersActionOsGetvncconsoleResponseConsole}
     * @memberof ServersActionOsGetvncconsoleResponse
     */
    'console'?: ServersActionOsGetvncconsoleResponseConsole;
}
/**
 * 
 * @export
 * @interface ServersActionOsGetvncconsoleResponseConsole
 */
export interface ServersActionOsGetvncconsoleResponseConsole {
    /**
     * The type of the remote console
     * @type {any}
     * @memberof ServersActionOsGetvncconsoleResponseConsole
     */
    'type'?: ServersActionOsGetvncconsoleResponseConsoleTypeEnum;
    /**
     * The URL used to connect to the console.
     * @type {any}
     * @memberof ServersActionOsGetvncconsoleResponseConsole
     */
    'url'?: any;
}

export const ServersActionOsGetvncconsoleResponseConsoleTypeEnum = {
    RdpHtml5: 'rdp-html5',
    Serial: 'serial',
    SpiceHtml5: 'spice-html5',
    Novnc: 'novnc'
} as const;

export type ServersActionOsGetvncconsoleResponseConsoleTypeEnum = typeof ServersActionOsGetvncconsoleResponseConsoleTypeEnum[keyof typeof ServersActionOsGetvncconsoleResponseConsoleTypeEnum];

/**
 * @type ServersActionOsMigrateliveRequest
 * @export
 */
export type ServersActionOsMigrateliveRequest = ServersActionMigrateLive20 | ServersActionMigrateLive225 | ServersActionMigrateLive230 | ServersActionMigrateLive268;

/**
 * 
 * @export
 * @interface ServersActionPause
 */
export interface ServersActionPause {
    /**
     * 
     * @type {any}
     * @memberof ServersActionPause
     */
    'pause': any;
}
/**
 * @type ServersActionRebuildRequest
 * @export
 */
export type ServersActionRebuildRequest = ServersActionActionRebuild20 | ServersActionActionRebuild21 | ServersActionActionRebuild219 | ServersActionActionRebuild254 | ServersActionActionRebuild257 | ServersActionActionRebuild263 | ServersActionActionRebuild290 | ServersActionActionRebuild294;

/**
 * 
 * @export
 * @interface ServersActionRemoveFixedIp
 */
export interface ServersActionRemoveFixedIp {
    /**
     * 
     * @type {OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp}
     * @memberof ServersActionRemoveFixedIp
     */
    'removeFixedIp': OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp;
}
/**
 * 
 * @export
 * @interface ServersActionRemoveFloatingIp
 */
export interface ServersActionRemoveFloatingIp {
    /**
     * 
     * @type {OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp}
     * @memberof ServersActionRemoveFloatingIp
     */
    'removeFloatingIp': OsVolumesBootActionRemoveFloatingIpRemoveFloatingIp;
}
/**
 * 
 * @export
 * @interface ServersActionRemovesecuritygroup
 */
export interface ServersActionRemovesecuritygroup {
    /**
     * 
     * @type {any}
     * @memberof ServersActionRemovesecuritygroup
     */
    'name'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionRescue
 */
export interface ServersActionRescue {
    /**
     * 
     * @type {ServersActionRescueRescue}
     * @memberof ServersActionRescue
     */
    'rescue': ServersActionRescueRescue;
}
/**
 * 
 * @export
 * @interface ServersActionRescueRescue
 */
export interface ServersActionRescueRescue {
    /**
     * 
     * @type {any}
     * @memberof ServersActionRescueRescue
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersActionRescueRescue
     */
    'rescue_image_ref'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionRescueResponse
 */
export interface ServersActionRescueResponse {
    /**
     * An administrative password to access moved instance. If you set enable_instance_password configuration option to False, the API wouldn’t return the adminPass field in response.
     * @type {any}
     * @memberof ServersActionRescueResponse
     */
    'adminPass'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionResetState
 */
export interface ServersActionResetState {
    /**
     * 
     * @type {OsVolumesBootActionResetStateOsResetState}
     * @memberof ServersActionResetState
     */
    'os-resetState': OsVolumesBootActionResetStateOsResetState;
}
/**
 * Empty body for resetNetwork action
 * @export
 * @interface ServersActionResetnetworkRequest
 */
export interface ServersActionResetnetworkRequest {
    /**
     * 
     * @type {any}
     * @memberof ServersActionResetnetworkRequest
     */
    'resetNetwork'?: any;
}
/**
 * 
 * @export
 * @interface ServersActionRestore
 */
export interface ServersActionRestore {
    /**
     * 
     * @type {any}
     * @memberof ServersActionRestore
     */
    'restore': any;
}
/**
 * 
 * @export
 * @interface ServersActionResume
 */
export interface ServersActionResume {
    /**
     * 
     * @type {any}
     * @memberof ServersActionResume
     */
    'resume': any;
}
/**
 * 
 * @export
 * @interface ServersActionShelve
 */
export interface ServersActionShelve {
    /**
     * 
     * @type {any}
     * @memberof ServersActionShelve
     */
    'shelve': any;
}
/**
 * 
 * @export
 * @interface ServersActionShelveOffload
 */
export interface ServersActionShelveOffload {
    /**
     * 
     * @type {any}
     * @memberof ServersActionShelveOffload
     */
    'shelveOffload': any;
}
/**
 * 
 * @export
 * @interface ServersActionStartServer
 */
export interface ServersActionStartServer {
    /**
     * 
     * @type {any}
     * @memberof ServersActionStartServer
     */
    'os-start': any;
}
/**
 * 
 * @export
 * @interface ServersActionStopServer
 */
export interface ServersActionStopServer {
    /**
     * 
     * @type {any}
     * @memberof ServersActionStopServer
     */
    'os-stop': any;
}
/**
 * 
 * @export
 * @interface ServersActionSuspend
 */
export interface ServersActionSuspend {
    /**
     * 
     * @type {any}
     * @memberof ServersActionSuspend
     */
    'suspend': any;
}
/**
 * 
 * @export
 * @interface ServersActionUnlock21
 */
export interface ServersActionUnlock21 {
    /**
     * 
     * @type {any}
     * @memberof ServersActionUnlock21
     */
    'unlock': any;
}
/**
 * 
 * @export
 * @interface ServersActionUnpause
 */
export interface ServersActionUnpause {
    /**
     * 
     * @type {any}
     * @memberof ServersActionUnpause
     */
    'unpause': any;
}
/**
 * 
 * @export
 * @interface ServersActionUnrescue
 */
export interface ServersActionUnrescue {
    /**
     * 
     * @type {any}
     * @memberof ServersActionUnrescue
     */
    'unrescue': any;
}
/**
 * 
 * @export
 * @interface ServersActionUnshelve21
 */
export interface ServersActionUnshelve21 {
    /**
     * 
     * @type {any}
     * @memberof ServersActionUnshelve21
     */
    'unshelve': any;
}
/**
 * 
 * @export
 * @interface ServersActionUnshelve277
 */
export interface ServersActionUnshelve277 {
    /**
     * 
     * @type {OsVolumesBootActionUnshelve277Unshelve}
     * @memberof ServersActionUnshelve277
     */
    'unshelve': OsVolumesBootActionUnshelve277Unshelve;
}
/**
 * 
 * @export
 * @interface ServersActionUnshelve291
 */
export interface ServersActionUnshelve291 {
    /**
     * 
     * @type {ServersActionUnshelve291Unshelve}
     * @memberof ServersActionUnshelve291
     */
    'unshelve': ServersActionUnshelve291Unshelve;
}
/**
 * @type ServersActionUnshelve291Unshelve
 * @export
 */
export type ServersActionUnshelve291Unshelve = ServersActionUnshelve291UnshelveOneOf | any;

/**
 * 
 * @export
 * @interface ServersActionUnshelve291UnshelveOneOf
 */
export interface ServersActionUnshelve291UnshelveOneOf {
    /**
     * 
     * @type {OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone}
     * @memberof ServersActionUnshelve291UnshelveOneOf
     */
    'availability_zone'?: OsVolumesBootActionUnshelve291UnshelveOneOfAvailabilityZone;
    /**
     * 
     * @type {any}
     * @memberof ServersActionUnshelve291UnshelveOneOf
     */
    'host'?: any;
}
/**
 * @type ServersActionUnshelveRequest
 * @export
 */
export type ServersActionUnshelveRequest = ServersActionUnshelve21 | ServersActionUnshelve277 | ServersActionUnshelve291;

/**
 * 
 * @export
 * @interface ServersCreate20
 */
export interface ServersCreate20 {
    /**
     * 
     * @type {ServersCreate20Server}
     * @memberof ServersCreate20
     */
    'server': ServersCreate20Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate20
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate20
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate20Server
 */
export interface ServersCreate20Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate20Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'OS-DCF:diskConfig'?: ServersCreate20ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'config_drive'?: ServersCreate20ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'return_reservation_id'?: ServersCreate20ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate20Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerUserData}
     * @memberof ServersCreate20Server
     */
    'user_data'?: OsVolumesBootCreate20ServerUserData;
}

export const ServersCreate20ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate20ServerOSDCFdiskConfigEnum = typeof ServersCreate20ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate20ServerOSDCFdiskConfigEnum];
export const ServersCreate20ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate20ServerConfigDriveEnum = typeof ServersCreate20ServerConfigDriveEnum[keyof typeof ServersCreate20ServerConfigDriveEnum];
export const ServersCreate20ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate20ServerReturnReservationIdEnum = typeof ServersCreate20ServerReturnReservationIdEnum[keyof typeof ServersCreate20ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate21
 */
export interface ServersCreate21 {
    /**
     * 
     * @type {ServersCreate21Server}
     * @memberof ServersCreate21
     */
    'server': ServersCreate21Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate21
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate21
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate219
 */
export interface ServersCreate219 {
    /**
     * 
     * @type {ServersCreate219Server}
     * @memberof ServersCreate219
     */
    'server': ServersCreate219Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate219
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate219
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate219Server
 */
export interface ServersCreate219Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate219Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'OS-DCF:diskConfig'?: ServersCreate219ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'config_drive'?: ServersCreate219ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'return_reservation_id'?: ServersCreate219ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate219Server
     */
    'description'?: any;
}

export const ServersCreate219ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate219ServerOSDCFdiskConfigEnum = typeof ServersCreate219ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate219ServerOSDCFdiskConfigEnum];
export const ServersCreate219ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate219ServerConfigDriveEnum = typeof ServersCreate219ServerConfigDriveEnum[keyof typeof ServersCreate219ServerConfigDriveEnum];
export const ServersCreate219ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate219ServerReturnReservationIdEnum = typeof ServersCreate219ServerReturnReservationIdEnum[keyof typeof ServersCreate219ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate21Server
 */
export interface ServersCreate21Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate21Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'OS-DCF:diskConfig'?: ServersCreate21ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'config_drive'?: ServersCreate21ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'return_reservation_id'?: ServersCreate21ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate21Server
     */
    'user_data'?: any;
}

export const ServersCreate21ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate21ServerOSDCFdiskConfigEnum = typeof ServersCreate21ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate21ServerOSDCFdiskConfigEnum];
export const ServersCreate21ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate21ServerConfigDriveEnum = typeof ServersCreate21ServerConfigDriveEnum[keyof typeof ServersCreate21ServerConfigDriveEnum];
export const ServersCreate21ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate21ServerReturnReservationIdEnum = typeof ServersCreate21ServerReturnReservationIdEnum[keyof typeof ServersCreate21ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate232
 */
export interface ServersCreate232 {
    /**
     * 
     * @type {ServersCreate232Server}
     * @memberof ServersCreate232
     */
    'server': ServersCreate232Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate232
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate232
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate232Server
 */
export interface ServersCreate232Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate232Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'OS-DCF:diskConfig'?: ServersCreate232ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'config_drive'?: ServersCreate232ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'return_reservation_id'?: ServersCreate232ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate232Server
     */
    'description'?: any;
}

export const ServersCreate232ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate232ServerOSDCFdiskConfigEnum = typeof ServersCreate232ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate232ServerOSDCFdiskConfigEnum];
export const ServersCreate232ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate232ServerConfigDriveEnum = typeof ServersCreate232ServerConfigDriveEnum[keyof typeof ServersCreate232ServerConfigDriveEnum];
export const ServersCreate232ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate232ServerReturnReservationIdEnum = typeof ServersCreate232ServerReturnReservationIdEnum[keyof typeof ServersCreate232ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate233
 */
export interface ServersCreate233 {
    /**
     * 
     * @type {ServersCreate233Server}
     * @memberof ServersCreate233
     */
    'server': ServersCreate233Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate233
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate233
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate233Server
 */
export interface ServersCreate233Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate233Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'networks'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'OS-DCF:diskConfig'?: ServersCreate233ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'config_drive'?: ServersCreate233ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'return_reservation_id'?: ServersCreate233ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate233Server
     */
    'description'?: any;
}

export const ServersCreate233ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate233ServerOSDCFdiskConfigEnum = typeof ServersCreate233ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate233ServerOSDCFdiskConfigEnum];
export const ServersCreate233ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate233ServerConfigDriveEnum = typeof ServersCreate233ServerConfigDriveEnum[keyof typeof ServersCreate233ServerConfigDriveEnum];
export const ServersCreate233ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate233ServerReturnReservationIdEnum = typeof ServersCreate233ServerReturnReservationIdEnum[keyof typeof ServersCreate233ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate237
 */
export interface ServersCreate237 {
    /**
     * 
     * @type {ServersCreate237Server}
     * @memberof ServersCreate237
     */
    'server': ServersCreate237Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate237
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate237
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate237Server
 */
export interface ServersCreate237Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate237Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate237ServerNetworks}
     * @memberof ServersCreate237Server
     */
    'networks': OsVolumesBootCreate237ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'OS-DCF:diskConfig'?: ServersCreate237ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'config_drive'?: ServersCreate237ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'return_reservation_id'?: ServersCreate237ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate237Server
     */
    'description'?: any;
}

export const ServersCreate237ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate237ServerOSDCFdiskConfigEnum = typeof ServersCreate237ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate237ServerOSDCFdiskConfigEnum];
export const ServersCreate237ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate237ServerConfigDriveEnum = typeof ServersCreate237ServerConfigDriveEnum[keyof typeof ServersCreate237ServerConfigDriveEnum];
export const ServersCreate237ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate237ServerReturnReservationIdEnum = typeof ServersCreate237ServerReturnReservationIdEnum[keyof typeof ServersCreate237ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate242
 */
export interface ServersCreate242 {
    /**
     * 
     * @type {ServersCreate242Server}
     * @memberof ServersCreate242
     */
    'server': ServersCreate242Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate242
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate242
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate242Server
 */
export interface ServersCreate242Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate242Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate242Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'OS-DCF:diskConfig'?: ServersCreate242ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'config_drive'?: ServersCreate242ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'return_reservation_id'?: ServersCreate242ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate242Server
     */
    'description'?: any;
}

export const ServersCreate242ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate242ServerOSDCFdiskConfigEnum = typeof ServersCreate242ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate242ServerOSDCFdiskConfigEnum];
export const ServersCreate242ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate242ServerConfigDriveEnum = typeof ServersCreate242ServerConfigDriveEnum[keyof typeof ServersCreate242ServerConfigDriveEnum];
export const ServersCreate242ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate242ServerReturnReservationIdEnum = typeof ServersCreate242ServerReturnReservationIdEnum[keyof typeof ServersCreate242ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate252
 */
export interface ServersCreate252 {
    /**
     * 
     * @type {ServersCreate252Server}
     * @memberof ServersCreate252
     */
    'server': ServersCreate252Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate252
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate252
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate252Server
 */
export interface ServersCreate252Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate252Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate252Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'OS-DCF:diskConfig'?: ServersCreate252ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'personality'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'config_drive'?: ServersCreate252ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'return_reservation_id'?: ServersCreate252ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate252Server
     */
    'tags'?: any;
}

export const ServersCreate252ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate252ServerOSDCFdiskConfigEnum = typeof ServersCreate252ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate252ServerOSDCFdiskConfigEnum];
export const ServersCreate252ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate252ServerConfigDriveEnum = typeof ServersCreate252ServerConfigDriveEnum[keyof typeof ServersCreate252ServerConfigDriveEnum];
export const ServersCreate252ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate252ServerReturnReservationIdEnum = typeof ServersCreate252ServerReturnReservationIdEnum[keyof typeof ServersCreate252ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate257
 */
export interface ServersCreate257 {
    /**
     * 
     * @type {ServersCreate257Server}
     * @memberof ServersCreate257
     */
    'server': ServersCreate257Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate257
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate257
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate257Server
 */
export interface ServersCreate257Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate257Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate257Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'OS-DCF:diskConfig'?: ServersCreate257ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'config_drive'?: ServersCreate257ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'return_reservation_id'?: ServersCreate257ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate257Server
     */
    'tags'?: any;
}

export const ServersCreate257ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate257ServerOSDCFdiskConfigEnum = typeof ServersCreate257ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate257ServerOSDCFdiskConfigEnum];
export const ServersCreate257ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate257ServerConfigDriveEnum = typeof ServersCreate257ServerConfigDriveEnum[keyof typeof ServersCreate257ServerConfigDriveEnum];
export const ServersCreate257ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate257ServerReturnReservationIdEnum = typeof ServersCreate257ServerReturnReservationIdEnum[keyof typeof ServersCreate257ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate263
 */
export interface ServersCreate263 {
    /**
     * 
     * @type {ServersCreate263Server}
     * @memberof ServersCreate263
     */
    'server': ServersCreate263Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate263
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate263
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate263Server
 */
export interface ServersCreate263Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate263Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate263Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'OS-DCF:diskConfig'?: ServersCreate263ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'config_drive'?: ServersCreate263ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'return_reservation_id'?: ServersCreate263ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate263Server
     */
    'trusted_image_certificates'?: any;
}

export const ServersCreate263ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate263ServerOSDCFdiskConfigEnum = typeof ServersCreate263ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate263ServerOSDCFdiskConfigEnum];
export const ServersCreate263ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate263ServerConfigDriveEnum = typeof ServersCreate263ServerConfigDriveEnum[keyof typeof ServersCreate263ServerConfigDriveEnum];
export const ServersCreate263ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate263ServerReturnReservationIdEnum = typeof ServersCreate263ServerReturnReservationIdEnum[keyof typeof ServersCreate263ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate267
 */
export interface ServersCreate267 {
    /**
     * 
     * @type {ServersCreate267Server}
     * @memberof ServersCreate267
     */
    'server': ServersCreate267Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate267
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate267
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate267Server
 */
export interface ServersCreate267Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate267Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate267Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'OS-DCF:diskConfig'?: ServersCreate267ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'config_drive'?: ServersCreate267ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'return_reservation_id'?: ServersCreate267ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate267Server
     */
    'trusted_image_certificates'?: any;
}

export const ServersCreate267ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate267ServerOSDCFdiskConfigEnum = typeof ServersCreate267ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate267ServerOSDCFdiskConfigEnum];
export const ServersCreate267ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate267ServerConfigDriveEnum = typeof ServersCreate267ServerConfigDriveEnum[keyof typeof ServersCreate267ServerConfigDriveEnum];
export const ServersCreate267ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate267ServerReturnReservationIdEnum = typeof ServersCreate267ServerReturnReservationIdEnum[keyof typeof ServersCreate267ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate274
 */
export interface ServersCreate274 {
    /**
     * 
     * @type {ServersCreate274Server}
     * @memberof ServersCreate274
     */
    'server': ServersCreate274Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate274
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate274
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate274Server
 */
export interface ServersCreate274Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate274Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate274Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'OS-DCF:diskConfig'?: ServersCreate274ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'config_drive'?: ServersCreate274ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'return_reservation_id'?: ServersCreate274ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate274Server
     */
    'hypervisor_hostname'?: any;
}

export const ServersCreate274ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate274ServerOSDCFdiskConfigEnum = typeof ServersCreate274ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate274ServerOSDCFdiskConfigEnum];
export const ServersCreate274ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate274ServerConfigDriveEnum = typeof ServersCreate274ServerConfigDriveEnum[keyof typeof ServersCreate274ServerConfigDriveEnum];
export const ServersCreate274ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate274ServerReturnReservationIdEnum = typeof ServersCreate274ServerReturnReservationIdEnum[keyof typeof ServersCreate274ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate290
 */
export interface ServersCreate290 {
    /**
     * 
     * @type {ServersCreate290Server}
     * @memberof ServersCreate290
     */
    'server': ServersCreate290Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate290
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate290
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate290Server
 */
export interface ServersCreate290Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate290Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate290Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'OS-DCF:diskConfig'?: ServersCreate290ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'config_drive'?: ServersCreate290ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'return_reservation_id'?: ServersCreate290ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'hypervisor_hostname'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate290Server
     */
    'hostname'?: any;
}

export const ServersCreate290ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate290ServerOSDCFdiskConfigEnum = typeof ServersCreate290ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate290ServerOSDCFdiskConfigEnum];
export const ServersCreate290ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate290ServerConfigDriveEnum = typeof ServersCreate290ServerConfigDriveEnum[keyof typeof ServersCreate290ServerConfigDriveEnum];
export const ServersCreate290ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate290ServerReturnReservationIdEnum = typeof ServersCreate290ServerReturnReservationIdEnum[keyof typeof ServersCreate290ServerReturnReservationIdEnum];

/**
 * 
 * @export
 * @interface ServersCreate294
 */
export interface ServersCreate294 {
    /**
     * 
     * @type {ServersCreate294Server}
     * @memberof ServersCreate294
     */
    'server': ServersCreate294Server;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate294
     */
    'os:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
    /**
     * 
     * @type {OsVolumesBootCreate20OsSchedulerHints}
     * @memberof ServersCreate294
     */
    'OS-SCH-HNT:scheduler_hints'?: OsVolumesBootCreate20OsSchedulerHints;
}
/**
 * 
 * @export
 * @interface ServersCreate294Server
 */
export interface ServersCreate294Server {
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'name': any;
    /**
     * 
     * @type {OsVolumesBootCreate20ServerImageRef}
     * @memberof ServersCreate294Server
     */
    'imageRef'?: OsVolumesBootCreate20ServerImageRef;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'flavorRef': any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'adminPass'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'metadata'?: any;
    /**
     * 
     * @type {OsVolumesBootCreate242ServerNetworks}
     * @memberof ServersCreate294Server
     */
    'networks': OsVolumesBootCreate242ServerNetworks;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'OS-DCF:diskConfig'?: ServersCreate294ServerOSDCFdiskConfigEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'accessIPv4'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'accessIPv6'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'availability_zone'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'block_device_mapping'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'block_device_mapping_v2'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'config_drive'?: ServersCreate294ServerConfigDriveEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'key_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'min_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'max_count'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'return_reservation_id'?: ServersCreate294ServerReturnReservationIdEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'security_groups'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'user_data'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'trusted_image_certificates'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'hypervisor_hostname'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersCreate294Server
     */
    'hostname'?: any;
}

export const ServersCreate294ServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreate294ServerOSDCFdiskConfigEnum = typeof ServersCreate294ServerOSDCFdiskConfigEnum[keyof typeof ServersCreate294ServerOSDCFdiskConfigEnum];
export const ServersCreate294ServerConfigDriveEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate294ServerConfigDriveEnum = typeof ServersCreate294ServerConfigDriveEnum[keyof typeof ServersCreate294ServerConfigDriveEnum];
export const ServersCreate294ServerReturnReservationIdEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;

export type ServersCreate294ServerReturnReservationIdEnum = typeof ServersCreate294ServerReturnReservationIdEnum[keyof typeof ServersCreate294ServerReturnReservationIdEnum];

/**
 * @type ServersCreateRequest
 * @export
 */
export type ServersCreateRequest = ServersCreate20 | ServersCreate21 | ServersCreate219 | ServersCreate232 | ServersCreate233 | ServersCreate237 | ServersCreate242 | ServersCreate252 | ServersCreate257 | ServersCreate263 | ServersCreate267 | ServersCreate274 | ServersCreate290 | ServersCreate294;

/**
 * @type ServersCreateResponse
 * @export
 */
export type ServersCreateResponse = ServersCreateResponseOneOf | ServersCreateResponseOneOf1;

/**
 * Created server object
 * @export
 * @interface ServersCreateResponseOneOf
 */
export interface ServersCreateResponseOneOf {
    /**
     * 
     * @type {ServersCreateResponseOneOfServer}
     * @memberof ServersCreateResponseOneOf
     */
    'server'?: ServersCreateResponseOneOfServer;
}
/**
 * 
 * @export
 * @interface ServersCreateResponseOneOf1
 */
export interface ServersCreateResponseOneOf1 {
    /**
     * The reservation id for the server. This is an id that can be useful in tracking groups of servers created with multiple create, that will all have the same reservation_id.
     * @type {any}
     * @memberof ServersCreateResponseOneOf1
     */
    'reservation_id'?: any;
}
/**
 * 
 * @export
 * @interface ServersCreateResponseOneOfServer
 */
export interface ServersCreateResponseOneOfServer {
    /**
     * The disk configuration. Either AUTO or MANUAL.
     * @type {any}
     * @memberof ServersCreateResponseOneOfServer
     */
    'OS-DCF:diskConfig'?: ServersCreateResponseOneOfServerOSDCFdiskConfigEnum;
    /**
     * The administrative password for the server. If you set enable_instance_password configuration option to False, the API wouldn’t return the adminPass field in response.
     * @type {any}
     * @memberof ServersCreateResponseOneOfServer
     */
    'adminPass'?: any;
    /**
     * Id of the server
     * @type {any}
     * @memberof ServersCreateResponseOneOfServer
     */
    'id'?: any;
    /**
     * One or more security groups objects.
     * @type {any}
     * @memberof ServersCreateResponseOneOfServer
     */
    'security_groups'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServersCreateResponseOneOfServer
     */
    'links'?: any;
}

export const ServersCreateResponseOneOfServerOSDCFdiskConfigEnum = {
    Auto: 'AUTO',
    Manual: 'MANUAL'
} as const;

export type ServersCreateResponseOneOfServerOSDCFdiskConfigEnum = typeof ServersCreateResponseOneOfServerOSDCFdiskConfigEnum[keyof typeof ServersCreateResponseOneOfServerOSDCFdiskConfigEnum];

/**
 * 
 * @export
 * @interface ServersDetailResponse
 */
export interface ServersDetailResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersDetailResponse
     */
    'servers'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServersDetailResponse
     */
    'servers_links'?: any;
}
/**
 * 
 * @export
 * @interface ServersDiagnosticsListResponse
 */
export interface ServersDiagnosticsListResponse {
    /**
     * The list of dictionaries with detailed information about VM CPUs.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'cpu_details'?: any;
    /**
     * The list of dictionaries with detailed information about VM disks.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'disk_details'?: any;
    /**
     * The driver on which the VM is running.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'driver'?: ServersDiagnosticsListResponseDriverEnum;
    /**
     * Indicates whether or not a config drive was used for this server.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'config_drive'?: any;
    /**
     * The hypervisor on which the VM is running.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'hypervisor'?: any;
    /**
     * The hypervisor OS.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'hypervisor_os'?: any;
    /**
     * Id of the resource
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'id'?: any;
    /**
     * The dictionary with information about VM memory usage.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'memory_details'?: any;
    /**
     * Name
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'name'?: any;
    /**
     * The list of dictionaries with detailed information about VM NICs.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'nic_details'?: any;
    /**
     * The number of vCPUs.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'num_cpus'?: any;
    /**
     * The number of disks.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'num_disks'?: any;
    /**
     * The number of vNICs.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'num_nics'?: any;
    /**
     * The current state of the VM.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'state'?: ServersDiagnosticsListResponseStateEnum;
    /**
     * The amount of time in seconds that the VM has been running.
     * @type {any}
     * @memberof ServersDiagnosticsListResponse
     */
    'uptime'?: any;
}

export const ServersDiagnosticsListResponseDriverEnum = {
    Libvirt: 'libvirt',
    Xenapi: 'xenapi',
    Hyperv: 'hyperv',
    Vmwareapi: 'vmwareapi',
    Ironic: 'ironic'
} as const;

export type ServersDiagnosticsListResponseDriverEnum = typeof ServersDiagnosticsListResponseDriverEnum[keyof typeof ServersDiagnosticsListResponseDriverEnum];
export const ServersDiagnosticsListResponseStateEnum = {
    Pending: 'pending',
    Running: 'running',
    Paused: 'paused',
    Shutdown: 'shutdown',
    Crashed: 'crashed',
    Suspended: 'suspended'
} as const;

export type ServersDiagnosticsListResponseStateEnum = typeof ServersDiagnosticsListResponseStateEnum[keyof typeof ServersDiagnosticsListResponseStateEnum];

/**
 * @type ServersIdActionPost201Response
 * @export
 */
export type ServersIdActionPost201Response = ServersActionEvacuateResponse | ServersActionOsGetconsoleoutputResponse | ServersActionOsGetrdpconsoleResponse | ServersActionOsGetserialconsoleResponse | ServersActionOsGetspiceconsoleResponse | ServersActionOsGetvncconsoleResponse | ServersActionRescueResponse;

/**
 * @type ServersIdActionPost202Response
 * @export
 */
export type ServersIdActionPost202Response = ServersActionCreatebackupResponse | ServersActionCreateimageResponse;

/**
 * @type ServersIdActionPostRequest
 * @export
 */
export type ServersIdActionPostRequest = ServersActionActionConfirmResize | ServersActionActionReboot | ServersActionActionResize | ServersActionActionRevertResize | ServersActionActionTriggerCrashDump | ServersActionAddFixedIp | ServersActionAddFloatingIp | ServersActionAddsecuritygroup | ServersActionChangePassword | ServersActionCreatebackupRequest | ServersActionCreateimageRequest | ServersActionEvacuateRequest | ServersActionForceDelete | ServersActionGetConsoleOutput | ServersActionGetSerialConsole | ServersActionGetSpiceConsole | ServersActionGetVncConsole | ServersActionInjectNetworkInfo | ServersActionLockRequest | ServersActionMigrate256 | ServersActionOsGetrdpconsoleRequest | ServersActionOsMigrateliveRequest | ServersActionPause | ServersActionRebuildRequest | ServersActionRemoveFixedIp | ServersActionRemoveFloatingIp | ServersActionRemovesecuritygroup | ServersActionRescue | ServersActionResetState | ServersActionResetnetworkRequest | ServersActionRestore | ServersActionResume | ServersActionShelve | ServersActionShelveOffload | ServersActionStartServer | ServersActionStopServer | ServersActionSuspend | ServersActionUnlock21 | ServersActionUnpause | ServersActionUnrescue | ServersActionUnshelveRequest;

/**
 * The addresses information for the server.
 * @export
 * @interface ServersIpsListResponse
 */
export interface ServersIpsListResponse {
    /**
     * A dictionary of addresses this server can be accessed through. The dictionary contains keys such as ``private`` and ``public``, each containing a list of dictionaries for addresses of that type. The addresses are contained in a dictionary with keys ``addr`` and ``version``, which is either 4 or 6 depending on the protocol of the IP address.
     * @type {{ [key: string]: any; }}
     * @memberof ServersIpsListResponse
     */
    'addresses'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface ServersListResponse
 */
export interface ServersListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersListResponse
     */
    'servers'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServersListResponse
     */
    'servers_links'?: any;
}
/**
 * 
 * @export
 * @interface ServersMetadataCreate
 */
export interface ServersMetadataCreate {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof ServersMetadataCreate
     */
    'metadata': any;
}
/**
 * Metadata key and value pairs. The maximum size for each metadata key and value pair is 255 bytes.
 * @export
 * @interface ServersMetadataCreateResponse
 */
export interface ServersMetadataCreateResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersMetadataCreateResponse
     */
    'metadata'?: any;
}
/**
 * Metadata key and value pairs. The maximum size for each metadata key and value pair is 255 bytes.
 * @export
 * @interface ServersMetadataListResponse
 */
export interface ServersMetadataListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersMetadataListResponse
     */
    'metadata'?: any;
}
/**
 * Metadata key and value pairs. The maximum size for each metadata key and value pair is 255 bytes.
 * @export
 * @interface ServersMetadataShowResponse
 */
export interface ServersMetadataShowResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersMetadataShowResponse
     */
    'meta'?: any;
}
/**
 * 
 * @export
 * @interface ServersMetadataUpdate
 */
export interface ServersMetadataUpdate {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof ServersMetadataUpdate
     */
    'meta': any;
}
/**
 * 
 * @export
 * @interface ServersMetadataUpdateAll
 */
export interface ServersMetadataUpdateAll {
    /**
     * 
     * @type {any}
     * @memberof ServersMetadataUpdateAll
     */
    'metadata': any;
}
/**
 * Metadata key and value pairs. The maximum size for each metadata key and value pair is 255 bytes.
 * @export
 * @interface ServersMetadataUpdateAllResponse
 */
export interface ServersMetadataUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersMetadataUpdateAllResponse
     */
    'metadata'?: any;
}
/**
 * 
 * @export
 * @interface ServersMigrationShowResponse
 */
export interface ServersMigrationShowResponse {
    /**
     * 
     * @type {ServersMigrationShowResponseMigration}
     * @memberof ServersMigrationShowResponse
     */
    'migration'?: ServersMigrationShowResponseMigration;
}
/**
 * Migration object
 * @export
 * @interface ServersMigrationShowResponseMigration
 */
export interface ServersMigrationShowResponseMigration {
    /**
     * The date and time when the resource was created.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'created_at'?: any;
    /**
     * The date and time when the resource was updated.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'updated_at'?: any;
    /**
     * The target compute for a migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'dest_compute'?: any;
    /**
     * The target host for a migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'dest_host'?: any;
    /**
     * The target node for a migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'dest_node'?: any;
    /**
     * The ID of the server migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'id'?: any;
    /**
     * The source compute for a migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'source_compute'?: any;
    /**
     * The source node for a migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'source_node'?: any;
    /**
     * The current status of the migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'status'?: any;
    /**
     * The ID of the project which initiated the server migration. The value may be null for older migration records.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'project_id'?: any;
    /**
     * The ID of the user which initiated the server migration. The value may be null for older migration records.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'user_id'?: any;
    /**
     * The UUID of the migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'uuid'?: any;
    /**
     * The amount of disk, in bytes, that has been processed during the migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'disk_processed_bytes'?: any;
    /**
     * The amount of disk, in bytes, that still needs to be migrated.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'disk_remaining_bytes'?: any;
    /**
     * The total amount of disk, in bytes, that needs to be migrated.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'disk_total_bytes'?: any;
    /**
     * The amount of memory, in bytes, that has been processed during the migration.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'memory_processed_bytes'?: any;
    /**
     * The amount of memory, in bytes, that still needs to be migrated.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'memory_remaining_bytes'?: any;
    /**
     * The total amount of memory, in bytes, that needs to be migrated.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'memory_total_bytes'?: any;
    /**
     * The UUID of the server.
     * @type {any}
     * @memberof ServersMigrationShowResponseMigration
     */
    'server_uuid'?: any;
}
/**
 * 
 * @export
 * @interface ServersMigrationsActionForceComplete
 */
export interface ServersMigrationsActionForceComplete {
    /**
     * 
     * @type {any}
     * @memberof ServersMigrationsActionForceComplete
     */
    'force_complete': any;
}
/**
 * List of migration objects
 * @export
 * @interface ServersMigrationsListResponse
 */
export interface ServersMigrationsListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersMigrationsListResponse
     */
    'migrations'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInstanceActionShowResponse
 */
export interface ServersOsInstanceActionShowResponse {
    /**
     * 
     * @type {ServersOsInstanceActionShowResponseInstanceAction}
     * @memberof ServersOsInstanceActionShowResponse
     */
    'instanceAction'?: ServersOsInstanceActionShowResponseInstanceAction;
}
/**
 * The instance action object.
 * @export
 * @interface ServersOsInstanceActionShowResponseInstanceAction
 */
export interface ServersOsInstanceActionShowResponseInstanceAction {
    /**
     * The name of the action.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'action'?: any;
    /**
     * Events
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'events'?: any;
    /**
     * The related error message for when an action fails.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'message'?: any;
    /**
     * The ID of the project that this server belongs to.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'project_id'?: any;
    /**
     * The ID of the request that this action related to.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'request_id'?: any;
    /**
     * The date and time when the action was started.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'start_time'?: any;
    /**
     * The ID of the user which initiated the server action.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'user_id'?: any;
    /**
     * The date and time when the instance action or the action event of instance action was updated.
     * @type {any}
     * @memberof ServersOsInstanceActionShowResponseInstanceAction
     */
    'updated_at'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInstanceActionsListResponse
 */
export interface ServersOsInstanceActionsListResponse {
    /**
     * List of the actions for the given instance in descending order of creation.
     * @type {any}
     * @memberof ServersOsInstanceActionsListResponse
     */
    'instanceActions'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof ServersOsInstanceActionsListResponse
     */
    'links'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceCreate20
 */
export interface ServersOsInterfaceCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsInterfaceCreate20InterfaceAttachment}
     * @memberof ServersOsInterfaceCreate20
     */
    'interfaceAttachment'?: ServersOsInterfaceCreate20InterfaceAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceCreate20InterfaceAttachment
 */
export interface ServersOsInterfaceCreate20InterfaceAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate20InterfaceAttachment
     */
    'net_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate20InterfaceAttachment
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate20InterfaceAttachment
     */
    'fixed_ips'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceCreate249
 */
export interface ServersOsInterfaceCreate249 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsInterfaceCreate249InterfaceAttachment}
     * @memberof ServersOsInterfaceCreate249
     */
    'interfaceAttachment'?: ServersOsInterfaceCreate249InterfaceAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceCreate249InterfaceAttachment
 */
export interface ServersOsInterfaceCreate249InterfaceAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate249InterfaceAttachment
     */
    'net_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate249InterfaceAttachment
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate249InterfaceAttachment
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceCreate249InterfaceAttachment
     */
    'tag'?: any;
}
/**
 * @type ServersOsInterfaceCreateRequest
 * @export
 */
export type ServersOsInterfaceCreateRequest = ServersOsInterfaceCreate20 | ServersOsInterfaceCreate249;

/**
 * 
 * @export
 * @interface ServersOsInterfaceCreateResponse
 */
export interface ServersOsInterfaceCreateResponse {
    /**
     * 
     * @type {ServersOsInterfaceCreateResponseInterfaceAttachment}
     * @memberof ServersOsInterfaceCreateResponse
     */
    'interfaceAttachment'?: ServersOsInterfaceCreateResponseInterfaceAttachment;
}
/**
 * The interface attachment.
 * @export
 * @interface ServersOsInterfaceCreateResponseInterfaceAttachment
 */
export interface ServersOsInterfaceCreateResponseInterfaceAttachment {
    /**
     * Fixed IP addresses with subnet IDs.
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'fixed_ips'?: any;
    /**
     * The MAC address
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'mac_addr'?: any;
    /**
     * The network ID.
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'net_id'?: any;
    /**
     * The port ID.
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'port_id'?: any;
    /**
     * The port state.
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'port_state'?: any;
    /**
     * The device tag applied to the virtual network interface or null.
     * @type {any}
     * @memberof ServersOsInterfaceCreateResponseInterfaceAttachment
     */
    'tag'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceListResponse
 */
export interface ServersOsInterfaceListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersOsInterfaceListResponse
     */
    'interfaceAttachments'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsInterfaceShowResponse
 */
export interface ServersOsInterfaceShowResponse {
    /**
     * 
     * @type {ServersOsInterfaceCreateResponseInterfaceAttachment}
     * @memberof ServersOsInterfaceShowResponse
     */
    'interfaceAttachment'?: ServersOsInterfaceCreateResponseInterfaceAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsSecurityGroupsListResponse
 */
export interface ServersOsSecurityGroupsListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersOsSecurityGroupsListResponse
     */
    'security_groups'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsServerPasswordListResponse
 */
export interface ServersOsServerPasswordListResponse {
    /**
     * The password returned from metadata server.
     * @type {any}
     * @memberof ServersOsServerPasswordListResponse
     */
    'password'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentShowResponse
 */
export interface ServersOsVolumeAttachmentShowResponse {
    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreateResponseVolumeAttachment}
     * @memberof ServersOsVolumeAttachmentShowResponse
     */
    'volumeAttachment'?: ServersOsVolumeAttachmentsCreateResponseVolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentUpdate20
 */
export interface ServersOsVolumeAttachmentUpdate20 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsVolumeAttachmentUpdate20VolumeAttachment}
     * @memberof ServersOsVolumeAttachmentUpdate20
     */
    'volumeAttachment': ServersOsVolumeAttachmentUpdate20VolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentUpdate20VolumeAttachment
 */
export interface ServersOsVolumeAttachmentUpdate20VolumeAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate20VolumeAttachment
     */
    'volumeId': any;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentUpdate285
 */
export interface ServersOsVolumeAttachmentUpdate285 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsVolumeAttachmentUpdate285VolumeAttachment}
     * @memberof ServersOsVolumeAttachmentUpdate285
     */
    'volumeAttachment': ServersOsVolumeAttachmentUpdate285VolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentUpdate285VolumeAttachment
 */
export interface ServersOsVolumeAttachmentUpdate285VolumeAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'volumeId': any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'device'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'tag'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'delete_on_termination'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'serverId'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentUpdate285VolumeAttachment
     */
    'id'?: any;
}


/**
 * @type ServersOsVolumeAttachmentUpdateRequest
 * @export
 */
export type ServersOsVolumeAttachmentUpdateRequest = ServersOsVolumeAttachmentUpdate20 | ServersOsVolumeAttachmentUpdate285;

/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentUpdateResponse
 */
export interface ServersOsVolumeAttachmentUpdateResponse {
    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreateResponseVolumeAttachment}
     * @memberof ServersOsVolumeAttachmentUpdateResponse
     */
    'volumeAttachment'?: ServersOsVolumeAttachmentsCreateResponseVolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate20
 */
export interface ServersOsVolumeAttachmentsCreate20 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreate20VolumeAttachment}
     * @memberof ServersOsVolumeAttachmentsCreate20
     */
    'volumeAttachment': ServersOsVolumeAttachmentsCreate20VolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate20VolumeAttachment
 */
export interface ServersOsVolumeAttachmentsCreate20VolumeAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate20VolumeAttachment
     */
    'volumeId': any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate20VolumeAttachment
     */
    'device'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate249
 */
export interface ServersOsVolumeAttachmentsCreate249 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreate249VolumeAttachment}
     * @memberof ServersOsVolumeAttachmentsCreate249
     */
    'volumeAttachment': ServersOsVolumeAttachmentsCreate249VolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate249VolumeAttachment
 */
export interface ServersOsVolumeAttachmentsCreate249VolumeAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate249VolumeAttachment
     */
    'volumeId': any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate249VolumeAttachment
     */
    'device'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate249VolumeAttachment
     */
    'tag'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate279
 */
export interface ServersOsVolumeAttachmentsCreate279 {
    [key: string]: any;

    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreate279VolumeAttachment}
     * @memberof ServersOsVolumeAttachmentsCreate279
     */
    'volumeAttachment': ServersOsVolumeAttachmentsCreate279VolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreate279VolumeAttachment
 */
export interface ServersOsVolumeAttachmentsCreate279VolumeAttachment {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate279VolumeAttachment
     */
    'volumeId': any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate279VolumeAttachment
     */
    'device'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreate279VolumeAttachment
     */
    'tag'?: any;
    /**
     * 
     * @type {FlavorsCreate20FlavorOsFlavorAccessIsPublic}
     * @memberof ServersOsVolumeAttachmentsCreate279VolumeAttachment
     */
    'delete_on_termination'?: FlavorsCreate20FlavorOsFlavorAccessIsPublic;
}


/**
 * @type ServersOsVolumeAttachmentsCreateRequest
 * @export
 */
export type ServersOsVolumeAttachmentsCreateRequest = ServersOsVolumeAttachmentsCreate20 | ServersOsVolumeAttachmentsCreate249 | ServersOsVolumeAttachmentsCreate279;

/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreateResponse
 */
export interface ServersOsVolumeAttachmentsCreateResponse {
    /**
     * 
     * @type {ServersOsVolumeAttachmentsCreateResponseVolumeAttachment}
     * @memberof ServersOsVolumeAttachmentsCreateResponse
     */
    'volumeAttachment'?: ServersOsVolumeAttachmentsCreateResponseVolumeAttachment;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
 */
export interface ServersOsVolumeAttachmentsCreateResponseVolumeAttachment {
    /**
     * Name of the device in the attachment object, such as, /dev/vdb.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'device'?: any;
    /**
     * The volume ID of the attachment
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'id'?: any;
    /**
     * The UUID of the server.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'serverId'?: any;
    /**
     * The UUID of the attached volume.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'volumeId'?: any;
    /**
     * The device tag applied to the volume block device or null.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'tag'?: any;
    /**
     * A flag indicating if the attached volume will be deleted when the server is deleted.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'delete_on_termination'?: any;
    /**
     * The UUID of the associated volume attachment in Cinder.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'attachment_id'?: any;
    /**
     * The UUID of the block device mapping record in Nova for the attachment.
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsCreateResponseVolumeAttachment
     */
    'bdm_uuid'?: any;
}
/**
 * 
 * @export
 * @interface ServersOsVolumeAttachmentsListResponse
 */
export interface ServersOsVolumeAttachmentsListResponse {
    /**
     * 
     * @type {any}
     * @memberof ServersOsVolumeAttachmentsListResponse
     */
    'volumeAttachments'?: any;
}
/**
 * 
 * @export
 * @interface ServersRemoteConsolesCreate26
 */
export interface ServersRemoteConsolesCreate26 {
    [key: string]: any;

    /**
     * 
     * @type {ServersRemoteConsolesCreate26RemoteConsole}
     * @memberof ServersRemoteConsolesCreate26
     */
    'remote_console': ServersRemoteConsolesCreate26RemoteConsole;
}
/**
 * 
 * @export
 * @interface ServersRemoteConsolesCreate26RemoteConsole
 */
export interface ServersRemoteConsolesCreate26RemoteConsole {
    /**
     * 
     * @type {any}
     * @memberof ServersRemoteConsolesCreate26RemoteConsole
     */
    'protocol': ServersRemoteConsolesCreate26RemoteConsoleProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersRemoteConsolesCreate26RemoteConsole
     */
    'type': ServersRemoteConsolesCreate26RemoteConsoleTypeEnum;
}

export const ServersRemoteConsolesCreate26RemoteConsoleProtocolEnum = {
    Vnc: 'vnc',
    Spice: 'spice',
    Serial: 'serial'
} as const;

export type ServersRemoteConsolesCreate26RemoteConsoleProtocolEnum = typeof ServersRemoteConsolesCreate26RemoteConsoleProtocolEnum[keyof typeof ServersRemoteConsolesCreate26RemoteConsoleProtocolEnum];
export const ServersRemoteConsolesCreate26RemoteConsoleTypeEnum = {
    Novnc: 'novnc',
    Xvpvnc: 'xvpvnc',
    SpiceHtml5: 'spice-html5',
    Serial: 'serial'
} as const;

export type ServersRemoteConsolesCreate26RemoteConsoleTypeEnum = typeof ServersRemoteConsolesCreate26RemoteConsoleTypeEnum[keyof typeof ServersRemoteConsolesCreate26RemoteConsoleTypeEnum];

/**
 * 
 * @export
 * @interface ServersRemoteConsolesCreate28
 */
export interface ServersRemoteConsolesCreate28 {
    [key: string]: any;

    /**
     * 
     * @type {ServersRemoteConsolesCreate28RemoteConsole}
     * @memberof ServersRemoteConsolesCreate28
     */
    'remote_console': ServersRemoteConsolesCreate28RemoteConsole;
}
/**
 * 
 * @export
 * @interface ServersRemoteConsolesCreate28RemoteConsole
 */
export interface ServersRemoteConsolesCreate28RemoteConsole {
    /**
     * 
     * @type {any}
     * @memberof ServersRemoteConsolesCreate28RemoteConsole
     */
    'protocol': ServersRemoteConsolesCreate28RemoteConsoleProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof ServersRemoteConsolesCreate28RemoteConsole
     */
    'type': ServersRemoteConsolesCreate28RemoteConsoleTypeEnum;
}

export const ServersRemoteConsolesCreate28RemoteConsoleProtocolEnum = {
    Vnc: 'vnc',
    Spice: 'spice',
    Serial: 'serial',
    Mks: 'mks'
} as const;

export type ServersRemoteConsolesCreate28RemoteConsoleProtocolEnum = typeof ServersRemoteConsolesCreate28RemoteConsoleProtocolEnum[keyof typeof ServersRemoteConsolesCreate28RemoteConsoleProtocolEnum];
export const ServersRemoteConsolesCreate28RemoteConsoleTypeEnum = {
    Novnc: 'novnc',
    Xvpvnc: 'xvpvnc',
    SpiceHtml5: 'spice-html5',
    Serial: 'serial',
    Webmks: 'webmks'
} as const;

export type ServersRemoteConsolesCreate28RemoteConsoleTypeEnum = typeof ServersRemoteConsolesCreate28RemoteConsoleTypeEnum[keyof typeof ServersRemoteConsolesCreate28RemoteConsoleTypeEnum];

/**
 * @type ServersRemoteConsolesCreateRequest
 * @export
 */
export type ServersRemoteConsolesCreateRequest = ServersRemoteConsolesCreate26 | ServersRemoteConsolesCreate28;

/**
 * Create Console Response
 * @export
 * @interface ServersRemoteConsolesCreateResponse
 */
export interface ServersRemoteConsolesCreateResponse {
    /**
     * 
     * @type {ServersRemoteConsolesCreateResponseRemoteConsole}
     * @memberof ServersRemoteConsolesCreateResponse
     */
    'remote_console'?: ServersRemoteConsolesCreateResponseRemoteConsole;
}
/**
 * The remote console object.
 * @export
 * @interface ServersRemoteConsolesCreateResponseRemoteConsole
 */
export interface ServersRemoteConsolesCreateResponseRemoteConsole {
    /**
     * The protocol of remote console. The valid values are vnc, spice, rdp, serial and mks. The protocol mks is added since Microversion 2.8.
     * @type {any}
     * @memberof ServersRemoteConsolesCreateResponseRemoteConsole
     */
    'protocol'?: ServersRemoteConsolesCreateResponseRemoteConsoleProtocolEnum;
    /**
     * The type of remote console. The valid values are novnc, rdp-html5, spice-html5, serial, and webmks. The type webmks is added since Microversion 2.8.
     * @type {any}
     * @memberof ServersRemoteConsolesCreateResponseRemoteConsole
     */
    'type'?: ServersRemoteConsolesCreateResponseRemoteConsoleTypeEnum;
    /**
     * The URL is used to connect the console.
     * @type {any}
     * @memberof ServersRemoteConsolesCreateResponseRemoteConsole
     */
    'url'?: any;
}

export const ServersRemoteConsolesCreateResponseRemoteConsoleProtocolEnum = {
    Vnc: 'vnc',
    Spice: 'spice',
    Serial: 'serial',
    Mks: 'mks'
} as const;

export type ServersRemoteConsolesCreateResponseRemoteConsoleProtocolEnum = typeof ServersRemoteConsolesCreateResponseRemoteConsoleProtocolEnum[keyof typeof ServersRemoteConsolesCreateResponseRemoteConsoleProtocolEnum];
export const ServersRemoteConsolesCreateResponseRemoteConsoleTypeEnum = {
    Novnc: 'novnc',
    Xvpvnc: 'xvpvnc',
    SpiceHtml5: 'spice-html5',
    Serial: 'serial',
    Webmks: 'webmks'
} as const;

export type ServersRemoteConsolesCreateResponseRemoteConsoleTypeEnum = typeof ServersRemoteConsolesCreateResponseRemoteConsoleTypeEnum[keyof typeof ServersRemoteConsolesCreateResponseRemoteConsoleTypeEnum];

/**
 * @type ServersServerIdMigrationsIdActionPostRequest
 * @export
 */
export type ServersServerIdMigrationsIdActionPostRequest = ServersMigrationsActionForceComplete;

/**
 * Server Tags
 * @export
 * @interface ServersTagsListResponse
 */
export interface ServersTagsListResponse {
    /**
     * A list of tags. The maximum count of tags in this list is 50.
     * @type {any}
     * @memberof ServersTagsListResponse
     */
    'tags'?: any;
}
/**
 * 
 * @export
 * @interface ServersTagsUpdateAll
 */
export interface ServersTagsUpdateAll {
    /**
     * 
     * @type {any}
     * @memberof ServersTagsUpdateAll
     */
    'tags': any;
}
/**
 * Server Tags
 * @export
 * @interface ServersTagsUpdateAllResponse
 */
export interface ServersTagsUpdateAllResponse {
    /**
     * A list of tags. The maximum count of tags in this list is 50.
     * @type {any}
     * @memberof ServersTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * NUMA topology information for a server
 * @export
 * @interface ServersTopologyListResponse
 */
export interface ServersTopologyListResponse {
    /**
     * NUMA nodes information of a server
     * @type {any}
     * @memberof ServersTopologyListResponse
     */
    'nodes'?: any;
}

/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extensionsIdGet', 'id', id)
            const localVarPath = `/v2.1/extensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extensionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extensionsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.extensionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extensionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extensionsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.extensionsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsGet(options?: any): AxiosPromise<ExtensionsListResponse> {
            return localVarFp.extensionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsIdGet(id: string, options?: any): AxiosPromise<ExtensionShowResponse> {
            return localVarFp.extensionsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public extensionsGet(options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).extensionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/extensions/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public extensionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).extensionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return all flavors in detail.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsDetailGetSortKeyEnum} [sortKey] 
         * @param {FlavorsDetailGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsDetailGet: async (limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsDetailGetSortKeyEnum, sortDir?: FlavorsDetailGetSortDirEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/flavors/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (minRam !== undefined) {
                localVarQueryParameter['minRam'] = minRam;
            }

            if (minDisk !== undefined) {
                localVarQueryParameter['minDisk'] = minDisk;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of extra specs for a given flavor.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsGet: async (flavorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsGet', 'flavorId', flavorId)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-extra_specs`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Deletes an existing extra spec.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdDelete: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdDelete', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdDelete', 'id', id)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-extra_specs/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return a single extra spec item.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdGet: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdGet', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdGet', 'id', id)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-extra_specs/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdPut: async (flavorId: string, id: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdPut', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsIdPut', 'id', id)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-extra_specs/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {FlavorsOsExtraSpecsCreate} [flavorsOsExtraSpecsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsPost: async (flavorId: string, flavorsOsExtraSpecsCreate?: FlavorsOsExtraSpecsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsExtraSpecsPost', 'flavorId', flavorId)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-extra_specs`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsOsExtraSpecsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-flavor-access API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsFlavorAccessGet: async (flavorId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdOsFlavorAccessGet', 'flavorId', flavorId)
            const localVarPath = `/v2.1/flavors/{flavor_id}/os-flavor-access`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return all flavors in brief.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsGetSortKeyEnum} [sortKey] 
         * @param {FlavorsGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsGet: async (limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsGetSortKeyEnum, sortDir?: FlavorsGetSortDirEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (isPublic !== undefined) {
                localVarQueryParameter['is_public'] = isPublic;
            }

            if (minRam !== undefined) {
                localVarQueryParameter['minRam'] = minRam;
            }

            if (minDisk !== undefined) {
                localVarQueryParameter['minDisk'] = minDisk;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id}/action API
         * @param {FlavorsIdActionPostRequest} [flavorsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdActionPost: async (id: string, flavorsIdActionPostRequest?: FlavorsIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdActionPost', 'id', id)
            const localVarPath = `/v2.1/flavors/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdDelete', 'id', id)
            const localVarPath = `/v2.1/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given flavor id.
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdGet', 'id', id)
            const localVarPath = `/v2.1/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {FlavorUpdate255} [flavorUpdate255] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdPut: async (id: string, flavorUpdate255?: FlavorUpdate255, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdPut', 'id', id)
            const localVarPath = `/v2.1/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorUpdate255, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsPost: async (flavorsCreateRequest?: FlavorsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return all flavors in detail.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsDetailGetSortKeyEnum} [sortKey] 
         * @param {FlavorsDetailGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsDetailGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsDetailGetSortKeyEnum, sortDir?: FlavorsDetailGetSortDirEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsDetailGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of extra specs for a given flavor.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsExtraSpecsGet(flavorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsOsExtraSpecsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsExtraSpecsGet(flavorId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsExtraSpecsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Deletes an existing extra spec.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsExtraSpecsIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsExtraSpecsIdDelete(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsExtraSpecsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return a single extra spec item.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsExtraSpecsIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsExtraSpecsIdGet(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsExtraSpecsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsExtraSpecsIdPut(flavorId: string, id: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsExtraSpecsIdPut(flavorId, id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsExtraSpecsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {FlavorsOsExtraSpecsCreate} [flavorsOsExtraSpecsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsExtraSpecsPost(flavorId: string, flavorsOsExtraSpecsCreate?: FlavorsOsExtraSpecsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsOsExtraSpecsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsExtraSpecsPost(flavorId, flavorsOsExtraSpecsCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsExtraSpecsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-flavor-access API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdOsFlavorAccessGet(flavorId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsOsFlavorAccessListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdOsFlavorAccessGet(flavorId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdOsFlavorAccessGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return all flavors in brief.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsGetSortKeyEnum} [sortKey] 
         * @param {FlavorsGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsGetSortKeyEnum, sortDir?: FlavorsGetSortDirEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id}/action API
         * @param {FlavorsIdActionPostRequest} [flavorsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdActionPost(id: string, flavorsIdActionPostRequest?: FlavorsIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdActionPost(id, flavorsIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given flavor id.
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {FlavorUpdate255} [flavorUpdate255] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdPut(id: string, flavorUpdate255?: FlavorUpdate255, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdPut(id, flavorUpdate255, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsPost(flavorsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         *  Return all flavors in detail.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsDetailGetSortKeyEnum} [sortKey] 
         * @param {FlavorsDetailGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsDetailGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsDetailGetSortKeyEnum, sortDir?: FlavorsDetailGetSortDirEnum, options?: any): AxiosPromise<FlavorsDetailResponse> {
            return localVarFp.flavorsDetailGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of extra specs for a given flavor.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsGet(flavorId: string, options?: any): AxiosPromise<FlavorsOsExtraSpecsListResponse> {
            return localVarFp.flavorsFlavorIdOsExtraSpecsGet(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes an existing extra spec.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdDelete(flavorId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.flavorsFlavorIdOsExtraSpecsIdDelete(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return a single extra spec item.
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdGet(flavorId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.flavorsFlavorIdOsExtraSpecsIdGet(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsIdPut(flavorId: string, id: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.flavorsFlavorIdOsExtraSpecsIdPut(flavorId, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
         * @param {FlavorsOsExtraSpecsCreate} [flavorsOsExtraSpecsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsExtraSpecsPost(flavorId: string, flavorsOsExtraSpecsCreate?: FlavorsOsExtraSpecsCreate, options?: any): AxiosPromise<FlavorsOsExtraSpecsCreateResponse> {
            return localVarFp.flavorsFlavorIdOsExtraSpecsPost(flavorId, flavorsOsExtraSpecsCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-flavor-access API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdOsFlavorAccessGet(flavorId: string, options?: any): AxiosPromise<FlavorsOsFlavorAccessListResponse> {
            return localVarFp.flavorsFlavorIdOsFlavorAccessGet(flavorId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return all flavors in brief.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [isPublic] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {FlavorsGetSortKeyEnum} [sortKey] 
         * @param {FlavorsGetSortDirEnum} [sortDir] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsGetSortKeyEnum, sortDir?: FlavorsGetSortDirEnum, options?: any): AxiosPromise<FlavorsListResponse> {
            return localVarFp.flavorsGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id}/action API
         * @param {FlavorsIdActionPostRequest} [flavorsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdActionPost(id: string, flavorsIdActionPostRequest?: FlavorsIdActionPostRequest, options?: any): AxiosPromise<FlavorsIdActionPost201Response> {
            return localVarFp.flavorsIdActionPost(id, flavorsIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.flavorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given flavor id.
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdGet(id: string, options?: any): AxiosPromise<FlavorShowResponse> {
            return localVarFp.flavorsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/flavors/{id} API
         * @param {FlavorUpdate255} [flavorUpdate255] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdPut(id: string, flavorUpdate255?: FlavorUpdate255, options?: any): AxiosPromise<FlavorUpdateResponse> {
            return localVarFp.flavorsIdPut(id, flavorUpdate255, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: any): AxiosPromise<FlavorsCreateResponse> {
            return localVarFp.flavorsPost(flavorsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     *  Return all flavors in detail.
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [isPublic] 
     * @param {string} [minRam] 
     * @param {string} [minDisk] 
     * @param {FlavorsDetailGetSortKeyEnum} [sortKey] 
     * @param {FlavorsDetailGetSortDirEnum} [sortDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsDetailGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsDetailGetSortKeyEnum, sortDir?: FlavorsDetailGetSortDirEnum, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsDetailGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of extra specs for a given flavor.
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsExtraSpecsGet(flavorId: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsExtraSpecsGet(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Deletes an existing extra spec.
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsExtraSpecsIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsExtraSpecsIdDelete(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return a single extra spec item.
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsExtraSpecsIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsExtraSpecsIdGet(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {string} id id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsExtraSpecsIdPut(flavorId: string, id: string, body?: any, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsExtraSpecsIdPut(flavorId, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-extra_specs/{id} API
     * @param {FlavorsOsExtraSpecsCreate} [flavorsOsExtraSpecsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsExtraSpecsPost(flavorId: string, flavorsOsExtraSpecsCreate?: FlavorsOsExtraSpecsCreate, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsExtraSpecsPost(flavorId, flavorsOsExtraSpecsCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.1/flavors/{flavor_id}/os-flavor-access API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdOsFlavorAccessGet(flavorId: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdOsFlavorAccessGet(flavorId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return all flavors in brief.
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [isPublic] 
     * @param {string} [minRam] 
     * @param {string} [minDisk] 
     * @param {FlavorsGetSortKeyEnum} [sortKey] 
     * @param {FlavorsGetSortDirEnum} [sortDir] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsGet(limit?: number | string, marker?: string, isPublic?: string, minRam?: string, minDisk?: string, sortKey?: FlavorsGetSortKeyEnum, sortDir?: FlavorsGetSortDirEnum, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsGet(limit, marker, isPublic, minRam, minDisk, sortKey, sortDir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/flavors/{id}/action API
     * @param {FlavorsIdActionPostRequest} [flavorsIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdActionPost(id: string, flavorsIdActionPostRequest?: FlavorsIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdActionPost(id, flavorsIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/flavors/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given flavor id.
     * @param {string} id id parameter for /v2.1/flavors/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/flavors/{id} API
     * @param {FlavorUpdate255} [flavorUpdate255] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdPut(id: string, flavorUpdate255?: FlavorUpdate255, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdPut(id, flavorUpdate255, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsPost(flavorsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FlavorsDetailGetSortKeyEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Disabled: 'disabled',
    EphemeralGb: 'ephemeral_gb',
    Flavorid: 'flavorid',
    Id: 'id',
    IsPublic: 'is_public',
    MemoryMb: 'memory_mb',
    Name: 'name',
    RootGb: 'root_gb',
    RxtxFactor: 'rxtx_factor',
    Swap: 'swap',
    UpdatedAt: 'updated_at',
    VcpuWeight: 'vcpu_weight',
    Vcpus: 'vcpus'
} as const;
export type FlavorsDetailGetSortKeyEnum = typeof FlavorsDetailGetSortKeyEnum[keyof typeof FlavorsDetailGetSortKeyEnum];
/**
 * @export
 */
export const FlavorsDetailGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FlavorsDetailGetSortDirEnum = typeof FlavorsDetailGetSortDirEnum[keyof typeof FlavorsDetailGetSortDirEnum];
/**
 * @export
 */
export const FlavorsGetSortKeyEnum = {
    CreatedAt: 'created_at',
    Description: 'description',
    Disabled: 'disabled',
    EphemeralGb: 'ephemeral_gb',
    Flavorid: 'flavorid',
    Id: 'id',
    IsPublic: 'is_public',
    MemoryMb: 'memory_mb',
    Name: 'name',
    RootGb: 'root_gb',
    RxtxFactor: 'rxtx_factor',
    Swap: 'swap',
    UpdatedAt: 'updated_at',
    VcpuWeight: 'vcpu_weight',
    Vcpus: 'vcpus'
} as const;
export type FlavorsGetSortKeyEnum = typeof FlavorsGetSortKeyEnum[keyof typeof FlavorsGetSortKeyEnum];
/**
 * @export
 */
export const FlavorsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FlavorsGetSortDirEnum = typeof FlavorsGetSortDirEnum[keyof typeof FlavorsGetSortDirEnum];


/**
 * ImagesApi - axios parameter creator
 * @export
 */
export const ImagesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return a detailed index listing of images available to the request.      | param req: | wsgi.Request object. | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesDetailGet: async (name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/images/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = changesSince;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (minRam !== undefined) {
                localVarQueryParameter['minRam'] = minRam;
            }

            if (minDisk !== undefined) {
                localVarQueryParameter['minDisk'] = minDisk;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageSize !== undefined) {
                for (const [key, value] of Object.entries(pageSize)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return an index listing of images available to the request.      | param req: | wsgi.Request object | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesGet: async (name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = changesSince;
            }

            if (server !== undefined) {
                localVarQueryParameter['server'] = server;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (minRam !== undefined) {
                localVarQueryParameter['minRam'] = minRam;
            }

            if (minDisk !== undefined) {
                localVarQueryParameter['minDisk'] = minDisk;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (pageSize !== undefined) {
                for (const [key, value] of Object.entries(pageSize)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete an image, if allowed.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier (integer) |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdDelete', 'id', id)
            const localVarPath = `/v2.1/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return detailed information about a specific image.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesIdGet', 'id', id)
            const localVarPath = `/v2.1/images/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataGet: async (imageId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataGet', 'imageId', imageId)
            const localVarPath = `/v2.1/images/{image_id}/metadata`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdDelete: async (imageId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdDelete', 'imageId', imageId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdDelete', 'id', id)
            const localVarPath = `/v2.1/images/{image_id}/metadata/{id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdGet: async (imageId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdGet', 'imageId', imageId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdGet', 'id', id)
            const localVarPath = `/v2.1/images/{image_id}/metadata/{id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdate} [imagesMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdPut: async (imageId: string, id: string, imagesMetadataUpdate?: ImagesMetadataUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdPut', 'imageId', imageId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('imagesImageIdMetadataIdPut', 'id', id)
            const localVarPath = `/v2.1/images/{image_id}/metadata/{id}`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagesMetadataUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataCreate} [imagesMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataPost: async (imageId: string, imagesMetadataCreate?: ImagesMetadataCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataPost', 'imageId', imageId)
            const localVarPath = `/v2.1/images/{image_id}/metadata`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagesMetadataCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdateAll} [imagesMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataPut: async (imageId: string, imagesMetadataUpdateAll?: ImagesMetadataUpdateAll, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'imageId' is not null or undefined
            assertParamExists('imagesImageIdMetadataPut', 'imageId', imageId)
            const localVarPath = `/v2.1/images/{image_id}/metadata`
                .replace(`{${"image_id"}}`, encodeURIComponent(String(imageId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(imagesMetadataUpdateAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ImagesApi - functional programming interface
 * @export
 */
export const ImagesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ImagesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return a detailed index listing of images available to the request.      | param req: | wsgi.Request object. | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesDetailGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesDetailGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return an index listing of images available to the request.      | param req: | wsgi.Request object | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Delete an image, if allowed.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier (integer) |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return detailed information about a specific image.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataGet(imageId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataGet(imageId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataIdDelete(imageId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataIdDelete(imageId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataIdGet(imageId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataIdGet(imageId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdate} [imagesMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataIdPut(imageId: string, id: string, imagesMetadataUpdate?: ImagesMetadataUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataIdPut(imageId, id, imagesMetadataUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataCreate} [imagesMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataPost(imageId: string, imagesMetadataCreate?: ImagesMetadataCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataPost(imageId, imagesMetadataCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdateAll} [imagesMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async imagesImageIdMetadataPut(imageId: string, imagesMetadataUpdateAll?: ImagesMetadataUpdateAll, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.imagesImageIdMetadataPut(imageId, imagesMetadataUpdateAll, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ImagesApi.imagesImageIdMetadataPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ImagesApi - factory interface
 * @export
 */
export const ImagesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ImagesApiFp(configuration)
    return {
        /**
         *  Return a detailed index listing of images available to the request.      | param req: | wsgi.Request object. | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesDetailGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.imagesDetailGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return an index listing of images available to the request.      | param req: | wsgi.Request object | | --- | --- |
         * @param {string} [name] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [server] 
         * @param {string} [type] 
         * @param {string} [minRam] 
         * @param {string} [minDisk] 
         * @param {number | string} [limit] 
         * @param {number | string} [pageSize] 
         * @param {string} [marker] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.imagesGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete an image, if allowed.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier (integer) |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imagesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return detailed information about a specific image.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier |
         * @param {string} id id parameter for /v2.1/images/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.imagesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataGet(imageId: string, options?: any): AxiosPromise<any> {
            return localVarFp.imagesImageIdMetadataGet(imageId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdDelete(imageId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.imagesImageIdMetadataIdDelete(imageId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdGet(imageId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.imagesImageIdMetadataIdGet(imageId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdate} [imagesMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataIdPut(imageId: string, id: string, imagesMetadataUpdate?: ImagesMetadataUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.imagesImageIdMetadataIdPut(imageId, id, imagesMetadataUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataCreate} [imagesMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataPost(imageId: string, imagesMetadataCreate?: ImagesMetadataCreate, options?: any): AxiosPromise<any> {
            return localVarFp.imagesImageIdMetadataPost(imageId, imagesMetadataCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
         * @param {ImagesMetadataUpdateAll} [imagesMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        imagesImageIdMetadataPut(imageId: string, imagesMetadataUpdateAll?: ImagesMetadataUpdateAll, options?: any): AxiosPromise<any> {
            return localVarFp.imagesImageIdMetadataPut(imageId, imagesMetadataUpdateAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ImagesApi - object-oriented interface
 * @export
 * @class ImagesApi
 * @extends {BaseAPI}
 */
export class ImagesApi extends BaseAPI {
    /**
     *  Return a detailed index listing of images available to the request.      | param req: | wsgi.Request object. | | --- | --- |
     * @param {string} [name] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [server] 
     * @param {string} [type] 
     * @param {string} [minRam] 
     * @param {string} [minDisk] 
     * @param {number | string} [limit] 
     * @param {number | string} [pageSize] 
     * @param {string} [marker] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesDetailGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesDetailGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return an index listing of images available to the request.      | param req: | wsgi.Request object | | --- | --- |
     * @param {string} [name] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [server] 
     * @param {string} [type] 
     * @param {string} [minRam] 
     * @param {string} [minDisk] 
     * @param {number | string} [limit] 
     * @param {number | string} [pageSize] 
     * @param {string} [marker] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesGet(name?: string, status?: string, changesSince?: string, server?: string, type?: string, minRam?: string, minDisk?: string, limit?: number | string, pageSize?: number | string, marker?: string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesGet(name, status, changesSince, server, type, minRam, minDisk, limit, pageSize, marker, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete an image, if allowed.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier (integer) |
     * @param {string} id id parameter for /v2.1/images/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return detailed information about a specific image.      | param req: | wsgi.Request object | | --- | --- | | param id: | Image identifier |
     * @param {string} id id parameter for /v2.1/images/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of metadata for a given instance.
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataGet(imageId: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataGet(imageId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataIdDelete(imageId: string, id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataIdDelete(imageId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataIdGet(imageId: string, id: string, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataIdGet(imageId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {ImagesMetadataUpdate} [imagesMetadataUpdate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataIdPut(imageId: string, id: string, imagesMetadataUpdate?: ImagesMetadataUpdate, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataIdPut(imageId, id, imagesMetadataUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {ImagesMetadataCreate} [imagesMetadataCreate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataPost(imageId: string, imagesMetadataCreate?: ImagesMetadataCreate, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataPost(imageId, imagesMetadataCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} imageId image_id parameter for /v2.1/images/{image_id}/metadata/{id} API
     * @param {ImagesMetadataUpdateAll} [imagesMetadataUpdateAll] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ImagesApi
     */
    public imagesImageIdMetadataPut(imageId: string, imagesMetadataUpdateAll?: ImagesMetadataUpdateAll, options?: RawAxiosRequestConfig) {
        return ImagesApiFp(this.configuration).imagesImageIdMetadataPut(imageId, imagesMetadataUpdateAll, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LimitsApi - axios parameter creator
 * @export
 */
export const LimitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        limitsGet: async (tenantId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LimitsApi - functional programming interface
 * @export
 */
export const LimitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LimitsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async limitsGet(tenantId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LimitsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsGet(tenantId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LimitsApi - factory interface
 * @export
 */
export const LimitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LimitsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [tenantId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        limitsGet(tenantId?: string, options?: any): AxiosPromise<LimitsListResponse> {
            return localVarFp.limitsGet(tenantId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LimitsApi - object-oriented interface
 * @export
 * @class LimitsApi
 * @extends {BaseAPI}
 */
export class LimitsApi extends BaseAPI {
    /**
     * 
     * @param {string} [tenantId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsGet(tenantId?: string, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsGet(tenantId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsAgentsApi - axios parameter creator
 * @export
 */
export const OsAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAgentsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsIdPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAgentsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsAgentsApi - functional programming interface
 * @export
 */
export const OsAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osAgentsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAgentsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAgentsApi.osAgentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osAgentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAgentsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAgentsApi.osAgentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osAgentsIdPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAgentsIdPut(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAgentsApi.osAgentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osAgentsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAgentsPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAgentsApi.osAgentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsAgentsApi - factory interface
 * @export
 */
export const OsAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsAgentsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osAgentsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osAgentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-agents/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsIdPut(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osAgentsIdPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osAgentsPost(options?: any): AxiosPromise<any> {
            return localVarFp.osAgentsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsAgentsApi - object-oriented interface
 * @export
 * @class OsAgentsApi
 * @extends {BaseAPI}
 */
export class OsAgentsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsAgentsApi
     */
    public osAgentsGet(options?: RawAxiosRequestConfig) {
        return OsAgentsApiFp(this.configuration).osAgentsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-agents/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsAgentsApi
     */
    public osAgentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsAgentsApiFp(this.configuration).osAgentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-agents/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsAgentsApi
     */
    public osAgentsIdPut(id: string, options?: RawAxiosRequestConfig) {
        return OsAgentsApiFp(this.configuration).osAgentsIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsAgentsApi
     */
    public osAgentsPost(options?: RawAxiosRequestConfig) {
        return OsAgentsApiFp(this.configuration).osAgentsPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsAggregatesApi - axios parameter creator
 * @export
 */
export const OsAggregatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list a host aggregate\'s id, name, availability_zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-aggregates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/action API
         * @param {OsAggregatesIdActionPostRequest} [osAggregatesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdActionPost: async (id: string, osAggregatesIdActionPostRequest?: OsAggregatesIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAggregatesIdActionPost', 'id', id)
            const localVarPath = `/v2.1/os-aggregates/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osAggregatesIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Removes an aggregate by id.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAggregatesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-aggregates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Shows the details of an aggregate, hosts and metadata included.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAggregatesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-aggregates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Allows image cache management requests.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/images API
         * @param {OsAggregatesImagesImages} [osAggregatesImagesImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdImagesPost: async (id: string, osAggregatesImagesImages?: OsAggregatesImagesImages, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAggregatesIdImagesPost', 'id', id)
            const localVarPath = `/v2.1/os-aggregates/{id}/images`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osAggregatesImagesImages, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Updates the name and/or availability_zone of given aggregate.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {OsAggregateUpdateRequest} [osAggregateUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdPut: async (id: string, osAggregateUpdateRequest?: OsAggregateUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osAggregatesIdPut', 'id', id)
            const localVarPath = `/v2.1/os-aggregates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osAggregateUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates an aggregate, given its name and optional availability zone.
         * @param {OsAggregatesCreateRequest} [osAggregatesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesPost: async (osAggregatesCreateRequest?: OsAggregatesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-aggregates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osAggregatesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsAggregatesApi - functional programming interface
 * @export
 */
export const OsAggregatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsAggregatesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list a host aggregate\'s id, name, availability_zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAggregatesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/action API
         * @param {OsAggregatesIdActionPostRequest} [osAggregatesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesIdActionPost(id: string, osAggregatesIdActionPostRequest?: OsAggregatesIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAggregatesIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesIdActionPost(id, osAggregatesIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Removes an aggregate by id.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Shows the details of an aggregate, hosts and metadata included.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAggregateShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Allows image cache management requests.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/images API
         * @param {OsAggregatesImagesImages} [osAggregatesImagesImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesIdImagesPost(id: string, osAggregatesImagesImages?: OsAggregatesImagesImages, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesIdImagesPost(id, osAggregatesImagesImages, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesIdImagesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Updates the name and/or availability_zone of given aggregate.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {OsAggregateUpdateRequest} [osAggregateUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesIdPut(id: string, osAggregateUpdateRequest?: OsAggregateUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAggregateUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesIdPut(id, osAggregateUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates an aggregate, given its name and optional availability zone.
         * @param {OsAggregatesCreateRequest} [osAggregatesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAggregatesPost(osAggregatesCreateRequest?: OsAggregatesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAggregatesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAggregatesPost(osAggregatesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAggregatesApi.osAggregatesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsAggregatesApi - factory interface
 * @export
 */
export const OsAggregatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsAggregatesApiFp(configuration)
    return {
        /**
         *  Returns a list a host aggregate\'s id, name, availability_zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesGet(options?: any): AxiosPromise<OsAggregatesListResponse> {
            return localVarFp.osAggregatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/action API
         * @param {OsAggregatesIdActionPostRequest} [osAggregatesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdActionPost(id: string, osAggregatesIdActionPostRequest?: OsAggregatesIdActionPostRequest, options?: any): AxiosPromise<OsAggregatesIdActionPost201Response> {
            return localVarFp.osAggregatesIdActionPost(id, osAggregatesIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Removes an aggregate by id.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osAggregatesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Shows the details of an aggregate, hosts and metadata included.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdGet(id: string, options?: any): AxiosPromise<OsAggregateShowResponse> {
            return localVarFp.osAggregatesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Allows image cache management requests.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id}/images API
         * @param {OsAggregatesImagesImages} [osAggregatesImagesImages] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdImagesPost(id: string, osAggregatesImagesImages?: OsAggregatesImagesImages, options?: any): AxiosPromise<void> {
            return localVarFp.osAggregatesIdImagesPost(id, osAggregatesImagesImages, options).then((request) => request(axios, basePath));
        },
        /**
         *  Updates the name and/or availability_zone of given aggregate.
         * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
         * @param {OsAggregateUpdateRequest} [osAggregateUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesIdPut(id: string, osAggregateUpdateRequest?: OsAggregateUpdateRequest, options?: any): AxiosPromise<OsAggregateUpdateResponse> {
            return localVarFp.osAggregatesIdPut(id, osAggregateUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates an aggregate, given its name and optional availability zone.
         * @param {OsAggregatesCreateRequest} [osAggregatesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAggregatesPost(osAggregatesCreateRequest?: OsAggregatesCreateRequest, options?: any): AxiosPromise<OsAggregatesCreateResponse> {
            return localVarFp.osAggregatesPost(osAggregatesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsAggregatesApi - object-oriented interface
 * @export
 * @class OsAggregatesApi
 * @extends {BaseAPI}
 */
export class OsAggregatesApi extends BaseAPI {
    /**
     *  Returns a list a host aggregate\'s id, name, availability_zone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesGet(options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-aggregates/{id}/action API
     * @param {OsAggregatesIdActionPostRequest} [osAggregatesIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesIdActionPost(id: string, osAggregatesIdActionPostRequest?: OsAggregatesIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesIdActionPost(id, osAggregatesIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Removes an aggregate by id.
     * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Shows the details of an aggregate, hosts and metadata included.
     * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Allows image cache management requests.
     * @param {string} id id parameter for /v2.1/os-aggregates/{id}/images API
     * @param {OsAggregatesImagesImages} [osAggregatesImagesImages] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesIdImagesPost(id: string, osAggregatesImagesImages?: OsAggregatesImagesImages, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesIdImagesPost(id, osAggregatesImagesImages, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Updates the name and/or availability_zone of given aggregate.
     * @param {string} id id parameter for /v2.1/os-aggregates/{id} API
     * @param {OsAggregateUpdateRequest} [osAggregateUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesIdPut(id: string, osAggregateUpdateRequest?: OsAggregateUpdateRequest, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesIdPut(id, osAggregateUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates an aggregate, given its name and optional availability zone.
     * @param {OsAggregatesCreateRequest} [osAggregatesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAggregatesApi
     */
    public osAggregatesPost(osAggregatesCreateRequest?: OsAggregatesCreateRequest, options?: RawAxiosRequestConfig) {
        return OsAggregatesApiFp(this.configuration).osAggregatesPost(osAggregatesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsAssistedVolumeSnapshotsApi - axios parameter creator
 * @export
 */
export const OsAssistedVolumeSnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Delete a snapshot.
         * @param {string} [deleteInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAssistedVolumeSnapshotsIdDelete: async (deleteInfo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-assisted-volume-snapshots/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (deleteInfo !== undefined) {
                localVarQueryParameter['delete_info'] = deleteInfo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new snapshot.
         * @param {OsAssistedVolumeSnapshotsCreate} [osAssistedVolumeSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAssistedVolumeSnapshotsPost: async (osAssistedVolumeSnapshotsCreate?: OsAssistedVolumeSnapshotsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-assisted-volume-snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osAssistedVolumeSnapshotsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsAssistedVolumeSnapshotsApi - functional programming interface
 * @export
 */
export const OsAssistedVolumeSnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsAssistedVolumeSnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Delete a snapshot.
         * @param {string} [deleteInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAssistedVolumeSnapshotsIdDelete(deleteInfo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAssistedVolumeSnapshotsIdDelete(deleteInfo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAssistedVolumeSnapshotsApi.osAssistedVolumeSnapshotsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new snapshot.
         * @param {OsAssistedVolumeSnapshotsCreate} [osAssistedVolumeSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate?: OsAssistedVolumeSnapshotsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAssistedVolumeSnapshotsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAssistedVolumeSnapshotsApi.osAssistedVolumeSnapshotsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsAssistedVolumeSnapshotsApi - factory interface
 * @export
 */
export const OsAssistedVolumeSnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsAssistedVolumeSnapshotsApiFp(configuration)
    return {
        /**
         *  Delete a snapshot.
         * @param {string} [deleteInfo] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAssistedVolumeSnapshotsIdDelete(deleteInfo?: string, options?: any): AxiosPromise<void> {
            return localVarFp.osAssistedVolumeSnapshotsIdDelete(deleteInfo, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new snapshot.
         * @param {OsAssistedVolumeSnapshotsCreate} [osAssistedVolumeSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate?: OsAssistedVolumeSnapshotsCreate, options?: any): AxiosPromise<OsAssistedVolumeSnapshotsCreateResponse> {
            return localVarFp.osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsAssistedVolumeSnapshotsApi - object-oriented interface
 * @export
 * @class OsAssistedVolumeSnapshotsApi
 * @extends {BaseAPI}
 */
export class OsAssistedVolumeSnapshotsApi extends BaseAPI {
    /**
     *  Delete a snapshot.
     * @param {string} [deleteInfo] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAssistedVolumeSnapshotsApi
     */
    public osAssistedVolumeSnapshotsIdDelete(deleteInfo?: string, options?: RawAxiosRequestConfig) {
        return OsAssistedVolumeSnapshotsApiFp(this.configuration).osAssistedVolumeSnapshotsIdDelete(deleteInfo, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new snapshot.
     * @param {OsAssistedVolumeSnapshotsCreate} [osAssistedVolumeSnapshotsCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAssistedVolumeSnapshotsApi
     */
    public osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate?: OsAssistedVolumeSnapshotsCreate, options?: RawAxiosRequestConfig) {
        return OsAssistedVolumeSnapshotsApiFp(this.configuration).osAssistedVolumeSnapshotsPost(osAssistedVolumeSnapshotsCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsAvailabilityZoneApi - axios parameter creator
 * @export
 */
export const OsAvailabilityZoneApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a detailed list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAvailabilityZoneDetailGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-availability-zone/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a summary list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAvailabilityZoneGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-availability-zone`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsAvailabilityZoneApi - functional programming interface
 * @export
 */
export const OsAvailabilityZoneApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsAvailabilityZoneApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a detailed list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAvailabilityZoneDetailGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAvailabilityZoneDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAvailabilityZoneDetailGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAvailabilityZoneApi.osAvailabilityZoneDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a summary list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osAvailabilityZoneGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsAvailabilityZoneListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osAvailabilityZoneGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsAvailabilityZoneApi.osAvailabilityZoneGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsAvailabilityZoneApi - factory interface
 * @export
 */
export const OsAvailabilityZoneApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsAvailabilityZoneApiFp(configuration)
    return {
        /**
         *  Returns a detailed list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAvailabilityZoneDetailGet(options?: any): AxiosPromise<OsAvailabilityZoneDetailResponse> {
            return localVarFp.osAvailabilityZoneDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a summary list of availability zone.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osAvailabilityZoneGet(options?: any): AxiosPromise<OsAvailabilityZoneListResponse> {
            return localVarFp.osAvailabilityZoneGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsAvailabilityZoneApi - object-oriented interface
 * @export
 * @class OsAvailabilityZoneApi
 * @extends {BaseAPI}
 */
export class OsAvailabilityZoneApi extends BaseAPI {
    /**
     *  Returns a detailed list of availability zone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAvailabilityZoneApi
     */
    public osAvailabilityZoneDetailGet(options?: RawAxiosRequestConfig) {
        return OsAvailabilityZoneApiFp(this.configuration).osAvailabilityZoneDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a summary list of availability zone.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsAvailabilityZoneApi
     */
    public osAvailabilityZoneGet(options?: RawAxiosRequestConfig) {
        return OsAvailabilityZoneApiFp(this.configuration).osAvailabilityZoneGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsBaremetalNodesApi - axios parameter creator
 * @export
 */
export const OsBaremetalNodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-baremetal-nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id}/action API
         * @param {OsBaremetalNodesIdActionPostRequest} [osBaremetalNodesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osBaremetalNodesIdActionPost: async (id: string, osBaremetalNodesIdActionPostRequest?: OsBaremetalNodesIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osBaremetalNodesIdActionPost', 'id', id)
            const localVarPath = `/v2.1/os-baremetal-nodes/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osBaremetalNodesIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osBaremetalNodesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-baremetal-nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osBaremetalNodesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-baremetal-nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-baremetal-nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsBaremetalNodesApi - functional programming interface
 * @export
 */
export const OsBaremetalNodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsBaremetalNodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osBaremetalNodesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osBaremetalNodesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsBaremetalNodesApi.osBaremetalNodesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id}/action API
         * @param {OsBaremetalNodesIdActionPostRequest} [osBaremetalNodesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osBaremetalNodesIdActionPost(id: string, osBaremetalNodesIdActionPostRequest?: OsBaremetalNodesIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsBaremetalNodesIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osBaremetalNodesIdActionPost(id, osBaremetalNodesIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsBaremetalNodesApi.osBaremetalNodesIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osBaremetalNodesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osBaremetalNodesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsBaremetalNodesApi.osBaremetalNodesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osBaremetalNodesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osBaremetalNodesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsBaremetalNodesApi.osBaremetalNodesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osBaremetalNodesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osBaremetalNodesPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsBaremetalNodesApi.osBaremetalNodesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsBaremetalNodesApi - factory interface
 * @export
 */
export const OsBaremetalNodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsBaremetalNodesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesGet(options?: any): AxiosPromise<any> {
            return localVarFp.osBaremetalNodesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id}/action API
         * @param {OsBaremetalNodesIdActionPostRequest} [osBaremetalNodesIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osBaremetalNodesIdActionPost(id: string, osBaremetalNodesIdActionPostRequest?: OsBaremetalNodesIdActionPostRequest, options?: any): AxiosPromise<OsBaremetalNodesIdActionPost201Response> {
            return localVarFp.osBaremetalNodesIdActionPost(id, osBaremetalNodesIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osBaremetalNodesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osBaremetalNodesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osBaremetalNodesPost(options?: any): AxiosPromise<any> {
            return localVarFp.osBaremetalNodesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsBaremetalNodesApi - object-oriented interface
 * @export
 * @class OsBaremetalNodesApi
 * @extends {BaseAPI}
 */
export class OsBaremetalNodesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsBaremetalNodesApi
     */
    public osBaremetalNodesGet(options?: RawAxiosRequestConfig) {
        return OsBaremetalNodesApiFp(this.configuration).osBaremetalNodesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id}/action API
     * @param {OsBaremetalNodesIdActionPostRequest} [osBaremetalNodesIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsBaremetalNodesApi
     */
    public osBaremetalNodesIdActionPost(id: string, osBaremetalNodesIdActionPostRequest?: OsBaremetalNodesIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return OsBaremetalNodesApiFp(this.configuration).osBaremetalNodesIdActionPost(id, osBaremetalNodesIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsBaremetalNodesApi
     */
    public osBaremetalNodesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsBaremetalNodesApiFp(this.configuration).osBaremetalNodesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-baremetal-nodes/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsBaremetalNodesApi
     */
    public osBaremetalNodesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsBaremetalNodesApiFp(this.configuration).osBaremetalNodesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsBaremetalNodesApi
     */
    public osBaremetalNodesPost(options?: RawAxiosRequestConfig) {
        return OsBaremetalNodesApiFp(this.configuration).osBaremetalNodesPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsCellsApi - axios parameter creator
 * @export
 */
export const OsCellsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsCapacitiesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells/capacities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsDetailGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id}/capacities API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdCapacitiesGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCellsIdCapacitiesGet', 'id', id)
            const localVarPath = `/v2.1/os-cells/{id}/capacities`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCellsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-cells/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCellsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-cells/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCellsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-cells/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsInfoGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsSyncInstancesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cells/sync_instances`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsCellsApi - functional programming interface
 * @export
 */
export const OsCellsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsCellsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsCapacitiesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsCapacitiesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsCapacitiesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsDetailGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsDetailGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id}/capacities API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsIdCapacitiesGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsIdCapacitiesGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsIdCapacitiesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsIdPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsIdPut(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsInfoGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsInfoGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsInfoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCellsSyncInstancesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCellsSyncInstancesPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCellsApi.osCellsSyncInstancesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsCellsApi - factory interface
 * @export
 */
export const OsCellsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsCellsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsCapacitiesGet(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsCapacitiesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsDetailGet(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsDetailGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id}/capacities API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdCapacitiesGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osCellsIdCapacitiesGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osCellsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osCellsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-cells/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsIdPut(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osCellsIdPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsInfoGet(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsPost(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCellsSyncInstancesPost(options?: any): AxiosPromise<any> {
            return localVarFp.osCellsSyncInstancesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsCellsApi - object-oriented interface
 * @export
 * @class OsCellsApi
 * @extends {BaseAPI}
 */
export class OsCellsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsCapacitiesGet(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsCapacitiesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsDetailGet(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsDetailGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsGet(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-cells/{id}/capacities API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsIdCapacitiesGet(id: string, options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsIdCapacitiesGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-cells/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-cells/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-cells/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsIdPut(id: string, options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsInfoGet(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsPost(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCellsApi
     */
    public osCellsSyncInstancesPost(options?: RawAxiosRequestConfig) {
        return OsCellsApiFp(this.configuration).osCellsSyncInstancesPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsCertificatesApi - axios parameter creator
 * @export
 */
export const OsCertificatesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return certificate information.
         * @param {string} id id parameter for /v2.1/os-certificates/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCertificatesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCertificatesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-certificates/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a certificate.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCertificatesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsCertificatesApi - functional programming interface
 * @export
 */
export const OsCertificatesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsCertificatesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return certificate information.
         * @param {string} id id parameter for /v2.1/os-certificates/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCertificatesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCertificatesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCertificatesApi.osCertificatesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Create a certificate.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCertificatesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCertificatesPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCertificatesApi.osCertificatesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsCertificatesApi - factory interface
 * @export
 */
export const OsCertificatesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsCertificatesApiFp(configuration)
    return {
        /**
         *  Return certificate information.
         * @param {string} id id parameter for /v2.1/os-certificates/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCertificatesIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osCertificatesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a certificate.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCertificatesPost(options?: any): AxiosPromise<any> {
            return localVarFp.osCertificatesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsCertificatesApi - object-oriented interface
 * @export
 * @class OsCertificatesApi
 * @extends {BaseAPI}
 */
export class OsCertificatesApi extends BaseAPI {
    /**
     *  Return certificate information.
     * @param {string} id id parameter for /v2.1/os-certificates/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCertificatesApi
     */
    public osCertificatesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsCertificatesApiFp(this.configuration).osCertificatesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a certificate.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCertificatesApi
     */
    public osCertificatesPost(options?: RawAxiosRequestConfig) {
        return OsCertificatesApiFp(this.configuration).osCertificatesPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsCloudpipeApi - axios parameter creator
 * @export
 */
export const OsCloudpipeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  List running cloudpipe instances.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipeGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cloudpipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Configure cloudpipe parameters for the project.
         * @param {string} id id parameter for /v2.1/os-cloudpipe/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipeIdPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osCloudpipeIdPut', 'id', id)
            const localVarPath = `/v2.1/os-cloudpipe/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create a new cloudpipe instance, if none exists.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipePost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-cloudpipe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsCloudpipeApi - functional programming interface
 * @export
 */
export const OsCloudpipeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsCloudpipeApiAxiosParamCreator(configuration)
    return {
        /**
         *  List running cloudpipe instances.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCloudpipeGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCloudpipeGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCloudpipeApi.osCloudpipeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Configure cloudpipe parameters for the project.
         * @param {string} id id parameter for /v2.1/os-cloudpipe/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCloudpipeIdPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCloudpipeIdPut(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCloudpipeApi.osCloudpipeIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Create a new cloudpipe instance, if none exists.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osCloudpipePost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osCloudpipePost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsCloudpipeApi.osCloudpipePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsCloudpipeApi - factory interface
 * @export
 */
export const OsCloudpipeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsCloudpipeApiFp(configuration)
    return {
        /**
         *  List running cloudpipe instances.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipeGet(options?: any): AxiosPromise<any> {
            return localVarFp.osCloudpipeGet(options).then((request) => request(axios, basePath));
        },
        /**
         *  Configure cloudpipe parameters for the project.
         * @param {string} id id parameter for /v2.1/os-cloudpipe/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipeIdPut(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osCloudpipeIdPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create a new cloudpipe instance, if none exists.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osCloudpipePost(options?: any): AxiosPromise<any> {
            return localVarFp.osCloudpipePost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsCloudpipeApi - object-oriented interface
 * @export
 * @class OsCloudpipeApi
 * @extends {BaseAPI}
 */
export class OsCloudpipeApi extends BaseAPI {
    /**
     *  List running cloudpipe instances.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCloudpipeApi
     */
    public osCloudpipeGet(options?: RawAxiosRequestConfig) {
        return OsCloudpipeApiFp(this.configuration).osCloudpipeGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Configure cloudpipe parameters for the project.
     * @param {string} id id parameter for /v2.1/os-cloudpipe/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCloudpipeApi
     */
    public osCloudpipeIdPut(id: string, options?: RawAxiosRequestConfig) {
        return OsCloudpipeApiFp(this.configuration).osCloudpipeIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create a new cloudpipe instance, if none exists.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsCloudpipeApi
     */
    public osCloudpipePost(options?: RawAxiosRequestConfig) {
        return OsCloudpipeApiFp(this.configuration).osCloudpipePost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFixedIpsApi - axios parameter creator
 * @export
 */
export const OsFixedIpsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id}/action API
         * @param {OsFixedIpsIdActionPostRequest} [osFixedIpsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osFixedIpsIdActionPost: async (id: string, osFixedIpsIdActionPostRequest?: OsFixedIpsIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFixedIpsIdActionPost', 'id', id)
            const localVarPath = `/v2.1/os-fixed-ips/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFixedIpsIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFixedIpsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFixedIpsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-fixed-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFixedIpsApi - functional programming interface
 * @export
 */
export const OsFixedIpsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFixedIpsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id}/action API
         * @param {OsFixedIpsIdActionPostRequest} [osFixedIpsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osFixedIpsIdActionPost(id: string, osFixedIpsIdActionPostRequest?: OsFixedIpsIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFixedIpsIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFixedIpsIdActionPost(id, osFixedIpsIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFixedIpsApi.osFixedIpsIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFixedIpsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFixedIpsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFixedIpsApi.osFixedIpsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFixedIpsApi - factory interface
 * @export
 */
export const OsFixedIpsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFixedIpsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id}/action API
         * @param {OsFixedIpsIdActionPostRequest} [osFixedIpsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osFixedIpsIdActionPost(id: string, osFixedIpsIdActionPostRequest?: OsFixedIpsIdActionPostRequest, options?: any): AxiosPromise<OsFixedIpsIdActionPost201Response> {
            return localVarFp.osFixedIpsIdActionPost(id, osFixedIpsIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fixed-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFixedIpsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFixedIpsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFixedIpsApi - object-oriented interface
 * @export
 * @class OsFixedIpsApi
 * @extends {BaseAPI}
 */
export class OsFixedIpsApi extends BaseAPI {
    /**
     * 
     * @param {string} id id parameter for /v2.1/os-fixed-ips/{id}/action API
     * @param {OsFixedIpsIdActionPostRequest} [osFixedIpsIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsFixedIpsApi
     */
    public osFixedIpsIdActionPost(id: string, osFixedIpsIdActionPostRequest?: OsFixedIpsIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return OsFixedIpsApiFp(this.configuration).osFixedIpsIdActionPost(id, osFixedIpsIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-fixed-ips/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFixedIpsApi
     */
    public osFixedIpsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsFixedIpsApiFp(this.configuration).osFixedIpsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFloatingIpDnsApi - axios parameter creator
 * @export
 */
export const OsFloatingIpDnsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdDelete: async (domainId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdDelete', 'domainId', domainId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-floating-ip-dns/{domain_id}/entries/{id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdGet: async (domainId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdGet', 'domainId', domainId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-floating-ip-dns/{domain_id}/entries/{id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdPut: async (domainId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdPut', 'domainId', domainId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpDnsDomainIdEntriesIdPut', 'id', id)
            const localVarPath = `/v2.1/os-floating-ip-dns/{domain_id}/entries/{id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ip-dns`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpDnsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-floating-ip-dns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsIdPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpDnsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-floating-ip-dns/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFloatingIpDnsApi - functional programming interface
 * @export
 */
export const OsFloatingIpDnsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFloatingIpDnsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsDomainIdEntriesIdDelete(domainId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsDomainIdEntriesIdDelete(domainId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsDomainIdEntriesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsDomainIdEntriesIdGet(domainId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsDomainIdEntriesIdGet(domainId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsDomainIdEntriesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsDomainIdEntriesIdPut(domainId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsDomainIdEntriesIdPut(domainId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsDomainIdEntriesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpDnsIdPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpDnsIdPut(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpDnsApi.osFloatingIpDnsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFloatingIpDnsApi - factory interface
 * @export
 */
export const OsFloatingIpDnsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFloatingIpDnsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdDelete(domainId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osFloatingIpDnsDomainIdEntriesIdDelete(domainId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdGet(domainId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpDnsDomainIdEntriesIdGet(domainId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsDomainIdEntriesIdPut(domainId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpDnsDomainIdEntriesIdPut(domainId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpDnsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osFloatingIpDnsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpDnsIdPut(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpDnsIdPut(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFloatingIpDnsApi - object-oriented interface
 * @export
 * @class OsFloatingIpDnsApi
 * @extends {BaseAPI}
 */
export class OsFloatingIpDnsApi extends BaseAPI {
    /**
     * 
     * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsDomainIdEntriesIdDelete(domainId: string, id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsDomainIdEntriesIdDelete(domainId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsDomainIdEntriesIdGet(domainId: string, id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsDomainIdEntriesIdGet(domainId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} domainId domain_id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{domain_id}/entries/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsDomainIdEntriesIdPut(domainId: string, id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsDomainIdEntriesIdPut(domainId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsGet(options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-floating-ip-dns/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpDnsApi
     */
    public osFloatingIpDnsIdPut(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpDnsApiFp(this.configuration).osFloatingIpDnsIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFloatingIpPoolsApi - axios parameter creator
 * @export
 */
export const OsFloatingIpPoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return a list of pools.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpPoolsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ip-pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFloatingIpPoolsApi - functional programming interface
 * @export
 */
export const OsFloatingIpPoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFloatingIpPoolsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return a list of pools.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpPoolsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpPoolsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpPoolsApi.osFloatingIpPoolsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFloatingIpPoolsApi - factory interface
 * @export
 */
export const OsFloatingIpPoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFloatingIpPoolsApiFp(configuration)
    return {
        /**
         *  Return a list of pools.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpPoolsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpPoolsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFloatingIpPoolsApi - object-oriented interface
 * @export
 * @class OsFloatingIpPoolsApi
 * @extends {BaseAPI}
 */
export class OsFloatingIpPoolsApi extends BaseAPI {
    /**
     *  Return a list of pools.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpPoolsApi
     */
    public osFloatingIpPoolsGet(options?: RawAxiosRequestConfig) {
        return OsFloatingIpPoolsApiFp(this.configuration).osFloatingIpPoolsGet(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFloatingIpsApi - axios parameter creator
 * @export
 */
export const OsFloatingIpsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return a list of floating IPs allocated to a project.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-floating-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given floating IP.
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-floating-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFloatingIpsApi - functional programming interface
 * @export
 */
export const OsFloatingIpsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFloatingIpsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return a list of floating IPs allocated to a project.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsApi.osFloatingIpsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsApi.osFloatingIpsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given floating IP.
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsApi.osFloatingIpsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsApi.osFloatingIpsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFloatingIpsApi - factory interface
 * @export
 */
export const OsFloatingIpsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFloatingIpsApiFp(configuration)
    return {
        /**
         *  Return a list of floating IPs allocated to a project.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osFloatingIpsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given floating IP.
         * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsPost(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFloatingIpsApi - object-oriented interface
 * @export
 * @class OsFloatingIpsApi
 * @extends {BaseAPI}
 */
export class OsFloatingIpsApi extends BaseAPI {
    /**
     *  Return a list of floating IPs allocated to a project.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsApi
     */
    public osFloatingIpsGet(options?: RawAxiosRequestConfig) {
        return OsFloatingIpsApiFp(this.configuration).osFloatingIpsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsApi
     */
    public osFloatingIpsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpsApiFp(this.configuration).osFloatingIpsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given floating IP.
     * @param {string} id id parameter for /v2.1/os-floating-ips/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsApi
     */
    public osFloatingIpsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpsApiFp(this.configuration).osFloatingIpsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsApi
     */
    public osFloatingIpsPost(options?: RawAxiosRequestConfig) {
        return OsFloatingIpsApiFp(this.configuration).osFloatingIpsPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFloatingIpsBulkApi - axios parameter creator
 * @export
 */
export const OsFloatingIpsBulkApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ips-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpsBulkIdGet', 'id', id)
            const localVarPath = `/v2.1/os-floating-ips-bulk/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkIdPut: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFloatingIpsBulkIdPut', 'id', id)
            const localVarPath = `/v2.1/os-floating-ips-bulk/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-floating-ips-bulk`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFloatingIpsBulkApi - functional programming interface
 * @export
 */
export const OsFloatingIpsBulkApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFloatingIpsBulkApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsBulkGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsBulkGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsBulkApi.osFloatingIpsBulkGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsBulkIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsBulkIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsBulkApi.osFloatingIpsBulkIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsBulkIdPut(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsBulkIdPut(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsBulkApi.osFloatingIpsBulkIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFloatingIpsBulkPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFloatingIpsBulkPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFloatingIpsBulkApi.osFloatingIpsBulkPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFloatingIpsBulkApi - factory interface
 * @export
 */
export const OsFloatingIpsBulkApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFloatingIpsBulkApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkGet(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsBulkGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsBulkIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkIdPut(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsBulkIdPut(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFloatingIpsBulkPost(options?: any): AxiosPromise<any> {
            return localVarFp.osFloatingIpsBulkPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFloatingIpsBulkApi - object-oriented interface
 * @export
 * @class OsFloatingIpsBulkApi
 * @extends {BaseAPI}
 */
export class OsFloatingIpsBulkApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsBulkApi
     */
    public osFloatingIpsBulkGet(options?: RawAxiosRequestConfig) {
        return OsFloatingIpsBulkApiFp(this.configuration).osFloatingIpsBulkGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsBulkApi
     */
    public osFloatingIpsBulkIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpsBulkApiFp(this.configuration).osFloatingIpsBulkIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-floating-ips-bulk/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsBulkApi
     */
    public osFloatingIpsBulkIdPut(id: string, options?: RawAxiosRequestConfig) {
        return OsFloatingIpsBulkApiFp(this.configuration).osFloatingIpsBulkIdPut(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFloatingIpsBulkApi
     */
    public osFloatingIpsBulkPost(options?: RawAxiosRequestConfig) {
        return OsFloatingIpsBulkApiFp(this.configuration).osFloatingIpsBulkPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsFpingApi - axios parameter creator
 * @export
 */
export const OsFpingApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFpingGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-fping`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fping/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFpingIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osFpingIdGet', 'id', id)
            const localVarPath = `/v2.1/os-fping/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsFpingApi - functional programming interface
 * @export
 */
export const OsFpingApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsFpingApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFpingGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFpingGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFpingApi.osFpingGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fping/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osFpingIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osFpingIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsFpingApi.osFpingIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsFpingApi - factory interface
 * @export
 */
export const OsFpingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsFpingApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFpingGet(options?: any): AxiosPromise<any> {
            return localVarFp.osFpingGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-fping/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osFpingIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osFpingIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsFpingApi - object-oriented interface
 * @export
 * @class OsFpingApi
 * @extends {BaseAPI}
 */
export class OsFpingApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFpingApi
     */
    public osFpingGet(options?: RawAxiosRequestConfig) {
        return OsFpingApiFp(this.configuration).osFpingGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-fping/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsFpingApi
     */
    public osFpingIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsFpingApiFp(this.configuration).osFpingIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsHostsApi - axios parameter creator
 * @export
 */
export const OsHostsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a dict in the format    {\'hosts\': \\[{\'host_name\': \'some.host.name\',   \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.other.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.celly.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'compute1\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'compute2\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'sched1\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'sched2\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'vol1\\.host.com\',  \'service\': \'volume\', \'zone\': \'internal\'}]}
         * @param {string} [zone] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsGet: async (zone?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-hosts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (zone !== undefined) {
                localVarQueryParameter['zone'] = zone;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Shows the physical/usage resource given by hosts.      | param id: | hostname | | --- | --- | | returns: | expected to use HostShowTemplate. ex.:  ```  {\'host\': {\'resource\':D},..} D: {\'host\': \'hostname\',\'project\': \'admin\',     \'cpu\': 1, \'memory_mb\': 2048, \'disk_gb\': 30}  ``` |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHostsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-hosts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return booleanized version of body dict.      | param Request req: | | | --- | --- | |  | The request object (containing \'nova\\-context\' env var). | | param str id: | The host name. | | param dict body: | | |  | example format {\'host\': {\'status\': \'enable\', \'maintenance_mode\': \'enable\'}} | | return: | Same dict as body but \'enable\' strings for \'status\' and \'maintenance_mode\' are converted into True, else False. | | rtype: | dict |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {OsHostUpdate} [osHostUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdPut: async (id: string, osHostUpdate?: OsHostUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHostsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-hosts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osHostUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/reboot API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdRebootGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHostsIdRebootGet', 'id', id)
            const localVarPath = `/v2.1/os-hosts/{id}/reboot`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/shutdown API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdShutdownGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHostsIdShutdownGet', 'id', id)
            const localVarPath = `/v2.1/os-hosts/{id}/shutdown`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/startup API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdStartupGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHostsIdStartupGet', 'id', id)
            const localVarPath = `/v2.1/os-hosts/{id}/startup`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsHostsApi - functional programming interface
 * @export
 */
export const OsHostsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsHostsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a dict in the format    {\'hosts\': \\[{\'host_name\': \'some.host.name\',   \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.other.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.celly.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'compute1\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'compute2\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'sched1\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'sched2\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'vol1\\.host.com\',  \'service\': \'volume\', \'zone\': \'internal\'}]}
         * @param {string} [zone] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsGet(zone?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsGet(zone, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Shows the physical/usage resource given by hosts.      | param id: | hostname | | --- | --- | | returns: | expected to use HostShowTemplate. ex.:  ```  {\'host\': {\'resource\':D},..} D: {\'host\': \'hostname\',\'project\': \'admin\',     \'cpu\': 1, \'memory_mb\': 2048, \'disk_gb\': 30}  ``` |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return booleanized version of body dict.      | param Request req: | | | --- | --- | |  | The request object (containing \'nova\\-context\' env var). | | param str id: | The host name. | | param dict body: | | |  | example format {\'host\': {\'status\': \'enable\', \'maintenance_mode\': \'enable\'}} | | return: | Same dict as body but \'enable\' strings for \'status\' and \'maintenance_mode\' are converted into True, else False. | | rtype: | dict |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {OsHostUpdate} [osHostUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsIdPut(id: string, osHostUpdate?: OsHostUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsIdPut(id, osHostUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/reboot API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsIdRebootGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsIdRebootGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsIdRebootGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/shutdown API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsIdShutdownGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsIdShutdownGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsIdShutdownGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/startup API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHostsIdStartupGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHostsIdStartupGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHostsApi.osHostsIdStartupGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsHostsApi - factory interface
 * @export
 */
export const OsHostsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsHostsApiFp(configuration)
    return {
        /**
         *  Returns a dict in the format    {\'hosts\': \\[{\'host_name\': \'some.host.name\',   \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.other.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.celly.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'compute1\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'compute2\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'sched1\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'sched2\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'vol1\\.host.com\',  \'service\': \'volume\', \'zone\': \'internal\'}]}
         * @param {string} [zone] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsGet(zone?: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsGet(zone, options).then((request) => request(axios, basePath));
        },
        /**
         *  Shows the physical/usage resource given by hosts.      | param id: | hostname | | --- | --- | | returns: | expected to use HostShowTemplate. ex.:  ```  {\'host\': {\'resource\':D},..} D: {\'host\': \'hostname\',\'project\': \'admin\',     \'cpu\': 1, \'memory_mb\': 2048, \'disk_gb\': 30}  ``` |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return booleanized version of body dict.      | param Request req: | | | --- | --- | |  | The request object (containing \'nova\\-context\' env var). | | param str id: | The host name. | | param dict body: | | |  | example format {\'host\': {\'status\': \'enable\', \'maintenance_mode\': \'enable\'}} | | return: | Same dict as body but \'enable\' strings for \'status\' and \'maintenance_mode\' are converted into True, else False. | | rtype: | dict |
         * @param {string} id id parameter for /v2.1/os-hosts/{id} API
         * @param {OsHostUpdate} [osHostUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdPut(id: string, osHostUpdate?: OsHostUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsIdPut(id, osHostUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/reboot API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdRebootGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsIdRebootGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/shutdown API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdShutdownGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsIdShutdownGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-hosts/{id}/startup API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHostsIdStartupGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHostsIdStartupGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsHostsApi - object-oriented interface
 * @export
 * @class OsHostsApi
 * @extends {BaseAPI}
 */
export class OsHostsApi extends BaseAPI {
    /**
     *  Returns a dict in the format    {\'hosts\': \\[{\'host_name\': \'some.host.name\',   \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.other.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'some.celly.host.name\',  \'service\': \'cells\', \'zone\': \'internal\'},  {\'host_name\': \'compute1\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'compute2\\.host.com\',  \'service\': \'compute\', \'zone\': \'nova\'},  {\'host_name\': \'sched1\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'sched2\\.host.com\',  \'service\': \'scheduler\', \'zone\': \'internal\'},  {\'host_name\': \'vol1\\.host.com\',  \'service\': \'volume\', \'zone\': \'internal\'}]}
     * @param {string} [zone] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsGet(zone?: string, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsGet(zone, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Shows the physical/usage resource given by hosts.      | param id: | hostname | | --- | --- | | returns: | expected to use HostShowTemplate. ex.:  ```  {\'host\': {\'resource\':D},..} D: {\'host\': \'hostname\',\'project\': \'admin\',     \'cpu\': 1, \'memory_mb\': 2048, \'disk_gb\': 30}  ``` |
     * @param {string} id id parameter for /v2.1/os-hosts/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return booleanized version of body dict.      | param Request req: | | | --- | --- | |  | The request object (containing \'nova\\-context\' env var). | | param str id: | The host name. | | param dict body: | | |  | example format {\'host\': {\'status\': \'enable\', \'maintenance_mode\': \'enable\'}} | | return: | Same dict as body but \'enable\' strings for \'status\' and \'maintenance_mode\' are converted into True, else False. | | rtype: | dict |
     * @param {string} id id parameter for /v2.1/os-hosts/{id} API
     * @param {OsHostUpdate} [osHostUpdate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsIdPut(id: string, osHostUpdate?: OsHostUpdate, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsIdPut(id, osHostUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-hosts/{id}/reboot API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsIdRebootGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsIdRebootGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-hosts/{id}/shutdown API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsIdShutdownGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsIdShutdownGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-hosts/{id}/startup API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHostsApi
     */
    public osHostsIdStartupGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHostsApiFp(this.configuration).osHostsIdStartupGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsHypervisorsApi - axios parameter creator
 * @export
 */
export const OsHypervisorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsDetailGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsDetailGet: async (limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsDetailGetWithServersEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-hypervisors/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (hypervisorHostnamePattern !== undefined) {
                localVarQueryParameter['hypervisor_hostname_pattern'] = hypervisorHostnamePattern;
            }

            if (withServers !== undefined) {
                localVarQueryParameter['with_servers'] = withServers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsGet: async (limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsGetWithServersEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-hypervisors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (hypervisorHostnamePattern !== undefined) {
                localVarQueryParameter['hypervisor_hostname_pattern'] = hypervisorHostnamePattern;
            }

            if (withServers !== undefined) {
                localVarQueryParameter['with_servers'] = withServers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  The 2\\.53 microversion requires that the id is a uuid and as a result it can also return a 400 response if an invalid uuid is passed.   The 2\\.53 microversion also supports the with_servers query parameter to include a list of servers on the given hypervisor if requested.
         * @param {OsHypervisorsIdGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdGet: async (withServers?: OsHypervisorsIdGetWithServersEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-hypervisors/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (withServers !== undefined) {
                localVarQueryParameter['with_servers'] = withServers;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern on a dedicated route. Starting with 2\\.53, searching by a hostname pattern is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/search API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdSearchGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHypervisorsIdSearchGet', 'id', id)
            const localVarPath = `/v2.1/os-hypervisors/{id}/search`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern and include servers on those hosts in the response on a dedicated route. Starting with 2\\.53, searching by a hostname pattern and including hosted servers is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/servers API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdServersGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHypervisorsIdServersGet', 'id', id)
            const localVarPath = `/v2.1/os-hypervisors/{id}/servers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Prior to microversion 2\\.88, you could retrieve a special version of the hypervisor detail view that included uptime. Starting in 2\\.88, this field is now included in the standard detail view, making this API unnecessary.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/uptime API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdUptimeGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osHypervisorsIdUptimeGet', 'id', id)
            const localVarPath = `/v2.1/os-hypervisors/{id}/uptime`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Prior to microversion 2\\.88, you could get statistics for the hypervisor. Most of these are now accessible from placement and the few that aren\'t as misleading and frequently misunderstood.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsStatisticsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-hypervisors/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsHypervisorsApi - functional programming interface
 * @export
 */
export const OsHypervisorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsHypervisorsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsDetailGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsDetailGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsDetailGetWithServersEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsHypervisorsDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsDetailGet(limit, marker, hypervisorHostnamePattern, withServers, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsGetWithServersEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsHypervisorsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsGet(limit, marker, hypervisorHostnamePattern, withServers, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  The 2\\.53 microversion requires that the id is a uuid and as a result it can also return a 400 response if an invalid uuid is passed.   The 2\\.53 microversion also supports the with_servers query parameter to include a list of servers on the given hypervisor if requested.
         * @param {OsHypervisorsIdGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsIdGet(withServers?: OsHypervisorsIdGetWithServersEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsHypervisorShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsIdGet(withServers, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern on a dedicated route. Starting with 2\\.53, searching by a hostname pattern is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/search API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsIdSearchGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsIdSearchGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsIdSearchGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern and include servers on those hosts in the response on a dedicated route. Starting with 2\\.53, searching by a hostname pattern and including hosted servers is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/servers API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsIdServersGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsIdServersGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsIdServersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Prior to microversion 2\\.88, you could retrieve a special version of the hypervisor detail view that included uptime. Starting in 2\\.88, this field is now included in the standard detail view, making this API unnecessary.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/uptime API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsIdUptimeGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsIdUptimeGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsIdUptimeGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Prior to microversion 2\\.88, you could get statistics for the hypervisor. Most of these are now accessible from placement and the few that aren\'t as misleading and frequently misunderstood.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osHypervisorsStatisticsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osHypervisorsStatisticsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsHypervisorsApi.osHypervisorsStatisticsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsHypervisorsApi - factory interface
 * @export
 */
export const OsHypervisorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsHypervisorsApiFp(configuration)
    return {
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsDetailGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsDetailGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsDetailGetWithServersEnum, options?: any): AxiosPromise<OsHypervisorsDetailResponse> {
            return localVarFp.osHypervisorsDetailGet(limit, marker, hypervisorHostnamePattern, withServers, options).then((request) => request(axios, basePath));
        },
        /**
         *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [hypervisorHostnamePattern] 
         * @param {OsHypervisorsGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsGetWithServersEnum, options?: any): AxiosPromise<OsHypervisorsListResponse> {
            return localVarFp.osHypervisorsGet(limit, marker, hypervisorHostnamePattern, withServers, options).then((request) => request(axios, basePath));
        },
        /**
         *  The 2\\.53 microversion requires that the id is a uuid and as a result it can also return a 400 response if an invalid uuid is passed.   The 2\\.53 microversion also supports the with_servers query parameter to include a list of servers on the given hypervisor if requested.
         * @param {OsHypervisorsIdGetWithServersEnum} [withServers] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdGet(withServers?: OsHypervisorsIdGetWithServersEnum, options?: any): AxiosPromise<OsHypervisorShowResponse> {
            return localVarFp.osHypervisorsIdGet(withServers, options).then((request) => request(axios, basePath));
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern on a dedicated route. Starting with 2\\.53, searching by a hostname pattern is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/search API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdSearchGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHypervisorsIdSearchGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern and include servers on those hosts in the response on a dedicated route. Starting with 2\\.53, searching by a hostname pattern and including hosted servers is a query parameter in the GET /os\\-hypervisors index and detail methods.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/servers API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdServersGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHypervisorsIdServersGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Prior to microversion 2\\.88, you could retrieve a special version of the hypervisor detail view that included uptime. Starting in 2\\.88, this field is now included in the standard detail view, making this API unnecessary.
         * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/uptime API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsIdUptimeGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osHypervisorsIdUptimeGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Prior to microversion 2\\.88, you could get statistics for the hypervisor. Most of these are now accessible from placement and the few that aren\'t as misleading and frequently misunderstood.
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osHypervisorsStatisticsGet(options?: any): AxiosPromise<any> {
            return localVarFp.osHypervisorsStatisticsGet(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsHypervisorsApi - object-oriented interface
 * @export
 * @class OsHypervisorsApi
 * @extends {BaseAPI}
 */
export class OsHypervisorsApi extends BaseAPI {
    /**
     *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [hypervisorHostnamePattern] 
     * @param {OsHypervisorsDetailGetWithServersEnum} [withServers] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsDetailGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsDetailGetWithServersEnum, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsDetailGet(limit, marker, hypervisorHostnamePattern, withServers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Starting with the 2\\.53 microversion, the id field in the response is the compute_nodes.uuid value. Also, the search and servers routes are superseded and replaced with query parameters for listing hypervisors by a hostname pattern and whether or not to include hosted servers in the response.
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [hypervisorHostnamePattern] 
     * @param {OsHypervisorsGetWithServersEnum} [withServers] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsGet(limit?: number | string, marker?: string, hypervisorHostnamePattern?: string, withServers?: OsHypervisorsGetWithServersEnum, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsGet(limit, marker, hypervisorHostnamePattern, withServers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  The 2\\.53 microversion requires that the id is a uuid and as a result it can also return a 400 response if an invalid uuid is passed.   The 2\\.53 microversion also supports the with_servers query parameter to include a list of servers on the given hypervisor if requested.
     * @param {OsHypervisorsIdGetWithServersEnum} [withServers] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsIdGet(withServers?: OsHypervisorsIdGetWithServersEnum, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsIdGet(withServers, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern on a dedicated route. Starting with 2\\.53, searching by a hostname pattern is a query parameter in the GET /os\\-hypervisors index and detail methods.
     * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/search API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsIdSearchGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsIdSearchGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Prior to microversion 2\\.53 you could search for hypervisors by a hostname pattern and include servers on those hosts in the response on a dedicated route. Starting with 2\\.53, searching by a hostname pattern and including hosted servers is a query parameter in the GET /os\\-hypervisors index and detail methods.
     * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/servers API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsIdServersGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsIdServersGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Prior to microversion 2\\.88, you could retrieve a special version of the hypervisor detail view that included uptime. Starting in 2\\.88, this field is now included in the standard detail view, making this API unnecessary.
     * @param {string} id id parameter for /v2.1/os-hypervisors/{id}/uptime API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsIdUptimeGet(id: string, options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsIdUptimeGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Prior to microversion 2\\.88, you could get statistics for the hypervisor. Most of these are now accessible from placement and the few that aren\'t as misleading and frequently misunderstood.
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsHypervisorsApi
     */
    public osHypervisorsStatisticsGet(options?: RawAxiosRequestConfig) {
        return OsHypervisorsApiFp(this.configuration).osHypervisorsStatisticsGet(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OsHypervisorsDetailGetWithServersEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;
export type OsHypervisorsDetailGetWithServersEnum = typeof OsHypervisorsDetailGetWithServersEnum[keyof typeof OsHypervisorsDetailGetWithServersEnum];
/**
 * @export
 */
export const OsHypervisorsGetWithServersEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;
export type OsHypervisorsGetWithServersEnum = typeof OsHypervisorsGetWithServersEnum[keyof typeof OsHypervisorsGetWithServersEnum];
/**
 * @export
 */
export const OsHypervisorsIdGetWithServersEnum = {
    True: 'true',
    True2: 'True',
    True3: 'TRUE',
    True4: 'true',
    _1: '1',
    True5: 'true',
    True6: 'true',
    True7: 'true',
    True8: 'true',
    True9: 'true',
    True10: 'true',
    False: 'false',
    False2: 'False',
    False3: 'FALSE',
    False4: 'false',
    _0: '0',
    False5: 'false',
    False6: 'false',
    False7: 'false',
    False8: 'false',
    False9: 'false',
    False10: 'false'
} as const;
export type OsHypervisorsIdGetWithServersEnum = typeof OsHypervisorsIdGetWithServersEnum[keyof typeof OsHypervisorsIdGetWithServersEnum];


/**
 * OsInstanceUsageAuditLogApi - axios parameter creator
 * @export
 */
export const OsInstanceUsageAuditLogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osInstanceUsageAuditLogGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-instance_usage_audit_log`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id Filters the response by the date and time before which to list usage audits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osInstanceUsageAuditLogIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osInstanceUsageAuditLogIdGet', 'id', id)
            const localVarPath = `/v2.1/os-instance_usage_audit_log/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsInstanceUsageAuditLogApi - functional programming interface
 * @export
 */
export const OsInstanceUsageAuditLogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsInstanceUsageAuditLogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osInstanceUsageAuditLogGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsInstanceUsageAuditLogListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osInstanceUsageAuditLogGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsInstanceUsageAuditLogApi.osInstanceUsageAuditLogGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id Filters the response by the date and time before which to list usage audits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osInstanceUsageAuditLogIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsInstanceUsageAuditLogShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osInstanceUsageAuditLogIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsInstanceUsageAuditLogApi.osInstanceUsageAuditLogIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsInstanceUsageAuditLogApi - factory interface
 * @export
 */
export const OsInstanceUsageAuditLogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsInstanceUsageAuditLogApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osInstanceUsageAuditLogGet(options?: any): AxiosPromise<OsInstanceUsageAuditLogListResponse> {
            return localVarFp.osInstanceUsageAuditLogGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id Filters the response by the date and time before which to list usage audits.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osInstanceUsageAuditLogIdGet(id: string, options?: any): AxiosPromise<OsInstanceUsageAuditLogShowResponse> {
            return localVarFp.osInstanceUsageAuditLogIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsInstanceUsageAuditLogApi - object-oriented interface
 * @export
 * @class OsInstanceUsageAuditLogApi
 * @extends {BaseAPI}
 */
export class OsInstanceUsageAuditLogApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsInstanceUsageAuditLogApi
     */
    public osInstanceUsageAuditLogGet(options?: RawAxiosRequestConfig) {
        return OsInstanceUsageAuditLogApiFp(this.configuration).osInstanceUsageAuditLogGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id Filters the response by the date and time before which to list usage audits.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsInstanceUsageAuditLogApi
     */
    public osInstanceUsageAuditLogIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsInstanceUsageAuditLogApiFp(this.configuration).osInstanceUsageAuditLogIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsKeypairsApi - axios parameter creator
 * @export
 */
export const OsKeypairsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsGet: async (userId?: string, limit?: number | string, marker?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsIdDelete: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-keypairs/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsIdGet: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-keypairs/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Create or import keypair.   Sending name will generate a key and return private_key and fingerprint.   You can send a public_key to add an existing ssh key.    params: keypair object with: name (required) \\- string public_key (optional) \\- string
         * @param {OsKeypairsCreateRequest} [osKeypairsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsPost: async (osKeypairsCreateRequest?: OsKeypairsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-keypairs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osKeypairsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsKeypairsApi - functional programming interface
 * @export
 */
export const OsKeypairsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsKeypairsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osKeypairsGet(userId?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsKeypairsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osKeypairsGet(userId, limit, marker, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsKeypairsApi.osKeypairsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osKeypairsIdDelete(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osKeypairsIdDelete(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsKeypairsApi.osKeypairsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osKeypairsIdGet(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsKeypairShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osKeypairsIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsKeypairsApi.osKeypairsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Create or import keypair.   Sending name will generate a key and return private_key and fingerprint.   You can send a public_key to add an existing ssh key.    params: keypair object with: name (required) \\- string public_key (optional) \\- string
         * @param {OsKeypairsCreateRequest} [osKeypairsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osKeypairsPost(osKeypairsCreateRequest?: OsKeypairsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsKeypairsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osKeypairsPost(osKeypairsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsKeypairsApi.osKeypairsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsKeypairsApi - factory interface
 * @export
 */
export const OsKeypairsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsKeypairsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [userId] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsGet(userId?: string, limit?: number | string, marker?: string, options?: any): AxiosPromise<OsKeypairsListResponse> {
            return localVarFp.osKeypairsGet(userId, limit, marker, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsIdDelete(userId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.osKeypairsIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsIdGet(userId?: string, options?: any): AxiosPromise<OsKeypairShowResponse> {
            return localVarFp.osKeypairsIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Create or import keypair.   Sending name will generate a key and return private_key and fingerprint.   You can send a public_key to add an existing ssh key.    params: keypair object with: name (required) \\- string public_key (optional) \\- string
         * @param {OsKeypairsCreateRequest} [osKeypairsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osKeypairsPost(osKeypairsCreateRequest?: OsKeypairsCreateRequest, options?: any): AxiosPromise<OsKeypairsCreateResponse> {
            return localVarFp.osKeypairsPost(osKeypairsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsKeypairsApi - object-oriented interface
 * @export
 * @class OsKeypairsApi
 * @extends {BaseAPI}
 */
export class OsKeypairsApi extends BaseAPI {
    /**
     * 
     * @param {string} [userId] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsKeypairsApi
     */
    public osKeypairsGet(userId?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig) {
        return OsKeypairsApiFp(this.configuration).osKeypairsGet(userId, limit, marker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsKeypairsApi
     */
    public osKeypairsIdDelete(userId?: string, options?: RawAxiosRequestConfig) {
        return OsKeypairsApiFp(this.configuration).osKeypairsIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsKeypairsApi
     */
    public osKeypairsIdGet(userId?: string, options?: RawAxiosRequestConfig) {
        return OsKeypairsApiFp(this.configuration).osKeypairsIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Create or import keypair.   Sending name will generate a key and return private_key and fingerprint.   You can send a public_key to add an existing ssh key.    params: keypair object with: name (required) \\- string public_key (optional) \\- string
     * @param {OsKeypairsCreateRequest} [osKeypairsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsKeypairsApi
     */
    public osKeypairsPost(osKeypairsCreateRequest?: OsKeypairsCreateRequest, options?: RawAxiosRequestConfig) {
        return OsKeypairsApiFp(this.configuration).osKeypairsPost(osKeypairsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsMigrationsApi - axios parameter creator
 * @export
 */
export const OsMigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return all migrations using the query parameters as filters.
         * @param {string} [hidden] 
         * @param {string} [host] 
         * @param {string} [instanceUuid] 
         * @param {string} [sourceCompute] 
         * @param {string} [status] 
         * @param {string} [migrationType] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osMigrationsGet: async (hidden?: string, host?: string, instanceUuid?: string, sourceCompute?: string, status?: string, migrationType?: string, limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, userId?: string, projectId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-migrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (hidden !== undefined) {
                localVarQueryParameter['hidden'] = hidden;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (instanceUuid !== undefined) {
                localVarQueryParameter['instance_uuid'] = instanceUuid;
            }

            if (sourceCompute !== undefined) {
                localVarQueryParameter['source_compute'] = sourceCompute;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (migrationType !== undefined) {
                localVarQueryParameter['migration_type'] = migrationType;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsMigrationsApi - functional programming interface
 * @export
 */
export const OsMigrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsMigrationsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return all migrations using the query parameters as filters.
         * @param {string} [hidden] 
         * @param {string} [host] 
         * @param {string} [instanceUuid] 
         * @param {string} [sourceCompute] 
         * @param {string} [status] 
         * @param {string} [migrationType] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osMigrationsGet(hidden?: string, host?: string, instanceUuid?: string, sourceCompute?: string, status?: string, migrationType?: string, limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, userId?: string, projectId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsMigrationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osMigrationsGet(hidden, host, instanceUuid, sourceCompute, status, migrationType, limit, marker, changesSince, changesBefore, userId, projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsMigrationsApi.osMigrationsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsMigrationsApi - factory interface
 * @export
 */
export const OsMigrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsMigrationsApiFp(configuration)
    return {
        /**
         *  Return all migrations using the query parameters as filters.
         * @param {string} [hidden] 
         * @param {string} [host] 
         * @param {string} [instanceUuid] 
         * @param {string} [sourceCompute] 
         * @param {string} [status] 
         * @param {string} [migrationType] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osMigrationsGet(hidden?: string, host?: string, instanceUuid?: string, sourceCompute?: string, status?: string, migrationType?: string, limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, userId?: string, projectId?: string, options?: any): AxiosPromise<OsMigrationsListResponse> {
            return localVarFp.osMigrationsGet(hidden, host, instanceUuid, sourceCompute, status, migrationType, limit, marker, changesSince, changesBefore, userId, projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsMigrationsApi - object-oriented interface
 * @export
 * @class OsMigrationsApi
 * @extends {BaseAPI}
 */
export class OsMigrationsApi extends BaseAPI {
    /**
     *  Return all migrations using the query parameters as filters.
     * @param {string} [hidden] 
     * @param {string} [host] 
     * @param {string} [instanceUuid] 
     * @param {string} [sourceCompute] 
     * @param {string} [status] 
     * @param {string} [migrationType] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [changesSince] 
     * @param {string} [changesBefore] 
     * @param {string} [userId] 
     * @param {string} [projectId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsMigrationsApi
     */
    public osMigrationsGet(hidden?: string, host?: string, instanceUuid?: string, sourceCompute?: string, status?: string, migrationType?: string, limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, userId?: string, projectId?: string, options?: RawAxiosRequestConfig) {
        return OsMigrationsApiFp(this.configuration).osMigrationsGet(hidden, host, instanceUuid, sourceCompute, status, migrationType, limit, marker, changesSince, changesBefore, userId, projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsNetworksApi - axios parameter creator
 * @export
 */
export const OsNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksAddPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-networks/add`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id}/action API
         * @param {OsNetworksIdActionPostRequest} [osNetworksIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osNetworksIdActionPost: async (id: string, osNetworksIdActionPostRequest?: OsNetworksIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osNetworksIdActionPost', 'id', id)
            const localVarPath = `/v2.1/os-networks/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osNetworksIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osNetworksIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-networks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osNetworksIdGet', 'id', id)
            const localVarPath = `/v2.1/os-networks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsNetworksApi - functional programming interface
 * @export
 */
export const OsNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osNetworksAddPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksAddPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksAddPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osNetworksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id}/action API
         * @param {OsNetworksIdActionPostRequest} [osNetworksIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osNetworksIdActionPost(id: string, osNetworksIdActionPostRequest?: OsNetworksIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsNetworksIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksIdActionPost(id, osNetworksIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osNetworksIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osNetworksIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osNetworksPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osNetworksPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsNetworksApi.osNetworksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsNetworksApi - factory interface
 * @export
 */
export const OsNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsNetworksApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksAddPost(options?: any): AxiosPromise<any> {
            return localVarFp.osNetworksAddPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksGet(options?: any): AxiosPromise<any> {
            return localVarFp.osNetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id}/action API
         * @param {OsNetworksIdActionPostRequest} [osNetworksIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osNetworksIdActionPost(id: string, osNetworksIdActionPostRequest?: OsNetworksIdActionPostRequest, options?: any): AxiosPromise<OsNetworksIdActionPost201Response> {
            return localVarFp.osNetworksIdActionPost(id, osNetworksIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osNetworksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osNetworksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osNetworksPost(options?: any): AxiosPromise<any> {
            return localVarFp.osNetworksPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsNetworksApi - object-oriented interface
 * @export
 * @class OsNetworksApi
 * @extends {BaseAPI}
 */
export class OsNetworksApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksAddPost(options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksAddPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksGet(options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-networks/{id}/action API
     * @param {OsNetworksIdActionPostRequest} [osNetworksIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksIdActionPost(id: string, osNetworksIdActionPostRequest?: OsNetworksIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksIdActionPost(id, osNetworksIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-networks/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-networks/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsNetworksApi
     */
    public osNetworksPost(options?: RawAxiosRequestConfig) {
        return OsNetworksApiFp(this.configuration).osNetworksPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsSecurityGroupDefaultRulesApi - axios parameter creator
 * @export
 */
export const OsSecurityGroupDefaultRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-security-group-default-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupDefaultRulesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-security-group-default-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupDefaultRulesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-security-group-default-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-security-group-default-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsSecurityGroupDefaultRulesApi - functional programming interface
 * @export
 */
export const OsSecurityGroupDefaultRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsSecurityGroupDefaultRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupDefaultRulesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupDefaultRulesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupDefaultRulesApi.osSecurityGroupDefaultRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupDefaultRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupDefaultRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupDefaultRulesApi.osSecurityGroupDefaultRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupDefaultRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupDefaultRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupDefaultRulesApi.osSecurityGroupDefaultRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupDefaultRulesPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupDefaultRulesPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupDefaultRulesApi.osSecurityGroupDefaultRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsSecurityGroupDefaultRulesApi - factory interface
 * @export
 */
export const OsSecurityGroupDefaultRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsSecurityGroupDefaultRulesApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesGet(options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupDefaultRulesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osSecurityGroupDefaultRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupDefaultRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupDefaultRulesPost(options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupDefaultRulesPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsSecurityGroupDefaultRulesApi - object-oriented interface
 * @export
 * @class OsSecurityGroupDefaultRulesApi
 * @extends {BaseAPI}
 */
export class OsSecurityGroupDefaultRulesApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupDefaultRulesApi
     */
    public osSecurityGroupDefaultRulesGet(options?: RawAxiosRequestConfig) {
        return OsSecurityGroupDefaultRulesApiFp(this.configuration).osSecurityGroupDefaultRulesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupDefaultRulesApi
     */
    public osSecurityGroupDefaultRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupDefaultRulesApiFp(this.configuration).osSecurityGroupDefaultRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-security-group-default-rules/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupDefaultRulesApi
     */
    public osSecurityGroupDefaultRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupDefaultRulesApiFp(this.configuration).osSecurityGroupDefaultRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupDefaultRulesApi
     */
    public osSecurityGroupDefaultRulesPost(options?: RawAxiosRequestConfig) {
        return OsSecurityGroupDefaultRulesApiFp(this.configuration).osSecurityGroupDefaultRulesPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsSecurityGroupRulesApi - axios parameter creator
 * @export
 */
export const OsSecurityGroupRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupRulesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {OsSecurityGroupRulesCreate} [osSecurityGroupRulesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupRulesPost: async (osSecurityGroupRulesCreate?: OsSecurityGroupRulesCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-security-group-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osSecurityGroupRulesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsSecurityGroupRulesApi - functional programming interface
 * @export
 */
export const OsSecurityGroupRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsSecurityGroupRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupRulesApi.osSecurityGroupRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {OsSecurityGroupRulesCreate} [osSecurityGroupRulesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupRulesPost(osSecurityGroupRulesCreate?: OsSecurityGroupRulesCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupRulesPost(osSecurityGroupRulesCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupRulesApi.osSecurityGroupRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsSecurityGroupRulesApi - factory interface
 * @export
 */
export const OsSecurityGroupRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsSecurityGroupRulesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osSecurityGroupRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {OsSecurityGroupRulesCreate} [osSecurityGroupRulesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupRulesPost(osSecurityGroupRulesCreate?: OsSecurityGroupRulesCreate, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupRulesPost(osSecurityGroupRulesCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsSecurityGroupRulesApi - object-oriented interface
 * @export
 * @class OsSecurityGroupRulesApi
 * @extends {BaseAPI}
 */
export class OsSecurityGroupRulesApi extends BaseAPI {
    /**
     * 
     * @param {string} id id parameter for /v2.1/os-security-group-rules/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupRulesApi
     */
    public osSecurityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupRulesApiFp(this.configuration).osSecurityGroupRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {OsSecurityGroupRulesCreate} [osSecurityGroupRulesCreate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupRulesApi
     */
    public osSecurityGroupRulesPost(osSecurityGroupRulesCreate?: OsSecurityGroupRulesCreate, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupRulesApiFp(this.configuration).osSecurityGroupRulesPost(osSecurityGroupRulesCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsSecurityGroupsApi - axios parameter creator
 * @export
 */
export const OsSecurityGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of security groups.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {string} [allTenants] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsGet: async (limit?: number | string, offset?: number | string, allTenants?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-security-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (allTenants !== undefined) {
                localVarQueryParameter['all_tenants'] = allTenants;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {OsSecurityGroupUpdate} [osSecurityGroupUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdPut: async (id: string, osSecurityGroupUpdate?: OsSecurityGroupUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSecurityGroupsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osSecurityGroupUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new security group.
         * @param {OsSecurityGroupsCreate} [osSecurityGroupsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsPost: async (osSecurityGroupsCreate?: OsSecurityGroupsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-security-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osSecurityGroupsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsSecurityGroupsApi - functional programming interface
 * @export
 */
export const OsSecurityGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsSecurityGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of security groups.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {string} [allTenants] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupsGet(limit?: number | string, offset?: number | string, allTenants?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupsGet(limit, offset, allTenants, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupsApi.osSecurityGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Delete a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupsApi.osSecurityGroupsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupsApi.osSecurityGroupsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Update a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {OsSecurityGroupUpdate} [osSecurityGroupUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupsIdPut(id: string, osSecurityGroupUpdate?: OsSecurityGroupUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupsIdPut(id, osSecurityGroupUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupsApi.osSecurityGroupsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new security group.
         * @param {OsSecurityGroupsCreate} [osSecurityGroupsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSecurityGroupsPost(osSecurityGroupsCreate?: OsSecurityGroupsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSecurityGroupsPost(osSecurityGroupsCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSecurityGroupsApi.osSecurityGroupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsSecurityGroupsApi - factory interface
 * @export
 */
export const OsSecurityGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsSecurityGroupsApiFp(configuration)
    return {
        /**
         *  Returns a list of security groups.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {string} [allTenants] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsGet(limit?: number | string, offset?: number | string, allTenants?: string, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupsGet(limit, offset, allTenants, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osSecurityGroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update a security group.
         * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
         * @param {OsSecurityGroupUpdate} [osSecurityGroupUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsIdPut(id: string, osSecurityGroupUpdate?: OsSecurityGroupUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupsIdPut(id, osSecurityGroupUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new security group.
         * @param {OsSecurityGroupsCreate} [osSecurityGroupsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSecurityGroupsPost(osSecurityGroupsCreate?: OsSecurityGroupsCreate, options?: any): AxiosPromise<any> {
            return localVarFp.osSecurityGroupsPost(osSecurityGroupsCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsSecurityGroupsApi - object-oriented interface
 * @export
 * @class OsSecurityGroupsApi
 * @extends {BaseAPI}
 */
export class OsSecurityGroupsApi extends BaseAPI {
    /**
     *  Returns a list of security groups.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {string} [allTenants] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupsApi
     */
    public osSecurityGroupsGet(limit?: number | string, offset?: number | string, allTenants?: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupsApiFp(this.configuration).osSecurityGroupsGet(limit, offset, allTenants, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a security group.
     * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupsApi
     */
    public osSecurityGroupsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupsApiFp(this.configuration).osSecurityGroupsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given security group.
     * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupsApi
     */
    public osSecurityGroupsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupsApiFp(this.configuration).osSecurityGroupsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update a security group.
     * @param {string} id id parameter for /v2.1/os-security-groups/{id} API
     * @param {OsSecurityGroupUpdate} [osSecurityGroupUpdate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupsApi
     */
    public osSecurityGroupsIdPut(id: string, osSecurityGroupUpdate?: OsSecurityGroupUpdate, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupsApiFp(this.configuration).osSecurityGroupsIdPut(id, osSecurityGroupUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new security group.
     * @param {OsSecurityGroupsCreate} [osSecurityGroupsCreate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSecurityGroupsApi
     */
    public osSecurityGroupsPost(osSecurityGroupsCreate?: OsSecurityGroupsCreate, options?: RawAxiosRequestConfig) {
        return OsSecurityGroupsApiFp(this.configuration).osSecurityGroupsPost(osSecurityGroupsCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsServerExternalEventsApi - axios parameter creator
 * @export
 */
export const OsServerExternalEventsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Creates a new instance event.
         * @param {OsServerExternalEventsCreateRequest} [osServerExternalEventsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerExternalEventsPost: async (osServerExternalEventsCreateRequest?: OsServerExternalEventsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-server-external-events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osServerExternalEventsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsServerExternalEventsApi - functional programming interface
 * @export
 */
export const OsServerExternalEventsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsServerExternalEventsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Creates a new instance event.
         * @param {OsServerExternalEventsCreateRequest} [osServerExternalEventsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServerExternalEventsPost(osServerExternalEventsCreateRequest?: OsServerExternalEventsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServerExternalEventsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServerExternalEventsPost(osServerExternalEventsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServerExternalEventsApi.osServerExternalEventsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsServerExternalEventsApi - factory interface
 * @export
 */
export const OsServerExternalEventsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsServerExternalEventsApiFp(configuration)
    return {
        /**
         *  Creates a new instance event.
         * @param {OsServerExternalEventsCreateRequest} [osServerExternalEventsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerExternalEventsPost(osServerExternalEventsCreateRequest?: OsServerExternalEventsCreateRequest, options?: any): AxiosPromise<OsServerExternalEventsCreateResponse> {
            return localVarFp.osServerExternalEventsPost(osServerExternalEventsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsServerExternalEventsApi - object-oriented interface
 * @export
 * @class OsServerExternalEventsApi
 * @extends {BaseAPI}
 */
export class OsServerExternalEventsApi extends BaseAPI {
    /**
     *  Creates a new instance event.
     * @param {OsServerExternalEventsCreateRequest} [osServerExternalEventsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServerExternalEventsApi
     */
    public osServerExternalEventsPost(osServerExternalEventsCreateRequest?: OsServerExternalEventsCreateRequest, options?: RawAxiosRequestConfig) {
        return OsServerExternalEventsApiFp(this.configuration).osServerExternalEventsPost(osServerExternalEventsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsServerGroupsApi - axios parameter creator
 * @export
 */
export const OsServerGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of server groups.
         * @param {string} [allProjects] 
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsGet: async (allProjects?: string, limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-server-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (allProjects !== undefined) {
                localVarQueryParameter['all_projects'] = allProjects;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osServerGroupsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-server-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osServerGroupsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-server-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new server group.
         * @param {OsServerGroupsCreateRequest} [osServerGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsPost: async (osServerGroupsCreateRequest?: OsServerGroupsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-server-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osServerGroupsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsServerGroupsApi - functional programming interface
 * @export
 */
export const OsServerGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsServerGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of server groups.
         * @param {string} [allProjects] 
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServerGroupsGet(allProjects?: string, limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServerGroupsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServerGroupsGet(allProjects, limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServerGroupsApi.osServerGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Delete a server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServerGroupsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServerGroupsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServerGroupsApi.osServerGroupsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServerGroupsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServerGroupShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServerGroupsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServerGroupsApi.osServerGroupsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new server group.
         * @param {OsServerGroupsCreateRequest} [osServerGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServerGroupsPost(osServerGroupsCreateRequest?: OsServerGroupsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServerGroupsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServerGroupsPost(osServerGroupsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServerGroupsApi.osServerGroupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsServerGroupsApi - factory interface
 * @export
 */
export const OsServerGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsServerGroupsApiFp(configuration)
    return {
        /**
         *  Returns a list of server groups.
         * @param {string} [allProjects] 
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsGet(allProjects?: string, limit?: number | string, offset?: number | string, options?: any): AxiosPromise<OsServerGroupsListResponse> {
            return localVarFp.osServerGroupsGet(allProjects, limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osServerGroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given server group.
         * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsIdGet(id: string, options?: any): AxiosPromise<OsServerGroupShowResponse> {
            return localVarFp.osServerGroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new server group.
         * @param {OsServerGroupsCreateRequest} [osServerGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServerGroupsPost(osServerGroupsCreateRequest?: OsServerGroupsCreateRequest, options?: any): AxiosPromise<OsServerGroupsCreateResponse> {
            return localVarFp.osServerGroupsPost(osServerGroupsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsServerGroupsApi - object-oriented interface
 * @export
 * @class OsServerGroupsApi
 * @extends {BaseAPI}
 */
export class OsServerGroupsApi extends BaseAPI {
    /**
     *  Returns a list of server groups.
     * @param {string} [allProjects] 
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServerGroupsApi
     */
    public osServerGroupsGet(allProjects?: string, limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return OsServerGroupsApiFp(this.configuration).osServerGroupsGet(allProjects, limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a server group.
     * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServerGroupsApi
     */
    public osServerGroupsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsServerGroupsApiFp(this.configuration).osServerGroupsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given server group.
     * @param {string} id id parameter for /v2.1/os-server-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServerGroupsApi
     */
    public osServerGroupsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsServerGroupsApiFp(this.configuration).osServerGroupsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new server group.
     * @param {OsServerGroupsCreateRequest} [osServerGroupsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServerGroupsApi
     */
    public osServerGroupsPost(osServerGroupsCreateRequest?: OsServerGroupsCreateRequest, options?: RawAxiosRequestConfig) {
        return OsServerGroupsApiFp(this.configuration).osServerGroupsPost(osServerGroupsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsServicesApi - axios parameter creator
 * @export
 */
export const OsServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return a list of all running services. Filter by host \\& service name
         * @param {string} [host] 
         * @param {string} [binary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServicesGet: async (host?: string, binary?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Deletes the specified service.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServicesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osServicesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Perform service update   Before microversion 2\\.53, the body contains a host and binary value to identify the service on which to perform the action. There is no service ID passed on the path, just the action, for example PUT /os\\-services/disable.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {OsServiceUpdateRequest} [osServiceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osServicesIdPut: async (id: string, osServiceUpdateRequest?: OsServiceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osServicesIdPut', 'id', id)
            const localVarPath = `/v2.1/os-services/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osServiceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsServicesApi - functional programming interface
 * @export
 */
export const OsServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsServicesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return a list of all running services. Filter by host \\& service name
         * @param {string} [host] 
         * @param {string} [binary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServicesGet(host?: string, binary?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServicesListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServicesGet(host, binary, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServicesApi.osServicesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Deletes the specified service.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osServicesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServicesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServicesApi.osServicesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Perform service update   Before microversion 2\\.53, the body contains a host and binary value to identify the service on which to perform the action. There is no service ID passed on the path, just the action, for example PUT /os\\-services/disable.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {OsServiceUpdateRequest} [osServiceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osServicesIdPut(id: string, osServiceUpdateRequest?: OsServiceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsServiceUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osServicesIdPut(id, osServiceUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsServicesApi.osServicesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsServicesApi - factory interface
 * @export
 */
export const OsServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsServicesApiFp(configuration)
    return {
        /**
         *  Return a list of all running services. Filter by host \\& service name
         * @param {string} [host] 
         * @param {string} [binary] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServicesGet(host?: string, binary?: string, options?: any): AxiosPromise<OsServicesListResponse> {
            return localVarFp.osServicesGet(host, binary, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes the specified service.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osServicesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osServicesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Perform service update   Before microversion 2\\.53, the body contains a host and binary value to identify the service on which to perform the action. There is no service ID passed on the path, just the action, for example PUT /os\\-services/disable.
         * @param {string} id id parameter for /v2.1/os-services/{id} API
         * @param {OsServiceUpdateRequest} [osServiceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osServicesIdPut(id: string, osServiceUpdateRequest?: OsServiceUpdateRequest, options?: any): AxiosPromise<OsServiceUpdateResponse> {
            return localVarFp.osServicesIdPut(id, osServiceUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsServicesApi - object-oriented interface
 * @export
 * @class OsServicesApi
 * @extends {BaseAPI}
 */
export class OsServicesApi extends BaseAPI {
    /**
     *  Return a list of all running services. Filter by host \\& service name
     * @param {string} [host] 
     * @param {string} [binary] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServicesApi
     */
    public osServicesGet(host?: string, binary?: string, options?: RawAxiosRequestConfig) {
        return OsServicesApiFp(this.configuration).osServicesGet(host, binary, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Deletes the specified service.
     * @param {string} id id parameter for /v2.1/os-services/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsServicesApi
     */
    public osServicesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsServicesApiFp(this.configuration).osServicesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Perform service update   Before microversion 2\\.53, the body contains a host and binary value to identify the service on which to perform the action. There is no service ID passed on the path, just the action, for example PUT /os\\-services/disable.
     * @param {string} id id parameter for /v2.1/os-services/{id} API
     * @param {OsServiceUpdateRequest} [osServiceUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsServicesApi
     */
    public osServicesIdPut(id: string, osServiceUpdateRequest?: OsServiceUpdateRequest, options?: RawAxiosRequestConfig) {
        return OsServicesApiFp(this.configuration).osServicesIdPut(id, osServiceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsSimpleTenantUsageApi - axios parameter creator
 * @export
 */
export const OsSimpleTenantUsageApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Retrieve tenant_usage for all tenants.
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [detailed] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSimpleTenantUsageGet: async (start?: string, end?: string, detailed?: string, limit?: number | string, marker?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-simple-tenant-usage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (detailed !== undefined) {
                localVarQueryParameter['detailed'] = detailed;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Retrieve tenant_usage for a specified tenant.
         * @param {string} id id parameter for /v2.1/os-simple-tenant-usage/{id} API
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSimpleTenantUsageIdGet: async (id: string, start?: string, end?: string, limit?: number | string, marker?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSimpleTenantUsageIdGet', 'id', id)
            const localVarPath = `/v2.1/os-simple-tenant-usage/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsSimpleTenantUsageApi - functional programming interface
 * @export
 */
export const OsSimpleTenantUsageApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsSimpleTenantUsageApiAxiosParamCreator(configuration)
    return {
        /**
         *  Retrieve tenant_usage for all tenants.
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [detailed] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSimpleTenantUsageGet(start?: string, end?: string, detailed?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsSimpleTenantUsageListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSimpleTenantUsageGet(start, end, detailed, limit, marker, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSimpleTenantUsageApi.osSimpleTenantUsageGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Retrieve tenant_usage for a specified tenant.
         * @param {string} id id parameter for /v2.1/os-simple-tenant-usage/{id} API
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSimpleTenantUsageIdGet(id: string, start?: string, end?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsSimpleTenantUsageShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSimpleTenantUsageIdGet(id, start, end, limit, marker, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSimpleTenantUsageApi.osSimpleTenantUsageIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsSimpleTenantUsageApi - factory interface
 * @export
 */
export const OsSimpleTenantUsageApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsSimpleTenantUsageApiFp(configuration)
    return {
        /**
         *  Retrieve tenant_usage for all tenants.
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {string} [detailed] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSimpleTenantUsageGet(start?: string, end?: string, detailed?: string, limit?: number | string, marker?: string, options?: any): AxiosPromise<OsSimpleTenantUsageListResponse> {
            return localVarFp.osSimpleTenantUsageGet(start, end, detailed, limit, marker, options).then((request) => request(axios, basePath));
        },
        /**
         *  Retrieve tenant_usage for a specified tenant.
         * @param {string} id id parameter for /v2.1/os-simple-tenant-usage/{id} API
         * @param {string} [start] 
         * @param {string} [end] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSimpleTenantUsageIdGet(id: string, start?: string, end?: string, limit?: number | string, marker?: string, options?: any): AxiosPromise<OsSimpleTenantUsageShowResponse> {
            return localVarFp.osSimpleTenantUsageIdGet(id, start, end, limit, marker, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsSimpleTenantUsageApi - object-oriented interface
 * @export
 * @class OsSimpleTenantUsageApi
 * @extends {BaseAPI}
 */
export class OsSimpleTenantUsageApi extends BaseAPI {
    /**
     *  Retrieve tenant_usage for all tenants.
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {string} [detailed] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSimpleTenantUsageApi
     */
    public osSimpleTenantUsageGet(start?: string, end?: string, detailed?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig) {
        return OsSimpleTenantUsageApiFp(this.configuration).osSimpleTenantUsageGet(start, end, detailed, limit, marker, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Retrieve tenant_usage for a specified tenant.
     * @param {string} id id parameter for /v2.1/os-simple-tenant-usage/{id} API
     * @param {string} [start] 
     * @param {string} [end] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSimpleTenantUsageApi
     */
    public osSimpleTenantUsageIdGet(id: string, start?: string, end?: string, limit?: number | string, marker?: string, options?: RawAxiosRequestConfig) {
        return OsSimpleTenantUsageApiFp(this.configuration).osSimpleTenantUsageIdGet(id, start, end, limit, marker, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsSnapshotsApi - axios parameter creator
 * @export
 */
export const OsSnapshotsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a detailed list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsDetailGet: async (limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-snapshots/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a summary list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsGet: async (limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSnapshotsIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osSnapshotsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-snapshots/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new snapshot.
         * @param {OsSnapshotsCreate} [osSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsPost: async (osSnapshotsCreate?: OsSnapshotsCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-snapshots`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osSnapshotsCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsSnapshotsApi - functional programming interface
 * @export
 */
export const OsSnapshotsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsSnapshotsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a detailed list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSnapshotsDetailGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSnapshotsDetailGet(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSnapshotsApi.osSnapshotsDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a summary list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSnapshotsGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSnapshotsGet(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSnapshotsApi.osSnapshotsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Delete a snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSnapshotsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSnapshotsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSnapshotsApi.osSnapshotsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSnapshotsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSnapshotsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSnapshotsApi.osSnapshotsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new snapshot.
         * @param {OsSnapshotsCreate} [osSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osSnapshotsPost(osSnapshotsCreate?: OsSnapshotsCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osSnapshotsPost(osSnapshotsCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsSnapshotsApi.osSnapshotsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsSnapshotsApi - factory interface
 * @export
 */
export const OsSnapshotsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsSnapshotsApiFp(configuration)
    return {
        /**
         *  Returns a detailed list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsDetailGet(limit?: number | string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.osSnapshotsDetailGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a summary list of snapshots.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsGet(limit?: number | string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.osSnapshotsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osSnapshotsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given snapshot.
         * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osSnapshotsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new snapshot.
         * @param {OsSnapshotsCreate} [osSnapshotsCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osSnapshotsPost(osSnapshotsCreate?: OsSnapshotsCreate, options?: any): AxiosPromise<any> {
            return localVarFp.osSnapshotsPost(osSnapshotsCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsSnapshotsApi - object-oriented interface
 * @export
 * @class OsSnapshotsApi
 * @extends {BaseAPI}
 */
export class OsSnapshotsApi extends BaseAPI {
    /**
     *  Returns a detailed list of snapshots.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSnapshotsApi
     */
    public osSnapshotsDetailGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return OsSnapshotsApiFp(this.configuration).osSnapshotsDetailGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a summary list of snapshots.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSnapshotsApi
     */
    public osSnapshotsGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return OsSnapshotsApiFp(this.configuration).osSnapshotsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a snapshot.
     * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSnapshotsApi
     */
    public osSnapshotsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsSnapshotsApiFp(this.configuration).osSnapshotsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given snapshot.
     * @param {string} id id parameter for /v2.1/os-snapshots/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSnapshotsApi
     */
    public osSnapshotsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsSnapshotsApiFp(this.configuration).osSnapshotsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new snapshot.
     * @param {OsSnapshotsCreate} [osSnapshotsCreate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsSnapshotsApi
     */
    public osSnapshotsPost(osSnapshotsCreate?: OsSnapshotsCreate, options?: RawAxiosRequestConfig) {
        return OsSnapshotsApiFp(this.configuration).osSnapshotsPost(osSnapshotsCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsTenantNetworksApi - axios parameter creator
 * @export
 */
export const OsTenantNetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-tenant-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osTenantNetworksIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-tenant-networks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osTenantNetworksIdGet', 'id', id)
            const localVarPath = `/v2.1/os-tenant-networks/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksPost: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-tenant-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsTenantNetworksApi - functional programming interface
 * @export
 */
export const OsTenantNetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsTenantNetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osTenantNetworksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osTenantNetworksGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsTenantNetworksApi.osTenantNetworksGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osTenantNetworksIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osTenantNetworksIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsTenantNetworksApi.osTenantNetworksIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osTenantNetworksIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osTenantNetworksIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsTenantNetworksApi.osTenantNetworksIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osTenantNetworksPost(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osTenantNetworksPost(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsTenantNetworksApi.osTenantNetworksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsTenantNetworksApi - factory interface
 * @export
 */
export const OsTenantNetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsTenantNetworksApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksGet(options?: any): AxiosPromise<any> {
            return localVarFp.osTenantNetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osTenantNetworksIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osTenantNetworksIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osTenantNetworksPost(options?: any): AxiosPromise<any> {
            return localVarFp.osTenantNetworksPost(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsTenantNetworksApi - object-oriented interface
 * @export
 * @class OsTenantNetworksApi
 * @extends {BaseAPI}
 */
export class OsTenantNetworksApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsTenantNetworksApi
     */
    public osTenantNetworksGet(options?: RawAxiosRequestConfig) {
        return OsTenantNetworksApiFp(this.configuration).osTenantNetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsTenantNetworksApi
     */
    public osTenantNetworksIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsTenantNetworksApiFp(this.configuration).osTenantNetworksIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-tenant-networks/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsTenantNetworksApi
     */
    public osTenantNetworksIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsTenantNetworksApiFp(this.configuration).osTenantNetworksIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsTenantNetworksApi
     */
    public osTenantNetworksPost(options?: RawAxiosRequestConfig) {
        return OsTenantNetworksApiFp(this.configuration).osTenantNetworksPost(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsVolumesApi - axios parameter creator
 * @export
 */
export const OsVolumesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a detailed list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesDetailGet: async (limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a summary list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesGet: async (limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Delete a volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-volumes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesIdGet', 'id', id)
            const localVarPath = `/v2.1/os-volumes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new volume.
         * @param {OsVolumesCreate} [osVolumesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesPost: async (osVolumesCreate?: OsVolumesCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osVolumesCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsVolumesApi - functional programming interface
 * @export
 */
export const OsVolumesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsVolumesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a detailed list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osVolumesDetailGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesDetailGet(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesApi.osVolumesDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a summary list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osVolumesGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesGet(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesApi.osVolumesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Delete a volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osVolumesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesApi.osVolumesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osVolumesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesApi.osVolumesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new volume.
         * @param {OsVolumesCreate} [osVolumesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osVolumesPost(osVolumesCreate?: OsVolumesCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesPost(osVolumesCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesApi.osVolumesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsVolumesApi - factory interface
 * @export
 */
export const OsVolumesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsVolumesApiFp(configuration)
    return {
        /**
         *  Returns a detailed list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesDetailGet(limit?: number | string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesDetailGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a summary list of volumes.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesGet(limit?: number | string, offset?: number | string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Delete a volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osVolumesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given volume.
         * @param {string} id id parameter for /v2.1/os-volumes/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new volume.
         * @param {OsVolumesCreate} [osVolumesCreate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osVolumesPost(osVolumesCreate?: OsVolumesCreate, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesPost(osVolumesCreate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsVolumesApi - object-oriented interface
 * @export
 * @class OsVolumesApi
 * @extends {BaseAPI}
 */
export class OsVolumesApi extends BaseAPI {
    /**
     *  Returns a detailed list of volumes.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsVolumesApi
     */
    public osVolumesDetailGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return OsVolumesApiFp(this.configuration).osVolumesDetailGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a summary list of volumes.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsVolumesApi
     */
    public osVolumesGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return OsVolumesApiFp(this.configuration).osVolumesGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Delete a volume.
     * @param {string} id id parameter for /v2.1/os-volumes/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsVolumesApi
     */
    public osVolumesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsVolumesApiFp(this.configuration).osVolumesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given volume.
     * @param {string} id id parameter for /v2.1/os-volumes/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsVolumesApi
     */
    public osVolumesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsVolumesApiFp(this.configuration).osVolumesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new volume.
     * @param {OsVolumesCreate} [osVolumesCreate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OsVolumesApi
     */
    public osVolumesPost(osVolumesCreate?: OsVolumesCreate, options?: RawAxiosRequestConfig) {
        return OsVolumesApiFp(this.configuration).osVolumesPost(osVolumesCreate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OsVolumesBootApi - axios parameter creator
 * @export
 */
export const OsVolumesBootApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootDetailGet: async (userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes_boot/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (launchIndex !== undefined) {
                localVarQueryParameter['launch_index'] = launchIndex;
            }

            if (imageRef !== undefined) {
                localVarQueryParameter['image_ref'] = imageRef;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (kernelId !== undefined) {
                localVarQueryParameter['kernel_id'] = kernelId;
            }

            if (ramdiskId !== undefined) {
                localVarQueryParameter['ramdisk_id'] = ramdiskId;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (keyName !== undefined) {
                localVarQueryParameter['key_name'] = keyName;
            }

            if (powerState !== undefined) {
                localVarQueryParameter['power_state'] = powerState;
            }

            if (vmState !== undefined) {
                localVarQueryParameter['vm_state'] = vmState;
            }

            if (taskState !== undefined) {
                localVarQueryParameter['task_state'] = taskState;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (flavor !== undefined) {
                localVarQueryParameter['flavor'] = flavor;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (launchedAt !== undefined) {
                localVarQueryParameter['launched_at'] = launchedAt;
            }

            if (terminatedAt !== undefined) {
                localVarQueryParameter['terminated_at'] = terminatedAt;
            }

            if (availabilityZone !== undefined) {
                localVarQueryParameter['availability_zone'] = availabilityZone;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (displayDescription !== undefined) {
                localVarQueryParameter['display_description'] = displayDescription;
            }

            if (lockedBy !== undefined) {
                localVarQueryParameter['locked_by'] = lockedBy;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (rootDeviceName !== undefined) {
                localVarQueryParameter['root_device_name'] = rootDeviceName;
            }

            if (configDrive !== undefined) {
                localVarQueryParameter['config_drive'] = configDrive;
            }

            if (accessIpV4 !== undefined) {
                localVarQueryParameter['access_ip_v4'] = accessIpV4;
            }

            if (accessIpV6 !== undefined) {
                localVarQueryParameter['access_ip_v6'] = accessIpV6;
            }

            if (autoDiskConfig !== undefined) {
                localVarQueryParameter['auto_disk_config'] = autoDiskConfig;
            }

            if (progress !== undefined) {
                localVarQueryParameter['progress'] = progress;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (allTenants !== undefined) {
                localVarQueryParameter['all_tenants'] = allTenants;
            }

            if (softDeleted !== undefined) {
                localVarQueryParameter['soft_deleted'] = softDeleted;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (ip6 !== undefined) {
                localVarQueryParameter['ip6'] = ip6;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (blockDeviceMapping !== undefined) {
                localVarQueryParameter['block_device_mapping'] = blockDeviceMapping;
            }

            if (services !== undefined) {
                localVarQueryParameter['services'] = services;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (systemMetadata !== undefined) {
                localVarQueryParameter['system_metadata'] = systemMetadata;
            }

            if (infoCache !== undefined) {
                localVarQueryParameter['info_cache'] = infoCache;
            }

            if (securityGroups !== undefined) {
                localVarQueryParameter['security_groups'] = securityGroups;
            }

            if (pciDevices !== undefined) {
                localVarQueryParameter['pci_devices'] = pciDevices;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAny !== undefined) {
                localVarQueryParameter['tags-any'] = tagsAny;
            }

            if (notTags !== undefined) {
                localVarQueryParameter['not-tags'] = notTags;
            }

            if (notTagsAny !== undefined) {
                localVarQueryParameter['not-tags-any'] = notTagsAny;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootGet: async (userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes_boot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (launchIndex !== undefined) {
                localVarQueryParameter['launch_index'] = launchIndex;
            }

            if (imageRef !== undefined) {
                localVarQueryParameter['image_ref'] = imageRef;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (kernelId !== undefined) {
                localVarQueryParameter['kernel_id'] = kernelId;
            }

            if (ramdiskId !== undefined) {
                localVarQueryParameter['ramdisk_id'] = ramdiskId;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (keyName !== undefined) {
                localVarQueryParameter['key_name'] = keyName;
            }

            if (powerState !== undefined) {
                localVarQueryParameter['power_state'] = powerState;
            }

            if (vmState !== undefined) {
                localVarQueryParameter['vm_state'] = vmState;
            }

            if (taskState !== undefined) {
                localVarQueryParameter['task_state'] = taskState;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (flavor !== undefined) {
                localVarQueryParameter['flavor'] = flavor;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (launchedAt !== undefined) {
                localVarQueryParameter['launched_at'] = launchedAt;
            }

            if (terminatedAt !== undefined) {
                localVarQueryParameter['terminated_at'] = terminatedAt;
            }

            if (availabilityZone !== undefined) {
                localVarQueryParameter['availability_zone'] = availabilityZone;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (displayDescription !== undefined) {
                localVarQueryParameter['display_description'] = displayDescription;
            }

            if (lockedBy !== undefined) {
                localVarQueryParameter['locked_by'] = lockedBy;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (rootDeviceName !== undefined) {
                localVarQueryParameter['root_device_name'] = rootDeviceName;
            }

            if (configDrive !== undefined) {
                localVarQueryParameter['config_drive'] = configDrive;
            }

            if (accessIpV4 !== undefined) {
                localVarQueryParameter['access_ip_v4'] = accessIpV4;
            }

            if (accessIpV6 !== undefined) {
                localVarQueryParameter['access_ip_v6'] = accessIpV6;
            }

            if (autoDiskConfig !== undefined) {
                localVarQueryParameter['auto_disk_config'] = autoDiskConfig;
            }

            if (progress !== undefined) {
                localVarQueryParameter['progress'] = progress;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (allTenants !== undefined) {
                localVarQueryParameter['all_tenants'] = allTenants;
            }

            if (softDeleted !== undefined) {
                localVarQueryParameter['soft_deleted'] = softDeleted;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (ip6 !== undefined) {
                localVarQueryParameter['ip6'] = ip6;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (blockDeviceMapping !== undefined) {
                localVarQueryParameter['block_device_mapping'] = blockDeviceMapping;
            }

            if (services !== undefined) {
                localVarQueryParameter['services'] = services;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (systemMetadata !== undefined) {
                localVarQueryParameter['system_metadata'] = systemMetadata;
            }

            if (infoCache !== undefined) {
                localVarQueryParameter['info_cache'] = infoCache;
            }

            if (securityGroups !== undefined) {
                localVarQueryParameter['security_groups'] = securityGroups;
            }

            if (pciDevices !== undefined) {
                localVarQueryParameter['pci_devices'] = pciDevices;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAny !== undefined) {
                localVarQueryParameter['tags-any'] = tagsAny;
            }

            if (notTags !== undefined) {
                localVarQueryParameter['not-tags'] = notTags;
            }

            if (notTagsAny !== undefined) {
                localVarQueryParameter['not-tags-any'] = notTagsAny;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id}/action API
         * @param {OsVolumesBootIdActionPostRequest} [osVolumesBootIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdActionPost: async (id: string, osVolumesBootIdActionPostRequest?: OsVolumesBootIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesBootIdActionPost', 'id', id)
            const localVarPath = `/v2.1/os-volumes_boot/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osVolumesBootIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesBootIdDelete', 'id', id)
            const localVarPath = `/v2.1/os-volumes_boot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesBootIdGet', 'id', id)
            const localVarPath = `/v2.1/os-volumes_boot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {OsVolumesBootUpdateRequest} [osVolumesBootUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdPut: async (id: string, osVolumesBootUpdateRequest?: OsVolumesBootUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osVolumesBootIdPut', 'id', id)
            const localVarPath = `/v2.1/os-volumes_boot/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osVolumesBootUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new server for a given user.
         * @param {OsVolumesBootCreateRequest} [osVolumesBootCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootPost: async (osVolumesBootCreateRequest?: OsVolumesBootCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-volumes_boot`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osVolumesBootCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OsVolumesBootApi - functional programming interface
 * @export
 */
export const OsVolumesBootApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OsVolumesBootApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id}/action API
         * @param {OsVolumesBootIdActionPostRequest} [osVolumesBootIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootIdActionPost(id: string, osVolumesBootIdActionPostRequest?: OsVolumesBootIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsVolumesBootIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootIdActionPost(id, osVolumesBootIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {OsVolumesBootUpdateRequest} [osVolumesBootUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootIdPut(id: string, osVolumesBootUpdateRequest?: OsVolumesBootUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootIdPut(id, osVolumesBootUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new server for a given user.
         * @param {OsVolumesBootCreateRequest} [osVolumesBootCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osVolumesBootPost(osVolumesBootCreateRequest?: OsVolumesBootCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osVolumesBootPost(osVolumesBootCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OsVolumesBootApi.osVolumesBootPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OsVolumesBootApi - factory interface
 * @export
 */
export const OsVolumesBootApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OsVolumesBootApiFp(configuration)
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesBootDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {OsVolumesBootGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesBootGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id}/action API
         * @param {OsVolumesBootIdActionPostRequest} [osVolumesBootIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdActionPost(id: string, osVolumesBootIdActionPostRequest?: OsVolumesBootIdActionPostRequest, options?: any): AxiosPromise<OsVolumesBootIdActionPost201Response> {
            return localVarFp.osVolumesBootIdActionPost(id, osVolumesBootIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.osVolumesBootIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdGet(id: string, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesBootIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
         * @param {OsVolumesBootUpdateRequest} [osVolumesBootUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootIdPut(id: string, osVolumesBootUpdateRequest?: OsVolumesBootUpdateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesBootIdPut(id, osVolumesBootUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new server for a given user.
         * @param {OsVolumesBootCreateRequest} [osVolumesBootCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osVolumesBootPost(osVolumesBootCreateRequest?: OsVolumesBootCreateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.osVolumesBootPost(osVolumesBootCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OsVolumesBootApi - object-oriented interface
 * @export
 * @class OsVolumesBootApi
 * @extends {BaseAPI}
 */
export class OsVolumesBootApi extends BaseAPI {
    /**
     *  Returns a list of server details for a given user.
     * @param {string} [userId] 
     * @param {string} [projectId] 
     * @param {string} [tenantId] 
     * @param {string} [launchIndex] 
     * @param {string} [imageRef] 
     * @param {string} [image] 
     * @param {string} [kernelId] 
     * @param {string} [ramdiskId] 
     * @param {string} [hostname] 
     * @param {string} [keyName] 
     * @param {string} [powerState] 
     * @param {string} [vmState] 
     * @param {string} [taskState] 
     * @param {string} [host] 
     * @param {string} [node] 
     * @param {string} [flavor] 
     * @param {string} [reservationId] 
     * @param {string} [launchedAt] 
     * @param {string} [terminatedAt] 
     * @param {string} [availabilityZone] 
     * @param {string} [name] 
     * @param {string} [displayName] 
     * @param {string} [description] 
     * @param {string} [displayDescription] 
     * @param {string} [lockedBy] 
     * @param {string} [uuid] 
     * @param {string} [rootDeviceName] 
     * @param {string} [configDrive] 
     * @param {string} [accessIpV4] 
     * @param {string} [accessIpV6] 
     * @param {string} [autoDiskConfig] 
     * @param {string} [progress] 
     * @param {OsVolumesBootDetailGetSortKeyEnum} [sortKey] 
     * @param {string} [sortDir] 
     * @param {string} [allTenants] 
     * @param {string} [softDeleted] 
     * @param {string} [deleted] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [ip] 
     * @param {string} [ip6] 
     * @param {string} [createdAt] 
     * @param {string} [blockDeviceMapping] 
     * @param {string} [services] 
     * @param {string} [metadata] 
     * @param {string} [systemMetadata] 
     * @param {string} [infoCache] 
     * @param {string} [securityGroups] 
     * @param {string} [pciDevices] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [tags] 
     * @param {string} [tagsAny] 
     * @param {string} [notTags] 
     * @param {string} [notTagsAny] 
     * @param {string} [changesBefore] 
     * @param {string} [locked] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a list of server names and ids for a given user.
     * @param {string} [userId] 
     * @param {string} [projectId] 
     * @param {string} [tenantId] 
     * @param {string} [launchIndex] 
     * @param {string} [imageRef] 
     * @param {string} [image] 
     * @param {string} [kernelId] 
     * @param {string} [ramdiskId] 
     * @param {string} [hostname] 
     * @param {string} [keyName] 
     * @param {string} [powerState] 
     * @param {string} [vmState] 
     * @param {string} [taskState] 
     * @param {string} [host] 
     * @param {string} [node] 
     * @param {string} [flavor] 
     * @param {string} [reservationId] 
     * @param {string} [launchedAt] 
     * @param {string} [terminatedAt] 
     * @param {string} [availabilityZone] 
     * @param {string} [name] 
     * @param {string} [displayName] 
     * @param {string} [description] 
     * @param {string} [displayDescription] 
     * @param {string} [lockedBy] 
     * @param {string} [uuid] 
     * @param {string} [rootDeviceName] 
     * @param {string} [configDrive] 
     * @param {string} [accessIpV4] 
     * @param {string} [accessIpV6] 
     * @param {string} [autoDiskConfig] 
     * @param {string} [progress] 
     * @param {OsVolumesBootGetSortKeyEnum} [sortKey] 
     * @param {string} [sortDir] 
     * @param {string} [allTenants] 
     * @param {string} [softDeleted] 
     * @param {string} [deleted] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [ip] 
     * @param {string} [ip6] 
     * @param {string} [createdAt] 
     * @param {string} [blockDeviceMapping] 
     * @param {string} [services] 
     * @param {string} [metadata] 
     * @param {string} [systemMetadata] 
     * @param {string} [infoCache] 
     * @param {string} [securityGroups] 
     * @param {string} [pciDevices] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [tags] 
     * @param {string} [tagsAny] 
     * @param {string} [notTags] 
     * @param {string} [notTagsAny] 
     * @param {string} [changesBefore] 
     * @param {string} [locked] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: OsVolumesBootGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-volumes_boot/{id}/action API
     * @param {OsVolumesBootIdActionPostRequest} [osVolumesBootIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootIdActionPost(id: string, osVolumesBootIdActionPostRequest?: OsVolumesBootIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootIdActionPost(id, osVolumesBootIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Destroys a server.
     * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns server details by server id.
     * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootIdGet(id: string, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update server then pass on to version\\-specific controller.
     * @param {string} id id parameter for /v2.1/os-volumes_boot/{id} API
     * @param {OsVolumesBootUpdateRequest} [osVolumesBootUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootIdPut(id: string, osVolumesBootUpdateRequest?: OsVolumesBootUpdateRequest, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootIdPut(id, osVolumesBootUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new server for a given user.
     * @param {OsVolumesBootCreateRequest} [osVolumesBootCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OsVolumesBootApi
     */
    public osVolumesBootPost(osVolumesBootCreateRequest?: OsVolumesBootCreateRequest, options?: RawAxiosRequestConfig) {
        return OsVolumesBootApiFp(this.configuration).osVolumesBootPost(osVolumesBootCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const OsVolumesBootDetailGetSortKeyEnum = {
    DisplayDescription: 'display_description',
    InstanceTypeId: 'instance_type_id',
    DisplayName: 'display_name',
    LaunchIndex: 'launch_index',
    AccessIpV6: 'access_ip_v6',
    TerminatedAt: 'terminated_at',
    VmState: 'vm_state',
    ProjectId: 'project_id',
    UserId: 'user_id',
    KernelId: 'kernel_id',
    Uuid: 'uuid',
    TaskState: 'task_state',
    ImageRef: 'image_ref',
    AutoDiskConfig: 'auto_disk_config',
    PowerState: 'power_state',
    KeyName: 'key_name',
    Host: 'host',
    Node: 'node',
    AvailabilityZone: 'availability_zone',
    LockedBy: 'locked_by',
    RootDeviceName: 'root_device_name',
    CreatedAt: 'created_at',
    RamdiskId: 'ramdisk_id',
    LaunchedAt: 'launched_at',
    AccessIpV4: 'access_ip_v4',
    Progress: 'progress',
    Locked: 'locked',
    UpdatedAt: 'updated_at',
    Hostname: 'hostname',
    ConfigDrive: 'config_drive'
} as const;
export type OsVolumesBootDetailGetSortKeyEnum = typeof OsVolumesBootDetailGetSortKeyEnum[keyof typeof OsVolumesBootDetailGetSortKeyEnum];
/**
 * @export
 */
export const OsVolumesBootGetSortKeyEnum = {
    DisplayDescription: 'display_description',
    InstanceTypeId: 'instance_type_id',
    DisplayName: 'display_name',
    LaunchIndex: 'launch_index',
    AccessIpV6: 'access_ip_v6',
    TerminatedAt: 'terminated_at',
    VmState: 'vm_state',
    ProjectId: 'project_id',
    UserId: 'user_id',
    KernelId: 'kernel_id',
    Uuid: 'uuid',
    TaskState: 'task_state',
    ImageRef: 'image_ref',
    AutoDiskConfig: 'auto_disk_config',
    PowerState: 'power_state',
    KeyName: 'key_name',
    Host: 'host',
    Node: 'node',
    AvailabilityZone: 'availability_zone',
    LockedBy: 'locked_by',
    RootDeviceName: 'root_device_name',
    CreatedAt: 'created_at',
    RamdiskId: 'ramdisk_id',
    LaunchedAt: 'launched_at',
    AccessIpV4: 'access_ip_v4',
    Progress: 'progress',
    Locked: 'locked',
    UpdatedAt: 'updated_at',
    Hostname: 'hostname',
    ConfigDrive: 'config_drive'
} as const;
export type OsVolumesBootGetSortKeyEnum = typeof OsVolumesBootGetSortKeyEnum[keyof typeof OsVolumesBootGetSortKeyEnum];


/**
 * QuotaClassSetsOsQuotaClassSetsApi - axios parameter creator
 * @export
 */
export const QuotaClassSetsOsQuotaClassSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaClassSetsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osQuotaClassSetsIdGet', 'id', id)
            const localVarPath = `/v2.1/os-quota-class-sets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {OsQuotaClassSetUpdate} [osQuotaClassSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaClassSetsIdPut: async (id: string, osQuotaClassSetUpdate?: OsQuotaClassSetUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osQuotaClassSetsIdPut', 'id', id)
            const localVarPath = `/v2.1/os-quota-class-sets/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osQuotaClassSetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotaClassSetsOsQuotaClassSetsApi - functional programming interface
 * @export
 */
export const QuotaClassSetsOsQuotaClassSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotaClassSetsOsQuotaClassSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaClassSetsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsQuotaClassSetShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaClassSetsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaClassSetsOsQuotaClassSetsApi.osQuotaClassSetsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {OsQuotaClassSetUpdate} [osQuotaClassSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaClassSetsIdPut(id: string, osQuotaClassSetUpdate?: OsQuotaClassSetUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaClassSetsIdPut(id, osQuotaClassSetUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaClassSetsOsQuotaClassSetsApi.osQuotaClassSetsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * QuotaClassSetsOsQuotaClassSetsApi - factory interface
 * @export
 */
export const QuotaClassSetsOsQuotaClassSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotaClassSetsOsQuotaClassSetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaClassSetsIdGet(id: string, options?: any): AxiosPromise<OsQuotaClassSetShowResponse> {
            return localVarFp.osQuotaClassSetsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
         * @param {OsQuotaClassSetUpdate} [osQuotaClassSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaClassSetsIdPut(id: string, osQuotaClassSetUpdate?: OsQuotaClassSetUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.osQuotaClassSetsIdPut(id, osQuotaClassSetUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotaClassSetsOsQuotaClassSetsApi - object-oriented interface
 * @export
 * @class QuotaClassSetsOsQuotaClassSetsApi
 * @extends {BaseAPI}
 */
export class QuotaClassSetsOsQuotaClassSetsApi extends BaseAPI {
    /**
     * 
     * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaClassSetsOsQuotaClassSetsApi
     */
    public osQuotaClassSetsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QuotaClassSetsOsQuotaClassSetsApiFp(this.configuration).osQuotaClassSetsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/os-quota-class-sets/{id} API
     * @param {OsQuotaClassSetUpdate} [osQuotaClassSetUpdate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaClassSetsOsQuotaClassSetsApi
     */
    public osQuotaClassSetsIdPut(id: string, osQuotaClassSetUpdate?: OsQuotaClassSetUpdate, options?: RawAxiosRequestConfig) {
        return QuotaClassSetsOsQuotaClassSetsApiFp(this.configuration).osQuotaClassSetsIdPut(id, osQuotaClassSetUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * QuotaSetsOsQuotaSetsApi - axios parameter creator
 * @export
 */
export const QuotaSetsOsQuotaSetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-sets/{id}/defaults API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdDefaultsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osQuotaSetsIdDefaultsGet', 'id', id)
            const localVarPath = `/v2.1/os-quota-sets/{id}/defaults`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osQuotaSetsIdDelete: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-quota-sets/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdDetailGet: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-quota-sets/{id}/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdGet: async (userId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-quota-sets/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {OsQuotaSetUpdate} [osQuotaSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdPut: async (userId?: string, osQuotaSetUpdate?: OsQuotaSetUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/os-quota-sets/{id}`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osQuotaSetUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotaSetsOsQuotaSetsApi - functional programming interface
 * @export
 */
export const QuotaSetsOsQuotaSetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotaSetsOsQuotaSetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-sets/{id}/defaults API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaSetsIdDefaultsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsQuotaSetsDefaultsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaSetsIdDefaultsGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaSetsOsQuotaSetsApi.osQuotaSetsIdDefaultsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async osQuotaSetsIdDelete(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaSetsIdDelete(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaSetsOsQuotaSetsApi.osQuotaSetsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaSetsIdDetailGet(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsQuotaSetsDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaSetsIdDetailGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaSetsOsQuotaSetsApi.osQuotaSetsIdDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaSetsIdGet(userId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsQuotaSetShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaSetsIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaSetsOsQuotaSetsApi.osQuotaSetsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {OsQuotaSetUpdate} [osQuotaSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osQuotaSetsIdPut(userId?: string, osQuotaSetUpdate?: OsQuotaSetUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsQuotaSetUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osQuotaSetsIdPut(userId, osQuotaSetUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotaSetsOsQuotaSetsApi.osQuotaSetsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * QuotaSetsOsQuotaSetsApi - factory interface
 * @export
 */
export const QuotaSetsOsQuotaSetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotaSetsOsQuotaSetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id id parameter for /v2.1/os-quota-sets/{id}/defaults API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdDefaultsGet(id: string, options?: any): AxiosPromise<OsQuotaSetsDefaultsResponse> {
            return localVarFp.osQuotaSetsIdDefaultsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        osQuotaSetsIdDelete(userId?: string, options?: any): AxiosPromise<void> {
            return localVarFp.osQuotaSetsIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdDetailGet(userId?: string, options?: any): AxiosPromise<OsQuotaSetsDetailResponse> {
            return localVarFp.osQuotaSetsIdDetailGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdGet(userId?: string, options?: any): AxiosPromise<OsQuotaSetShowResponse> {
            return localVarFp.osQuotaSetsIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [userId] 
         * @param {OsQuotaSetUpdate} [osQuotaSetUpdate] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osQuotaSetsIdPut(userId?: string, osQuotaSetUpdate?: OsQuotaSetUpdate, options?: any): AxiosPromise<OsQuotaSetUpdateResponse> {
            return localVarFp.osQuotaSetsIdPut(userId, osQuotaSetUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotaSetsOsQuotaSetsApi - object-oriented interface
 * @export
 * @class QuotaSetsOsQuotaSetsApi
 * @extends {BaseAPI}
 */
export class QuotaSetsOsQuotaSetsApi extends BaseAPI {
    /**
     * 
     * @param {string} id id parameter for /v2.1/os-quota-sets/{id}/defaults API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaSetsOsQuotaSetsApi
     */
    public osQuotaSetsIdDefaultsGet(id: string, options?: RawAxiosRequestConfig) {
        return QuotaSetsOsQuotaSetsApiFp(this.configuration).osQuotaSetsIdDefaultsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotaSetsOsQuotaSetsApi
     */
    public osQuotaSetsIdDelete(userId?: string, options?: RawAxiosRequestConfig) {
        return QuotaSetsOsQuotaSetsApiFp(this.configuration).osQuotaSetsIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaSetsOsQuotaSetsApi
     */
    public osQuotaSetsIdDetailGet(userId?: string, options?: RawAxiosRequestConfig) {
        return QuotaSetsOsQuotaSetsApiFp(this.configuration).osQuotaSetsIdDetailGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaSetsOsQuotaSetsApi
     */
    public osQuotaSetsIdGet(userId?: string, options?: RawAxiosRequestConfig) {
        return QuotaSetsOsQuotaSetsApiFp(this.configuration).osQuotaSetsIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [userId] 
     * @param {OsQuotaSetUpdate} [osQuotaSetUpdate] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof QuotaSetsOsQuotaSetsApi
     */
    public osQuotaSetsIdPut(userId?: string, osQuotaSetUpdate?: OsQuotaSetUpdate, options?: RawAxiosRequestConfig) {
        return QuotaSetsOsQuotaSetsApiFp(this.configuration).osQuotaSetsIdPut(userId, osQuotaSetUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerConsolesApi - axios parameter creator
 * @export
 */
export const ServerConsolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Until microversion 2\\.30, this API was available only for the rdp\\-html5 console type which has been removed along with the HyperV driver in the Nova 29\\.0\\.0 (Caracal) release. As this method is for microversion \\<\\=2\\.30, it will return an http 400 error. Starting from 2\\.31 microversion, this API works for all the supported console types that are handled by the separate show method defined below.
         * @param {string} id id parameter for /v2.1/os-console-auth-tokens/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osConsoleAuthTokensIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('osConsoleAuthTokensIdGet', 'id', id)
            const localVarPath = `/v2.1/os-console-auth-tokens/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/remote-consoles API
         * @param {ServersRemoteConsolesCreateRequest} [serversRemoteConsolesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdRemoteConsolesPost: async (serverId: string, serversRemoteConsolesCreateRequest?: ServersRemoteConsolesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdRemoteConsolesPost', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/remote-consoles`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversRemoteConsolesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerConsolesApi - functional programming interface
 * @export
 */
export const ServerConsolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerConsolesApiAxiosParamCreator(configuration)
    return {
        /**
         *  Until microversion 2\\.30, this API was available only for the rdp\\-html5 console type which has been removed along with the HyperV driver in the Nova 29\\.0\\.0 (Caracal) release. As this method is for microversion \\<\\=2\\.30, it will return an http 400 error. Starting from 2\\.31 microversion, this API works for all the supported console types that are handled by the separate show method defined below.
         * @param {string} id id parameter for /v2.1/os-console-auth-tokens/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async osConsoleAuthTokensIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsConsoleAuthTokenShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.osConsoleAuthTokensIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerConsolesApi.osConsoleAuthTokensIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/remote-consoles API
         * @param {ServersRemoteConsolesCreateRequest} [serversRemoteConsolesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdRemoteConsolesPost(serverId: string, serversRemoteConsolesCreateRequest?: ServersRemoteConsolesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersRemoteConsolesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdRemoteConsolesPost(serverId, serversRemoteConsolesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerConsolesApi.serversServerIdRemoteConsolesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServerConsolesApi - factory interface
 * @export
 */
export const ServerConsolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerConsolesApiFp(configuration)
    return {
        /**
         *  Until microversion 2\\.30, this API was available only for the rdp\\-html5 console type which has been removed along with the HyperV driver in the Nova 29\\.0\\.0 (Caracal) release. As this method is for microversion \\<\\=2\\.30, it will return an http 400 error. Starting from 2\\.31 microversion, this API works for all the supported console types that are handled by the separate show method defined below.
         * @param {string} id id parameter for /v2.1/os-console-auth-tokens/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        osConsoleAuthTokensIdGet(id: string, options?: any): AxiosPromise<OsConsoleAuthTokenShowResponse> {
            return localVarFp.osConsoleAuthTokensIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/remote-consoles API
         * @param {ServersRemoteConsolesCreateRequest} [serversRemoteConsolesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdRemoteConsolesPost(serverId: string, serversRemoteConsolesCreateRequest?: ServersRemoteConsolesCreateRequest, options?: any): AxiosPromise<ServersRemoteConsolesCreateResponse> {
            return localVarFp.serversServerIdRemoteConsolesPost(serverId, serversRemoteConsolesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerConsolesApi - object-oriented interface
 * @export
 * @class ServerConsolesApi
 * @extends {BaseAPI}
 */
export class ServerConsolesApi extends BaseAPI {
    /**
     *  Until microversion 2\\.30, this API was available only for the rdp\\-html5 console type which has been removed along with the HyperV driver in the Nova 29\\.0\\.0 (Caracal) release. As this method is for microversion \\<\\=2\\.30, it will return an http 400 error. Starting from 2\\.31 microversion, this API works for all the supported console types that are handled by the separate show method defined below.
     * @param {string} id id parameter for /v2.1/os-console-auth-tokens/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServerConsolesApi
     */
    public osConsoleAuthTokensIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ServerConsolesApiFp(this.configuration).osConsoleAuthTokensIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/remote-consoles API
     * @param {ServersRemoteConsolesCreateRequest} [serversRemoteConsolesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerConsolesApi
     */
    public serversServerIdRemoteConsolesPost(serverId: string, serversRemoteConsolesCreateRequest?: ServersRemoteConsolesCreateRequest, options?: RawAxiosRequestConfig) {
        return ServerConsolesApiFp(this.configuration).serversServerIdRemoteConsolesPost(serverId, serversRemoteConsolesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerMigrationsApi - axios parameter creator
 * @export
 */
export const ServerMigrationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Return all migrations of an instance in progress.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMigrationsGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/migrations`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {ServersServerIdMigrationsIdActionPostRequest} [serversServerIdMigrationsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdActionPost: async (serverId: string, id: string, serversServerIdMigrationsIdActionPostRequest?: ServersServerIdMigrationsIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdActionPost', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdActionPost', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/migrations/{id}/action`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversServerIdMigrationsIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Abort an in progress migration of an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/migrations/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return the migration of an instance in progress by id.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMigrationsIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/migrations/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerMigrationsApi - functional programming interface
 * @export
 */
export const ServerMigrationsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerMigrationsApiAxiosParamCreator(configuration)
    return {
        /**
         *  Return all migrations of an instance in progress.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMigrationsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMigrationsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMigrationsGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerMigrationsApi.serversServerIdMigrationsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {ServersServerIdMigrationsIdActionPostRequest} [serversServerIdMigrationsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMigrationsIdActionPost(serverId: string, id: string, serversServerIdMigrationsIdActionPostRequest?: ServersServerIdMigrationsIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMigrationsIdActionPost(serverId, id, serversServerIdMigrationsIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerMigrationsApi.serversServerIdMigrationsIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Abort an in progress migration of an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMigrationsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMigrationsIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerMigrationsApi.serversServerIdMigrationsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return the migration of an instance in progress by id.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMigrationsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMigrationShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMigrationsIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerMigrationsApi.serversServerIdMigrationsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServerMigrationsApi - factory interface
 * @export
 */
export const ServerMigrationsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerMigrationsApiFp(configuration)
    return {
        /**
         *  Return all migrations of an instance in progress.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsGet(serverId: string, options?: any): AxiosPromise<ServersMigrationsListResponse> {
            return localVarFp.serversServerIdMigrationsGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
         * @param {ServersServerIdMigrationsIdActionPostRequest} [serversServerIdMigrationsIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdActionPost(serverId: string, id: string, serversServerIdMigrationsIdActionPostRequest?: ServersServerIdMigrationsIdActionPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdMigrationsIdActionPost(serverId, id, serversServerIdMigrationsIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Abort an in progress migration of an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdMigrationsIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return the migration of an instance in progress by id.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMigrationsIdGet(serverId: string, id: string, options?: any): AxiosPromise<ServersMigrationShowResponse> {
            return localVarFp.serversServerIdMigrationsIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerMigrationsApi - object-oriented interface
 * @export
 * @class ServerMigrationsApi
 * @extends {BaseAPI}
 */
export class ServerMigrationsApi extends BaseAPI {
    /**
     *  Return all migrations of an instance in progress.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerMigrationsApi
     */
    public serversServerIdMigrationsGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServerMigrationsApiFp(this.configuration).serversServerIdMigrationsGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id}/action API
     * @param {ServersServerIdMigrationsIdActionPostRequest} [serversServerIdMigrationsIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerMigrationsApi
     */
    public serversServerIdMigrationsIdActionPost(serverId: string, id: string, serversServerIdMigrationsIdActionPostRequest?: ServersServerIdMigrationsIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return ServerMigrationsApiFp(this.configuration).serversServerIdMigrationsIdActionPost(serverId, id, serversServerIdMigrationsIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Abort an in progress migration of an instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerMigrationsApi
     */
    public serversServerIdMigrationsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServerMigrationsApiFp(this.configuration).serversServerIdMigrationsIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return the migration of an instance in progress by id.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/migrations/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/migrations/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerMigrationsApi
     */
    public serversServerIdMigrationsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServerMigrationsApiFp(this.configuration).serversServerIdMigrationsIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServerTagsApi - axios parameter creator
 * @export
 */
export const ServerTagsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsDelete: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsDelete', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/tags`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/tags`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/tags/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/tags/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdPut: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsIdPut', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/tags/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {ServersTagsUpdateAll} [serversTagsUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsPut: async (serverId: string, serversTagsUpdateAll?: ServersTagsUpdateAll, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTagsPut', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/tags`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversTagsUpdateAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServerTagsApi - functional programming interface
 * @export
 */
export const ServerTagsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServerTagsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsDelete(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsDelete(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersTagsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsIdPut(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsIdPut(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {ServersTagsUpdateAll} [serversTagsUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTagsPut(serverId: string, serversTagsUpdateAll?: ServersTagsUpdateAll, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTagsPut(serverId, serversTagsUpdateAll, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServerTagsApi.serversServerIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServerTagsApi - factory interface
 * @export
 */
export const ServerTagsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServerTagsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsDelete(serverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdTagsDelete(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsGet(serverId: string, options?: any): AxiosPromise<ServersTagsListResponse> {
            return localVarFp.serversServerIdTagsGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdTagsIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdGet(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdTagsIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsIdPut(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdTagsIdPut(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
         * @param {ServersTagsUpdateAll} [serversTagsUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTagsPut(serverId: string, serversTagsUpdateAll?: ServersTagsUpdateAll, options?: any): AxiosPromise<ServersTagsUpdateAllResponse> {
            return localVarFp.serversServerIdTagsPut(serverId, serversTagsUpdateAll, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServerTagsApi - object-oriented interface
 * @export
 * @class ServerTagsApi
 * @extends {BaseAPI}
 */
export class ServerTagsApi extends BaseAPI {
    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsDelete(serverId: string, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsDelete(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsIdPut(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsIdPut(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/tags/{id} API
     * @param {ServersTagsUpdateAll} [serversTagsUpdateAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServerTagsApi
     */
    public serversServerIdTagsPut(serverId: string, serversTagsUpdateAll?: ServersTagsUpdateAll, options?: RawAxiosRequestConfig) {
        return ServerTagsApiFp(this.configuration).serversServerIdTagsPut(serverId, serversTagsUpdateAll, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServersApi - axios parameter creator
 * @export
 */
export const ServersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversDetailGet: async (userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/servers/detail`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (launchIndex !== undefined) {
                localVarQueryParameter['launch_index'] = launchIndex;
            }

            if (imageRef !== undefined) {
                localVarQueryParameter['image_ref'] = imageRef;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (kernelId !== undefined) {
                localVarQueryParameter['kernel_id'] = kernelId;
            }

            if (ramdiskId !== undefined) {
                localVarQueryParameter['ramdisk_id'] = ramdiskId;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (keyName !== undefined) {
                localVarQueryParameter['key_name'] = keyName;
            }

            if (powerState !== undefined) {
                localVarQueryParameter['power_state'] = powerState;
            }

            if (vmState !== undefined) {
                localVarQueryParameter['vm_state'] = vmState;
            }

            if (taskState !== undefined) {
                localVarQueryParameter['task_state'] = taskState;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (flavor !== undefined) {
                localVarQueryParameter['flavor'] = flavor;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (launchedAt !== undefined) {
                localVarQueryParameter['launched_at'] = launchedAt;
            }

            if (terminatedAt !== undefined) {
                localVarQueryParameter['terminated_at'] = terminatedAt;
            }

            if (availabilityZone !== undefined) {
                localVarQueryParameter['availability_zone'] = availabilityZone;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (displayDescription !== undefined) {
                localVarQueryParameter['display_description'] = displayDescription;
            }

            if (lockedBy !== undefined) {
                localVarQueryParameter['locked_by'] = lockedBy;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (rootDeviceName !== undefined) {
                localVarQueryParameter['root_device_name'] = rootDeviceName;
            }

            if (configDrive !== undefined) {
                localVarQueryParameter['config_drive'] = configDrive;
            }

            if (accessIpV4 !== undefined) {
                localVarQueryParameter['access_ip_v4'] = accessIpV4;
            }

            if (accessIpV6 !== undefined) {
                localVarQueryParameter['access_ip_v6'] = accessIpV6;
            }

            if (autoDiskConfig !== undefined) {
                localVarQueryParameter['auto_disk_config'] = autoDiskConfig;
            }

            if (progress !== undefined) {
                localVarQueryParameter['progress'] = progress;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (allTenants !== undefined) {
                localVarQueryParameter['all_tenants'] = allTenants;
            }

            if (softDeleted !== undefined) {
                localVarQueryParameter['soft_deleted'] = softDeleted;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (ip6 !== undefined) {
                localVarQueryParameter['ip6'] = ip6;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (blockDeviceMapping !== undefined) {
                localVarQueryParameter['block_device_mapping'] = blockDeviceMapping;
            }

            if (services !== undefined) {
                localVarQueryParameter['services'] = services;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (systemMetadata !== undefined) {
                localVarQueryParameter['system_metadata'] = systemMetadata;
            }

            if (infoCache !== undefined) {
                localVarQueryParameter['info_cache'] = infoCache;
            }

            if (securityGroups !== undefined) {
                localVarQueryParameter['security_groups'] = securityGroups;
            }

            if (pciDevices !== undefined) {
                localVarQueryParameter['pci_devices'] = pciDevices;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAny !== undefined) {
                localVarQueryParameter['tags-any'] = tagsAny;
            }

            if (notTags !== undefined) {
                localVarQueryParameter['not-tags'] = notTags;
            }

            if (notTagsAny !== undefined) {
                localVarQueryParameter['not-tags-any'] = notTagsAny;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversGet: async (userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (userId !== undefined) {
                localVarQueryParameter['user_id'] = userId;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (launchIndex !== undefined) {
                localVarQueryParameter['launch_index'] = launchIndex;
            }

            if (imageRef !== undefined) {
                localVarQueryParameter['image_ref'] = imageRef;
            }

            if (image !== undefined) {
                localVarQueryParameter['image'] = image;
            }

            if (kernelId !== undefined) {
                localVarQueryParameter['kernel_id'] = kernelId;
            }

            if (ramdiskId !== undefined) {
                localVarQueryParameter['ramdisk_id'] = ramdiskId;
            }

            if (hostname !== undefined) {
                localVarQueryParameter['hostname'] = hostname;
            }

            if (keyName !== undefined) {
                localVarQueryParameter['key_name'] = keyName;
            }

            if (powerState !== undefined) {
                localVarQueryParameter['power_state'] = powerState;
            }

            if (vmState !== undefined) {
                localVarQueryParameter['vm_state'] = vmState;
            }

            if (taskState !== undefined) {
                localVarQueryParameter['task_state'] = taskState;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (node !== undefined) {
                localVarQueryParameter['node'] = node;
            }

            if (flavor !== undefined) {
                localVarQueryParameter['flavor'] = flavor;
            }

            if (reservationId !== undefined) {
                localVarQueryParameter['reservation_id'] = reservationId;
            }

            if (launchedAt !== undefined) {
                localVarQueryParameter['launched_at'] = launchedAt;
            }

            if (terminatedAt !== undefined) {
                localVarQueryParameter['terminated_at'] = terminatedAt;
            }

            if (availabilityZone !== undefined) {
                localVarQueryParameter['availability_zone'] = availabilityZone;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (displayName !== undefined) {
                localVarQueryParameter['display_name'] = displayName;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (displayDescription !== undefined) {
                localVarQueryParameter['display_description'] = displayDescription;
            }

            if (lockedBy !== undefined) {
                localVarQueryParameter['locked_by'] = lockedBy;
            }

            if (uuid !== undefined) {
                localVarQueryParameter['uuid'] = uuid;
            }

            if (rootDeviceName !== undefined) {
                localVarQueryParameter['root_device_name'] = rootDeviceName;
            }

            if (configDrive !== undefined) {
                localVarQueryParameter['config_drive'] = configDrive;
            }

            if (accessIpV4 !== undefined) {
                localVarQueryParameter['access_ip_v4'] = accessIpV4;
            }

            if (accessIpV6 !== undefined) {
                localVarQueryParameter['access_ip_v6'] = accessIpV6;
            }

            if (autoDiskConfig !== undefined) {
                localVarQueryParameter['auto_disk_config'] = autoDiskConfig;
            }

            if (progress !== undefined) {
                localVarQueryParameter['progress'] = progress;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (allTenants !== undefined) {
                localVarQueryParameter['all_tenants'] = allTenants;
            }

            if (softDeleted !== undefined) {
                localVarQueryParameter['soft_deleted'] = softDeleted;
            }

            if (deleted !== undefined) {
                localVarQueryParameter['deleted'] = deleted;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (ip !== undefined) {
                localVarQueryParameter['ip'] = ip;
            }

            if (ip6 !== undefined) {
                localVarQueryParameter['ip6'] = ip6;
            }

            if (createdAt !== undefined) {
                localVarQueryParameter['created_at'] = createdAt;
            }

            if (blockDeviceMapping !== undefined) {
                localVarQueryParameter['block_device_mapping'] = blockDeviceMapping;
            }

            if (services !== undefined) {
                localVarQueryParameter['services'] = services;
            }

            if (metadata !== undefined) {
                localVarQueryParameter['metadata'] = metadata;
            }

            if (systemMetadata !== undefined) {
                localVarQueryParameter['system_metadata'] = systemMetadata;
            }

            if (infoCache !== undefined) {
                localVarQueryParameter['info_cache'] = infoCache;
            }

            if (securityGroups !== undefined) {
                localVarQueryParameter['security_groups'] = securityGroups;
            }

            if (pciDevices !== undefined) {
                localVarQueryParameter['pci_devices'] = pciDevices;
            }

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (tags !== undefined) {
                localVarQueryParameter['tags'] = tags;
            }

            if (tagsAny !== undefined) {
                localVarQueryParameter['tags-any'] = tagsAny;
            }

            if (notTags !== undefined) {
                localVarQueryParameter['not-tags'] = notTags;
            }

            if (notTagsAny !== undefined) {
                localVarQueryParameter['not-tags-any'] = notTagsAny;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }

            if (locked !== undefined) {
                localVarQueryParameter['locked'] = locked;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/servers/{id}/action API
         * @param {ServersIdActionPostRequest} [serversIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdActionPost: async (id: string, serversIdActionPostRequest?: ServersIdActionPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversIdActionPost', 'id', id)
            const localVarPath = `/v2.1/servers/{id}/action`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversIdActionPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {ServerUpdateRequest} [serverUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdPut: async (id: string, serverUpdateRequest?: ServerUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversIdPut', 'id', id)
            const localVarPath = `/v2.1/servers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serverUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Creates a new server for a given user.
         * @param {ServersCreateRequest} [serversCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversPost: async (serversCreateRequest?: ServersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/servers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdConsolesGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/consoles`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdConsolesIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdConsolesIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/consoles/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdConsolesIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdConsolesIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/consoles/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesPost: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdConsolesPost', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/consoles`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/diagnostics API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdDiagnosticsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdDiagnosticsGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/diagnostics`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdIpsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdIpsGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/ips`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdIpsIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdIpsIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdIpsIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/ips/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/metadata`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Deletes an existing metadata.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMetadataIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/metadata/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return a single metadata item.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMetadataIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/metadata/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdate} [serversMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdPut: async (serverId: string, id: string, serversMetadataUpdate?: ServersMetadataUpdate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataIdPut', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdMetadataIdPut', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/metadata/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversMetadataUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataCreate} [serversMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataPost: async (serverId: string, serversMetadataCreate?: ServersMetadataCreate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataPost', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/metadata`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversMetadataCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdateAll} [serversMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataPut: async (serverId: string, serversMetadataUpdateAll?: ServersMetadataUpdateAll, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdMetadataPut', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/metadata`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversMetadataUpdateAll, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of actions recorded for a given instance.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdOsInstanceActionsGet: async (limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/servers/{server_id}/os-instance-actions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (changesSince !== undefined) {
                localVarQueryParameter['changes-since'] = (changesSince as any instanceof Date) ?
                    (changesSince as any).toISOString() :
                    changesSince;
            }

            if (changesBefore !== undefined) {
                localVarQueryParameter['changes-before'] = (changesBefore as any instanceof Date) ?
                    (changesBefore as any).toISOString() :
                    changesBefore;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given instance action.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInstanceActionsIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsInstanceActionsIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsInstanceActionsIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-instance-actions/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of interface attachments for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsInterfaceGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-interface`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Detach an interface from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsInterfaceIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsInterfaceIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-interface/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given interface attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsInterfaceIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsInterfaceIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-interface/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Attach an interface to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {ServersOsInterfaceCreateRequest} [serversOsInterfaceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfacePost: async (serverId: string, serversOsInterfaceCreateRequest?: ServersOsInterfaceCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsInterfacePost', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-interface`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversOsInterfaceCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns a list of security groups for the given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-security-groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsSecurityGroupsGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsSecurityGroupsGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-security-groups`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Removes the encrypted server password from the metadata server   Note that this does not actually change the instance server password.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsServerPasswordDelete: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsServerPasswordDelete', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-server-password`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsServerPasswordGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsServerPasswordGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-server-password`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-virtual-interfaces API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdOsVirtualInterfacesGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsVirtualInterfacesGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-virtual-interfaces`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Returns the list of volume attachments for a given instance.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsGet: async (limit?: number | string, offset?: number | string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/servers/{server_id}/os-volume_attachments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (limit !== undefined) {
                for (const [key, value] of Object.entries(limit)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (offset !== undefined) {
                for (const [key, value] of Object.entries(offset)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Detach a volume from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdDelete: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdDelete', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdDelete', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-volume_attachments/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Return data about the given volume attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdGet: async (serverId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdGet', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdGet', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-volume_attachments/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentUpdateRequest} [serversOsVolumeAttachmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdPut: async (serverId: string, id: string, serversOsVolumeAttachmentUpdateRequest?: ServersOsVolumeAttachmentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdPut', 'serverId', serverId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsIdPut', 'id', id)
            const localVarPath = `/v2.1/servers/{server_id}/os-volume_attachments/{id}`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversOsVolumeAttachmentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         *  Attach a volume to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentsCreateRequest} [serversOsVolumeAttachmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsPost: async (serverId: string, serversOsVolumeAttachmentsCreateRequest?: ServersOsVolumeAttachmentsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdOsVolumeAttachmentsPost', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/os-volume_attachments`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serversOsVolumeAttachmentsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/topology API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTopologyGet: async (serverId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serverId' is not null or undefined
            assertParamExists('serversServerIdTopologyGet', 'serverId', serverId)
            const localVarPath = `/v2.1/servers/{server_id}/topology`
                .replace(`{${"server_id"}}`, encodeURIComponent(String(serverId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServersApi - functional programming interface
 * @export
 */
export const ServersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServersApiAxiosParamCreator(configuration)
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersDetailResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversDetailGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/servers/{id}/action API
         * @param {ServersIdActionPostRequest} [serversIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversIdActionPost(id: string, serversIdActionPostRequest?: ServersIdActionPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersIdActionPost201Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversIdActionPost(id, serversIdActionPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversIdActionPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {ServerUpdateRequest} [serverUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversIdPut(id: string, serverUpdateRequest?: ServerUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServerUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversIdPut(id, serverUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Creates a new server for a given user.
         * @param {ServersCreateRequest} [serversCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversPost(serversCreateRequest?: ServersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversPost(serversCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdConsolesGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdConsolesGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdConsolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdConsolesIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdConsolesIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdConsolesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdConsolesIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdConsolesIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdConsolesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdConsolesPost(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdConsolesPost(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdConsolesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/diagnostics API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdDiagnosticsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersDiagnosticsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdDiagnosticsGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdDiagnosticsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdIpsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersIpsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdIpsGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdIpsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdIpsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdIpsIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdIpsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMetadataListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Deletes an existing metadata.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return a single metadata item.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMetadataShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdate} [serversMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataIdPut(serverId: string, id: string, serversMetadataUpdate?: ServersMetadataUpdate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataIdPut(serverId, id, serversMetadataUpdate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataCreate} [serversMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataPost(serverId: string, serversMetadataCreate?: ServersMetadataCreate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMetadataCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataPost(serverId, serversMetadataCreate, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdateAll} [serversMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdMetadataPut(serverId: string, serversMetadataUpdateAll?: ServersMetadataUpdateAll, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersMetadataUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdMetadataPut(serverId, serversMetadataUpdateAll, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdMetadataPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of actions recorded for a given instance.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdOsInstanceActionsGet(limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsInstanceActionsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInstanceActionsGet(limit, marker, changesSince, changesBefore, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInstanceActionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given instance action.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsInstanceActionsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsInstanceActionShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInstanceActionsIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInstanceActionsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of interface attachments for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsInterfaceGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsInterfaceListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInterfaceGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInterfaceGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Detach an interface from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsInterfaceIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInterfaceIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInterfaceIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given interface attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsInterfaceIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsInterfaceShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInterfaceIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInterfaceIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Attach an interface to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {ServersOsInterfaceCreateRequest} [serversOsInterfaceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsInterfacePost(serverId: string, serversOsInterfaceCreateRequest?: ServersOsInterfaceCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsInterfaceCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsInterfacePost(serverId, serversOsInterfaceCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsInterfacePost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns a list of security groups for the given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-security-groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsSecurityGroupsGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsSecurityGroupsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsSecurityGroupsGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsSecurityGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Removes the encrypted server password from the metadata server   Note that this does not actually change the instance server password.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsServerPasswordDelete(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsServerPasswordDelete(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsServerPasswordDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsServerPasswordGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsServerPasswordListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsServerPasswordGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsServerPasswordGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-virtual-interfaces API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async serversServerIdOsVirtualInterfacesGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVirtualInterfacesGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVirtualInterfacesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Returns the list of volume attachments for a given instance.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsVolumeAttachmentsGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsVolumeAttachmentsListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVolumeAttachmentsGet(limit, offset, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVolumeAttachmentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Detach a volume from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsVolumeAttachmentsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVolumeAttachmentsIdDelete(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVolumeAttachmentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Return data about the given volume attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsVolumeAttachmentsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsVolumeAttachmentShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVolumeAttachmentsIdGet(serverId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVolumeAttachmentsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentUpdateRequest} [serversOsVolumeAttachmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsVolumeAttachmentsIdPut(serverId: string, id: string, serversOsVolumeAttachmentUpdateRequest?: ServersOsVolumeAttachmentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsVolumeAttachmentUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVolumeAttachmentsIdPut(serverId, id, serversOsVolumeAttachmentUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVolumeAttachmentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         *  Attach a volume to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentsCreateRequest} [serversOsVolumeAttachmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdOsVolumeAttachmentsPost(serverId: string, serversOsVolumeAttachmentsCreateRequest?: ServersOsVolumeAttachmentsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersOsVolumeAttachmentsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdOsVolumeAttachmentsPost(serverId, serversOsVolumeAttachmentsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdOsVolumeAttachmentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/topology API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serversServerIdTopologyGet(serverId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServersTopologyListResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serversServerIdTopologyGet(serverId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServersApi.serversServerIdTopologyGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServersApi - factory interface
 * @export
 */
export const ServersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServersApiFp(configuration)
    return {
        /**
         *  Returns a list of server details for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersDetailGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: any): AxiosPromise<ServersDetailResponse> {
            return localVarFp.serversDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a list of server names and ids for a given user.
         * @param {string} [userId] 
         * @param {string} [projectId] 
         * @param {string} [tenantId] 
         * @param {string} [launchIndex] 
         * @param {string} [imageRef] 
         * @param {string} [image] 
         * @param {string} [kernelId] 
         * @param {string} [ramdiskId] 
         * @param {string} [hostname] 
         * @param {string} [keyName] 
         * @param {string} [powerState] 
         * @param {string} [vmState] 
         * @param {string} [taskState] 
         * @param {string} [host] 
         * @param {string} [node] 
         * @param {string} [flavor] 
         * @param {string} [reservationId] 
         * @param {string} [launchedAt] 
         * @param {string} [terminatedAt] 
         * @param {string} [availabilityZone] 
         * @param {string} [name] 
         * @param {string} [displayName] 
         * @param {string} [description] 
         * @param {string} [displayDescription] 
         * @param {string} [lockedBy] 
         * @param {string} [uuid] 
         * @param {string} [rootDeviceName] 
         * @param {string} [configDrive] 
         * @param {string} [accessIpV4] 
         * @param {string} [accessIpV6] 
         * @param {string} [autoDiskConfig] 
         * @param {string} [progress] 
         * @param {ServersGetSortKeyEnum} [sortKey] 
         * @param {string} [sortDir] 
         * @param {string} [allTenants] 
         * @param {string} [softDeleted] 
         * @param {string} [deleted] 
         * @param {string} [status] 
         * @param {string} [changesSince] 
         * @param {string} [ip] 
         * @param {string} [ip6] 
         * @param {string} [createdAt] 
         * @param {string} [blockDeviceMapping] 
         * @param {string} [services] 
         * @param {string} [metadata] 
         * @param {string} [systemMetadata] 
         * @param {string} [infoCache] 
         * @param {string} [securityGroups] 
         * @param {string} [pciDevices] 
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [tags] 
         * @param {string} [tagsAny] 
         * @param {string} [notTags] 
         * @param {string} [notTagsAny] 
         * @param {string} [changesBefore] 
         * @param {string} [locked] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: any): AxiosPromise<ServersListResponse> {
            return localVarFp.serversGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/servers/{id}/action API
         * @param {ServersIdActionPostRequest} [serversIdActionPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdActionPost(id: string, serversIdActionPostRequest?: ServersIdActionPostRequest, options?: any): AxiosPromise<ServersIdActionPost201Response> {
            return localVarFp.serversIdActionPost(id, serversIdActionPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Destroys a server.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns server details by server id.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdGet(id: string, options?: any): AxiosPromise<ServerShowResponse> {
            return localVarFp.serversIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Update server then pass on to version\\-specific controller.
         * @param {string} id id parameter for /v2.1/servers/{id} API
         * @param {ServerUpdateRequest} [serverUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversIdPut(id: string, serverUpdateRequest?: ServerUpdateRequest, options?: any): AxiosPromise<ServerUpdateResponse> {
            return localVarFp.serversIdPut(id, serverUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Creates a new server for a given user.
         * @param {ServersCreateRequest} [serversCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversPost(serversCreateRequest?: ServersCreateRequest, options?: any): AxiosPromise<ServersCreateResponse> {
            return localVarFp.serversPost(serversCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesGet(serverId: string, options?: any): AxiosPromise<any> {
            return localVarFp.serversServerIdConsolesGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdConsolesIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesIdGet(serverId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.serversServerIdConsolesIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdConsolesPost(serverId: string, options?: any): AxiosPromise<any> {
            return localVarFp.serversServerIdConsolesPost(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/diagnostics API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdDiagnosticsGet(serverId: string, options?: any): AxiosPromise<ServersDiagnosticsListResponse> {
            return localVarFp.serversServerIdDiagnosticsGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdIpsGet(serverId: string, options?: any): AxiosPromise<ServersIpsListResponse> {
            return localVarFp.serversServerIdIpsGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdIpsIdGet(serverId: string, id: string, options?: any): AxiosPromise<{ [key: string]: any; }> {
            return localVarFp.serversServerIdIpsIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of metadata for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataGet(serverId: string, options?: any): AxiosPromise<ServersMetadataListResponse> {
            return localVarFp.serversServerIdMetadataGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Deletes an existing metadata.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdMetadataIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return a single metadata item.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdGet(serverId: string, id: string, options?: any): AxiosPromise<ServersMetadataShowResponse> {
            return localVarFp.serversServerIdMetadataIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdate} [serversMetadataUpdate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataIdPut(serverId: string, id: string, serversMetadataUpdate?: ServersMetadataUpdate, options?: any): AxiosPromise<any> {
            return localVarFp.serversServerIdMetadataIdPut(serverId, id, serversMetadataUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataCreate} [serversMetadataCreate] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataPost(serverId: string, serversMetadataCreate?: ServersMetadataCreate, options?: any): AxiosPromise<ServersMetadataCreateResponse> {
            return localVarFp.serversServerIdMetadataPost(serverId, serversMetadataCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
         * @param {ServersMetadataUpdateAll} [serversMetadataUpdateAll] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdMetadataPut(serverId: string, serversMetadataUpdateAll?: ServersMetadataUpdateAll, options?: any): AxiosPromise<ServersMetadataUpdateAllResponse> {
            return localVarFp.serversServerIdMetadataPut(serverId, serversMetadataUpdateAll, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of actions recorded for a given instance.
         * @param {number | string} [limit] 
         * @param {string} [marker] 
         * @param {string} [changesSince] 
         * @param {string} [changesBefore] 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdOsInstanceActionsGet(limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, options?: any): AxiosPromise<ServersOsInstanceActionsListResponse> {
            return localVarFp.serversServerIdOsInstanceActionsGet(limit, marker, changesSince, changesBefore, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given instance action.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInstanceActionsIdGet(serverId: string, id: string, options?: any): AxiosPromise<ServersOsInstanceActionShowResponse> {
            return localVarFp.serversServerIdOsInstanceActionsIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of interface attachments for a given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceGet(serverId: string, options?: any): AxiosPromise<ServersOsInterfaceListResponse> {
            return localVarFp.serversServerIdOsInterfaceGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Detach an interface from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdOsInterfaceIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given interface attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfaceIdGet(serverId: string, id: string, options?: any): AxiosPromise<ServersOsInterfaceShowResponse> {
            return localVarFp.serversServerIdOsInterfaceIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Attach an interface to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
         * @param {ServersOsInterfaceCreateRequest} [serversOsInterfaceCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsInterfacePost(serverId: string, serversOsInterfaceCreateRequest?: ServersOsInterfaceCreateRequest, options?: any): AxiosPromise<ServersOsInterfaceCreateResponse> {
            return localVarFp.serversServerIdOsInterfacePost(serverId, serversOsInterfaceCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns a list of security groups for the given instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-security-groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsSecurityGroupsGet(serverId: string, options?: any): AxiosPromise<ServersOsSecurityGroupsListResponse> {
            return localVarFp.serversServerIdOsSecurityGroupsGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Removes the encrypted server password from the metadata server   Note that this does not actually change the instance server password.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsServerPasswordDelete(serverId: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdOsServerPasswordDelete(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsServerPasswordGet(serverId: string, options?: any): AxiosPromise<ServersOsServerPasswordListResponse> {
            return localVarFp.serversServerIdOsServerPasswordGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-virtual-interfaces API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        serversServerIdOsVirtualInterfacesGet(serverId: string, options?: any): AxiosPromise<any> {
            return localVarFp.serversServerIdOsVirtualInterfacesGet(serverId, options).then((request) => request(axios, basePath));
        },
        /**
         *  Returns the list of volume attachments for a given instance.
         * @param {number | string} [limit] 
         * @param {number | string} [offset] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsGet(limit?: number | string, offset?: number | string, options?: any): AxiosPromise<ServersOsVolumeAttachmentsListResponse> {
            return localVarFp.serversServerIdOsVolumeAttachmentsGet(limit, offset, options).then((request) => request(axios, basePath));
        },
        /**
         *  Detach a volume from an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdDelete(serverId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serversServerIdOsVolumeAttachmentsIdDelete(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         *  Return data about the given volume attachment.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdGet(serverId: string, id: string, options?: any): AxiosPromise<ServersOsVolumeAttachmentShowResponse> {
            return localVarFp.serversServerIdOsVolumeAttachmentsIdGet(serverId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentUpdateRequest} [serversOsVolumeAttachmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsIdPut(serverId: string, id: string, serversOsVolumeAttachmentUpdateRequest?: ServersOsVolumeAttachmentUpdateRequest, options?: any): AxiosPromise<ServersOsVolumeAttachmentUpdateResponse> {
            return localVarFp.serversServerIdOsVolumeAttachmentsIdPut(serverId, id, serversOsVolumeAttachmentUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         *  Attach a volume to an instance.
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
         * @param {ServersOsVolumeAttachmentsCreateRequest} [serversOsVolumeAttachmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdOsVolumeAttachmentsPost(serverId: string, serversOsVolumeAttachmentsCreateRequest?: ServersOsVolumeAttachmentsCreateRequest, options?: any): AxiosPromise<ServersOsVolumeAttachmentsCreateResponse> {
            return localVarFp.serversServerIdOsVolumeAttachmentsPost(serverId, serversOsVolumeAttachmentsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/topology API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serversServerIdTopologyGet(serverId: string, options?: any): AxiosPromise<ServersTopologyListResponse> {
            return localVarFp.serversServerIdTopologyGet(serverId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServersApi - object-oriented interface
 * @export
 * @class ServersApi
 * @extends {BaseAPI}
 */
export class ServersApi extends BaseAPI {
    /**
     *  Returns a list of server details for a given user.
     * @param {string} [userId] 
     * @param {string} [projectId] 
     * @param {string} [tenantId] 
     * @param {string} [launchIndex] 
     * @param {string} [imageRef] 
     * @param {string} [image] 
     * @param {string} [kernelId] 
     * @param {string} [ramdiskId] 
     * @param {string} [hostname] 
     * @param {string} [keyName] 
     * @param {string} [powerState] 
     * @param {string} [vmState] 
     * @param {string} [taskState] 
     * @param {string} [host] 
     * @param {string} [node] 
     * @param {string} [flavor] 
     * @param {string} [reservationId] 
     * @param {string} [launchedAt] 
     * @param {string} [terminatedAt] 
     * @param {string} [availabilityZone] 
     * @param {string} [name] 
     * @param {string} [displayName] 
     * @param {string} [description] 
     * @param {string} [displayDescription] 
     * @param {string} [lockedBy] 
     * @param {string} [uuid] 
     * @param {string} [rootDeviceName] 
     * @param {string} [configDrive] 
     * @param {string} [accessIpV4] 
     * @param {string} [accessIpV6] 
     * @param {string} [autoDiskConfig] 
     * @param {string} [progress] 
     * @param {ServersDetailGetSortKeyEnum} [sortKey] 
     * @param {string} [sortDir] 
     * @param {string} [allTenants] 
     * @param {string} [softDeleted] 
     * @param {string} [deleted] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [ip] 
     * @param {string} [ip6] 
     * @param {string} [createdAt] 
     * @param {string} [blockDeviceMapping] 
     * @param {string} [services] 
     * @param {string} [metadata] 
     * @param {string} [systemMetadata] 
     * @param {string} [infoCache] 
     * @param {string} [securityGroups] 
     * @param {string} [pciDevices] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [tags] 
     * @param {string} [tagsAny] 
     * @param {string} [notTags] 
     * @param {string} [notTagsAny] 
     * @param {string} [changesBefore] 
     * @param {string} [locked] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversDetailGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersDetailGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversDetailGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a list of server names and ids for a given user.
     * @param {string} [userId] 
     * @param {string} [projectId] 
     * @param {string} [tenantId] 
     * @param {string} [launchIndex] 
     * @param {string} [imageRef] 
     * @param {string} [image] 
     * @param {string} [kernelId] 
     * @param {string} [ramdiskId] 
     * @param {string} [hostname] 
     * @param {string} [keyName] 
     * @param {string} [powerState] 
     * @param {string} [vmState] 
     * @param {string} [taskState] 
     * @param {string} [host] 
     * @param {string} [node] 
     * @param {string} [flavor] 
     * @param {string} [reservationId] 
     * @param {string} [launchedAt] 
     * @param {string} [terminatedAt] 
     * @param {string} [availabilityZone] 
     * @param {string} [name] 
     * @param {string} [displayName] 
     * @param {string} [description] 
     * @param {string} [displayDescription] 
     * @param {string} [lockedBy] 
     * @param {string} [uuid] 
     * @param {string} [rootDeviceName] 
     * @param {string} [configDrive] 
     * @param {string} [accessIpV4] 
     * @param {string} [accessIpV6] 
     * @param {string} [autoDiskConfig] 
     * @param {string} [progress] 
     * @param {ServersGetSortKeyEnum} [sortKey] 
     * @param {string} [sortDir] 
     * @param {string} [allTenants] 
     * @param {string} [softDeleted] 
     * @param {string} [deleted] 
     * @param {string} [status] 
     * @param {string} [changesSince] 
     * @param {string} [ip] 
     * @param {string} [ip6] 
     * @param {string} [createdAt] 
     * @param {string} [blockDeviceMapping] 
     * @param {string} [services] 
     * @param {string} [metadata] 
     * @param {string} [systemMetadata] 
     * @param {string} [infoCache] 
     * @param {string} [securityGroups] 
     * @param {string} [pciDevices] 
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [tags] 
     * @param {string} [tagsAny] 
     * @param {string} [notTags] 
     * @param {string} [notTagsAny] 
     * @param {string} [changesBefore] 
     * @param {string} [locked] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversGet(userId?: string, projectId?: string, tenantId?: string, launchIndex?: string, imageRef?: string, image?: string, kernelId?: string, ramdiskId?: string, hostname?: string, keyName?: string, powerState?: string, vmState?: string, taskState?: string, host?: string, node?: string, flavor?: string, reservationId?: string, launchedAt?: string, terminatedAt?: string, availabilityZone?: string, name?: string, displayName?: string, description?: string, displayDescription?: string, lockedBy?: string, uuid?: string, rootDeviceName?: string, configDrive?: string, accessIpV4?: string, accessIpV6?: string, autoDiskConfig?: string, progress?: string, sortKey?: ServersGetSortKeyEnum, sortDir?: string, allTenants?: string, softDeleted?: string, deleted?: string, status?: string, changesSince?: string, ip?: string, ip6?: string, createdAt?: string, blockDeviceMapping?: string, services?: string, metadata?: string, systemMetadata?: string, infoCache?: string, securityGroups?: string, pciDevices?: string, limit?: number | string, marker?: string, tags?: string, tagsAny?: string, notTags?: string, notTagsAny?: string, changesBefore?: string, locked?: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversGet(userId, projectId, tenantId, launchIndex, imageRef, image, kernelId, ramdiskId, hostname, keyName, powerState, vmState, taskState, host, node, flavor, reservationId, launchedAt, terminatedAt, availabilityZone, name, displayName, description, displayDescription, lockedBy, uuid, rootDeviceName, configDrive, accessIpV4, accessIpV6, autoDiskConfig, progress, sortKey, sortDir, allTenants, softDeleted, deleted, status, changesSince, ip, ip6, createdAt, blockDeviceMapping, services, metadata, systemMetadata, infoCache, securityGroups, pciDevices, limit, marker, tags, tagsAny, notTags, notTagsAny, changesBefore, locked, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/servers/{id}/action API
     * @param {ServersIdActionPostRequest} [serversIdActionPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversIdActionPost(id: string, serversIdActionPostRequest?: ServersIdActionPostRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversIdActionPost(id, serversIdActionPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Destroys a server.
     * @param {string} id id parameter for /v2.1/servers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns server details by server id.
     * @param {string} id id parameter for /v2.1/servers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Update server then pass on to version\\-specific controller.
     * @param {string} id id parameter for /v2.1/servers/{id} API
     * @param {ServerUpdateRequest} [serverUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversIdPut(id: string, serverUpdateRequest?: ServerUpdateRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversIdPut(id, serverUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Creates a new server for a given user.
     * @param {ServersCreateRequest} [serversCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversPost(serversCreateRequest?: ServersCreateRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversPost(serversCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdConsolesGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdConsolesGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdConsolesIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdConsolesIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdConsolesIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdConsolesIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/consoles/{id} API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdConsolesPost(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdConsolesPost(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/diagnostics API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdDiagnosticsGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdDiagnosticsGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdIpsGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdIpsGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/ips/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/ips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdIpsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdIpsIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of metadata for a given instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Deletes an existing metadata.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return a single metadata item.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {ServersMetadataUpdate} [serversMetadataUpdate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataIdPut(serverId: string, id: string, serversMetadataUpdate?: ServersMetadataUpdate, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataIdPut(serverId, id, serversMetadataUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {ServersMetadataCreate} [serversMetadataCreate] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataPost(serverId: string, serversMetadataCreate?: ServersMetadataCreate, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataPost(serverId, serversMetadataCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/metadata/{id} API
     * @param {ServersMetadataUpdateAll} [serversMetadataUpdateAll] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdMetadataPut(serverId: string, serversMetadataUpdateAll?: ServersMetadataUpdateAll, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdMetadataPut(serverId, serversMetadataUpdateAll, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of actions recorded for a given instance.
     * @param {number | string} [limit] 
     * @param {string} [marker] 
     * @param {string} [changesSince] 
     * @param {string} [changesBefore] 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInstanceActionsGet(limit?: number | string, marker?: string, changesSince?: string, changesBefore?: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInstanceActionsGet(limit, marker, changesSince, changesBefore, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given instance action.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-instance-actions/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInstanceActionsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInstanceActionsIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of interface attachments for a given instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInterfaceGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInterfaceGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Detach an interface from an instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInterfaceIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInterfaceIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given interface attachment.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInterfaceIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInterfaceIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Attach an interface to an instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-interface/{id} API
     * @param {ServersOsInterfaceCreateRequest} [serversOsInterfaceCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsInterfacePost(serverId: string, serversOsInterfaceCreateRequest?: ServersOsInterfaceCreateRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsInterfacePost(serverId, serversOsInterfaceCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns a list of security groups for the given instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-security-groups API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsSecurityGroupsGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsSecurityGroupsGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Removes the encrypted server password from the metadata server   Note that this does not actually change the instance server password.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsServerPasswordDelete(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsServerPasswordDelete(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-server-password API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsServerPasswordGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsServerPasswordGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-virtual-interfaces API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVirtualInterfacesGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVirtualInterfacesGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Returns the list of volume attachments for a given instance.
     * @param {number | string} [limit] 
     * @param {number | string} [offset] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVolumeAttachmentsGet(limit?: number | string, offset?: number | string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVolumeAttachmentsGet(limit, offset, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Detach a volume from an instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVolumeAttachmentsIdDelete(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVolumeAttachmentsIdDelete(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Return data about the given volume attachment.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVolumeAttachmentsIdGet(serverId: string, id: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVolumeAttachmentsIdGet(serverId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {string} id id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {ServersOsVolumeAttachmentUpdateRequest} [serversOsVolumeAttachmentUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVolumeAttachmentsIdPut(serverId: string, id: string, serversOsVolumeAttachmentUpdateRequest?: ServersOsVolumeAttachmentUpdateRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVolumeAttachmentsIdPut(serverId, id, serversOsVolumeAttachmentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     *  Attach a volume to an instance.
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/os-volume_attachments/{id} API
     * @param {ServersOsVolumeAttachmentsCreateRequest} [serversOsVolumeAttachmentsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdOsVolumeAttachmentsPost(serverId: string, serversOsVolumeAttachmentsCreateRequest?: ServersOsVolumeAttachmentsCreateRequest, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdOsVolumeAttachmentsPost(serverId, serversOsVolumeAttachmentsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} serverId server_id parameter for /v2.1/servers/{server_id}/topology API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServersApi
     */
    public serversServerIdTopologyGet(serverId: string, options?: RawAxiosRequestConfig) {
        return ServersApiFp(this.configuration).serversServerIdTopologyGet(serverId, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ServersDetailGetSortKeyEnum = {
    DisplayDescription: 'display_description',
    InstanceTypeId: 'instance_type_id',
    DisplayName: 'display_name',
    LaunchIndex: 'launch_index',
    AccessIpV6: 'access_ip_v6',
    TerminatedAt: 'terminated_at',
    VmState: 'vm_state',
    ProjectId: 'project_id',
    UserId: 'user_id',
    KernelId: 'kernel_id',
    Uuid: 'uuid',
    TaskState: 'task_state',
    ImageRef: 'image_ref',
    AutoDiskConfig: 'auto_disk_config',
    PowerState: 'power_state',
    KeyName: 'key_name',
    Host: 'host',
    Node: 'node',
    AvailabilityZone: 'availability_zone',
    LockedBy: 'locked_by',
    RootDeviceName: 'root_device_name',
    CreatedAt: 'created_at',
    RamdiskId: 'ramdisk_id',
    LaunchedAt: 'launched_at',
    AccessIpV4: 'access_ip_v4',
    Progress: 'progress',
    Locked: 'locked',
    UpdatedAt: 'updated_at',
    Hostname: 'hostname',
    ConfigDrive: 'config_drive'
} as const;
export type ServersDetailGetSortKeyEnum = typeof ServersDetailGetSortKeyEnum[keyof typeof ServersDetailGetSortKeyEnum];
/**
 * @export
 */
export const ServersGetSortKeyEnum = {
    DisplayDescription: 'display_description',
    InstanceTypeId: 'instance_type_id',
    DisplayName: 'display_name',
    LaunchIndex: 'launch_index',
    AccessIpV6: 'access_ip_v6',
    TerminatedAt: 'terminated_at',
    VmState: 'vm_state',
    ProjectId: 'project_id',
    UserId: 'user_id',
    KernelId: 'kernel_id',
    Uuid: 'uuid',
    TaskState: 'task_state',
    ImageRef: 'image_ref',
    AutoDiskConfig: 'auto_disk_config',
    PowerState: 'power_state',
    KeyName: 'key_name',
    Host: 'host',
    Node: 'node',
    AvailabilityZone: 'availability_zone',
    LockedBy: 'locked_by',
    RootDeviceName: 'root_device_name',
    CreatedAt: 'created_at',
    RamdiskId: 'ramdisk_id',
    LaunchedAt: 'launched_at',
    AccessIpV4: 'access_ip_v4',
    Progress: 'progress',
    Locked: 'locked',
    UpdatedAt: 'updated_at',
    Hostname: 'hostname',
    ConfigDrive: 'config_drive'
} as const;
export type ServersGetSortKeyEnum = typeof ServersGetSortKeyEnum[keyof typeof ServersGetSortKeyEnum];


/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.1/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/versions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('versionsIdGet', 'id', id)
            const localVarPath = `/v2.1/versions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.get(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VersionApi.get']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/versions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VersionApi.versionsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        get(options?: any): AxiosPromise<object> {
            return localVarFp.get(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.1/versions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsIdGet(id: string, options?: any): AxiosPromise<object> {
            return localVarFp.versionsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public get(options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.1/versions/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public versionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).versionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



