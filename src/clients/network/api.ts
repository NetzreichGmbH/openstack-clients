/* tslint:disable */
/* eslint-disable */
/**
 * OpenStack Network API
 * Network API provided by Neutron service
 *
 * The version of the OpenAPI document: 2.25
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * Response of the address-groups/id:get operation
 * @export
 * @interface AddressGroupShowResponse
 */
export interface AddressGroupShowResponse {
    /**
     * 
     * @type {AddressGroupsCreateResponseAddressGroup}
     * @memberof AddressGroupShowResponse
     */
    'address_group'?: AddressGroupsCreateResponseAddressGroup;
}
/**
 * Request of the address-groups/id:put operation
 * @export
 * @interface AddressGroupUpdateRequest
 */
export interface AddressGroupUpdateRequest {
    /**
     * 
     * @type {AddressGroupUpdateRequestAddressGroup}
     * @memberof AddressGroupUpdateRequest
     */
    'address_group'?: AddressGroupUpdateRequestAddressGroup;
}
/**
 * 
 * @export
 * @interface AddressGroupUpdateRequestAddressGroup
 */
export interface AddressGroupUpdateRequestAddressGroup {
    /**
     * 
     * @type {string}
     * @memberof AddressGroupUpdateRequestAddressGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupUpdateRequestAddressGroup
     */
    'description'?: string;
}
/**
 * Response of the address-groups/id:put operation
 * @export
 * @interface AddressGroupUpdateResponse
 */
export interface AddressGroupUpdateResponse {
    /**
     * 
     * @type {AddressGroupsCreateResponseAddressGroup}
     * @memberof AddressGroupUpdateResponse
     */
    'address_group'?: AddressGroupsCreateResponseAddressGroup;
}
/**
 * 
 * @export
 * @interface AddressGroupsAddAddressesAddAddressesRequest
 */
export interface AddressGroupsAddAddressesAddAddressesRequest {
    /**
     * 
     * @type {AddressGroupsAddAddressesAddAddressesRequestAddressGroup}
     * @memberof AddressGroupsAddAddressesAddAddressesRequest
     */
    'address_group'?: AddressGroupsAddAddressesAddAddressesRequestAddressGroup;
}
/**
 * 
 * @export
 * @interface AddressGroupsAddAddressesAddAddressesRequestAddressGroup
 */
export interface AddressGroupsAddAddressesAddAddressesRequestAddressGroup {
    /**
     * A list of IP addresses.
     * @type {Array<string>}
     * @memberof AddressGroupsAddAddressesAddAddressesRequestAddressGroup
     */
    'addresses'?: Array<string>;
}
/**
 * Request of the address-groups:post operation
 * @export
 * @interface AddressGroupsCreateRequest
 */
export interface AddressGroupsCreateRequest {
    /**
     * 
     * @type {AddressGroupsCreateRequestAddressGroup}
     * @memberof AddressGroupsCreateRequest
     */
    'address_group'?: AddressGroupsCreateRequestAddressGroup;
}
/**
 * 
 * @export
 * @interface AddressGroupsCreateRequestAddressGroup
 */
export interface AddressGroupsCreateRequestAddressGroup {
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateRequestAddressGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateRequestAddressGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateRequestAddressGroup
     */
    'project_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddressGroupsCreateRequestAddressGroup
     */
    'addresses'?: Array<string>;
}
/**
 * Response of the address-groups:post operation
 * @export
 * @interface AddressGroupsCreateResponse
 */
export interface AddressGroupsCreateResponse {
    /**
     * 
     * @type {AddressGroupsCreateResponseAddressGroup}
     * @memberof AddressGroupsCreateResponse
     */
    'address_group'?: AddressGroupsCreateResponseAddressGroup;
}
/**
 * 
 * @export
 * @interface AddressGroupsCreateResponseAddressGroup
 */
export interface AddressGroupsCreateResponseAddressGroup {
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateResponseAddressGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateResponseAddressGroup
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateResponseAddressGroup
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressGroupsCreateResponseAddressGroup
     */
    'project_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof AddressGroupsCreateResponseAddressGroup
     */
    'addresses'?: Array<string>;
}
/**
 * Response of the address-groups:get operation
 * @export
 * @interface AddressGroupsIndexResponse
 */
export interface AddressGroupsIndexResponse {
    /**
     * 
     * @type {Array<AddressGroupsCreateResponseAddressGroup>}
     * @memberof AddressGroupsIndexResponse
     */
    'address_groups'?: Array<AddressGroupsCreateResponseAddressGroup>;
}
/**
 * 
 * @export
 * @interface AddressGroupsRemoveAddressesRemoveAddressesRequest
 */
export interface AddressGroupsRemoveAddressesRemoveAddressesRequest {
    /**
     * 
     * @type {AddressGroupsAddAddressesAddAddressesRequestAddressGroup}
     * @memberof AddressGroupsRemoveAddressesRemoveAddressesRequest
     */
    'address_group'?: AddressGroupsAddAddressesAddAddressesRequestAddressGroup;
}
/**
 * Response of the address-scopes/id:get operation
 * @export
 * @interface AddressScopeShowResponse
 */
export interface AddressScopeShowResponse {
    /**
     * 
     * @type {AddressScopesCreateResponseAddressScope}
     * @memberof AddressScopeShowResponse
     */
    'address_scope'?: AddressScopesCreateResponseAddressScope;
}
/**
 * Request of the address-scopes/id:put operation
 * @export
 * @interface AddressScopeUpdateRequest
 */
export interface AddressScopeUpdateRequest {
    /**
     * 
     * @type {AddressScopeUpdateRequestAddressScope}
     * @memberof AddressScopeUpdateRequest
     */
    'address_scope'?: AddressScopeUpdateRequestAddressScope;
}
/**
 * 
 * @export
 * @interface AddressScopeUpdateRequestAddressScope
 */
export interface AddressScopeUpdateRequestAddressScope {
    /**
     * 
     * @type {string}
     * @memberof AddressScopeUpdateRequestAddressScope
     */
    'name'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof AddressScopeUpdateRequestAddressScope
     */
    'shared'?: AddressScopesCreateRequestAddressScopeShared;
}
/**
 * Response of the address-scopes/id:put operation
 * @export
 * @interface AddressScopeUpdateResponse
 */
export interface AddressScopeUpdateResponse {
    /**
     * 
     * @type {AddressScopesCreateResponseAddressScope}
     * @memberof AddressScopeUpdateResponse
     */
    'address_scope'?: AddressScopesCreateResponseAddressScope;
}
/**
 * Request of the address-scopes:post operation
 * @export
 * @interface AddressScopesCreateRequest
 */
export interface AddressScopesCreateRequest {
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScope}
     * @memberof AddressScopesCreateRequest
     */
    'address_scope'?: AddressScopesCreateRequestAddressScope;
}
/**
 * 
 * @export
 * @interface AddressScopesCreateRequestAddressScope
 */
export interface AddressScopesCreateRequestAddressScope {
    /**
     * 
     * @type {string}
     * @memberof AddressScopesCreateRequestAddressScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressScopesCreateRequestAddressScope
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof AddressScopesCreateRequestAddressScope
     */
    'shared'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeIpVersion}
     * @memberof AddressScopesCreateRequestAddressScope
     */
    'ip_version'?: AddressScopesCreateRequestAddressScopeIpVersion;
}


/**
 * 
 * @export
 * @interface AddressScopesCreateRequestAddressScopeIpVersion
 */
export interface AddressScopesCreateRequestAddressScopeIpVersion {
}
/**
 * 
 * @export
 * @interface AddressScopesCreateRequestAddressScopeShared
 */
export interface AddressScopesCreateRequestAddressScopeShared {
}
/**
 * Response of the address-scopes:post operation
 * @export
 * @interface AddressScopesCreateResponse
 */
export interface AddressScopesCreateResponse {
    /**
     * 
     * @type {AddressScopesCreateResponseAddressScope}
     * @memberof AddressScopesCreateResponse
     */
    'address_scope'?: AddressScopesCreateResponseAddressScope;
}
/**
 * 
 * @export
 * @interface AddressScopesCreateResponseAddressScope
 */
export interface AddressScopesCreateResponseAddressScope {
    /**
     * 
     * @type {string}
     * @memberof AddressScopesCreateResponseAddressScope
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressScopesCreateResponseAddressScope
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AddressScopesCreateResponseAddressScope
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof AddressScopesCreateResponseAddressScope
     */
    'shared'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeIpVersion}
     * @memberof AddressScopesCreateResponseAddressScope
     */
    'ip_version'?: AddressScopesCreateRequestAddressScopeIpVersion;
}


/**
 * Response of the address-scopes:get operation
 * @export
 * @interface AddressScopesIndexResponse
 */
export interface AddressScopesIndexResponse {
    /**
     * 
     * @type {Array<AddressScopesCreateResponseAddressScope>}
     * @memberof AddressScopesIndexResponse
     */
    'address_scopes'?: Array<AddressScopesCreateResponseAddressScope>;
}
/**
 * Response of the agents/id:get operation
 * @export
 * @interface AgentShowResponse
 */
export interface AgentShowResponse {
    /**
     * 
     * @type {AgentsCreateResponseAgent}
     * @memberof AgentShowResponse
     */
    'agent'?: AgentsCreateResponseAgent;
}
/**
 * Request of the agents/id:put operation
 * @export
 * @interface AgentUpdateRequest
 */
export interface AgentUpdateRequest {
    /**
     * 
     * @type {AgentUpdateRequestAgent}
     * @memberof AgentUpdateRequest
     */
    'agent'?: AgentUpdateRequestAgent;
}
/**
 * 
 * @export
 * @interface AgentUpdateRequestAgent
 */
export interface AgentUpdateRequestAgent {
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof AgentUpdateRequestAgent
     */
    'admin_state_up'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {string}
     * @memberof AgentUpdateRequestAgent
     */
    'description'?: string | null;
}
/**
 * Response of the agents/id:put operation
 * @export
 * @interface AgentUpdateResponse
 */
export interface AgentUpdateResponse {
    /**
     * 
     * @type {AgentsCreateResponseAgent}
     * @memberof AgentUpdateResponse
     */
    'agent'?: AgentsCreateResponseAgent;
}
/**
 * Request of the agents:post operation
 * @export
 * @interface AgentsCreateRequest
 */
export interface AgentsCreateRequest {
    /**
     * 
     * @type {object}
     * @memberof AgentsCreateRequest
     */
    'agent'?: object;
}
/**
 * Response of the agents:post operation
 * @export
 * @interface AgentsCreateResponse
 */
export interface AgentsCreateResponse {
    /**
     * 
     * @type {AgentsCreateResponseAgent}
     * @memberof AgentsCreateResponse
     */
    'agent'?: AgentsCreateResponseAgent;
}
/**
 * 
 * @export
 * @interface AgentsCreateResponseAgent
 */
export interface AgentsCreateResponseAgent {
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'agent_type'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'binary'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'topic'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'host'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof AgentsCreateResponseAgent
     */
    'admin_state_up'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'started_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'heartbeat_timestamp'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'alive'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'configurations'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'resources_synced'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgentsCreateResponseAgent
     */
    'availability_zone'?: string;
}
/**
 * Response of the agents:get operation
 * @export
 * @interface AgentsIndexResponse
 */
export interface AgentsIndexResponse {
    /**
     * 
     * @type {Array<AgentsCreateResponseAgent>}
     * @memberof AgentsIndexResponse
     */
    'agents'?: Array<AgentsCreateResponseAgent>;
}
/**
 * 
 * @export
 * @interface AgentsL3RoutersCreateRequest
 */
export interface AgentsL3RoutersCreateRequest {
    /**
     * The ID of the router.
     * @type {any}
     * @memberof AgentsL3RoutersCreateRequest
     */
    'router_id'?: any;
}
/**
 * 
 * @export
 * @interface AgentsL3RoutersIndexResponse
 */
export interface AgentsL3RoutersIndexResponse {
    /**
     * A list of router objects.
     * @type {any}
     * @memberof AgentsL3RoutersIndexResponse
     */
    'routers'?: any;
}
/**
 * Request of the auto-allocated-topology:post operation
 * @export
 * @interface AutoAllocatedTopologyCreateRequest
 */
export interface AutoAllocatedTopologyCreateRequest {
    /**
     * 
     * @type {object}
     * @memberof AutoAllocatedTopologyCreateRequest
     */
    'auto_allocated_topology'?: object;
}
/**
 * Response of the auto-allocated-topology:post operation
 * @export
 * @interface AutoAllocatedTopologyCreateResponse
 */
export interface AutoAllocatedTopologyCreateResponse {
    /**
     * 
     * @type {AutoAllocatedTopologyCreateResponseAutoAllocatedTopology}
     * @memberof AutoAllocatedTopologyCreateResponse
     */
    'auto_allocated_topology'?: AutoAllocatedTopologyCreateResponseAutoAllocatedTopology;
}
/**
 * 
 * @export
 * @interface AutoAllocatedTopologyCreateResponseAutoAllocatedTopology
 */
export interface AutoAllocatedTopologyCreateResponseAutoAllocatedTopology {
    /**
     * 
     * @type {string}
     * @memberof AutoAllocatedTopologyCreateResponseAutoAllocatedTopology
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AutoAllocatedTopologyCreateResponseAutoAllocatedTopology
     */
    'tenant_id'?: string;
}
/**
 * Response of the auto-allocated-topology:get operation
 * @export
 * @interface AutoAllocatedTopologyIndexResponse
 */
export interface AutoAllocatedTopologyIndexResponse {
    /**
     * 
     * @type {Array<AutoAllocatedTopologyCreateResponseAutoAllocatedTopology>}
     * @memberof AutoAllocatedTopologyIndexResponse
     */
    'auto_allocated_topologies'?: Array<AutoAllocatedTopologyCreateResponseAutoAllocatedTopology>;
}
/**
 * Response of the auto-allocated-topology/id:get operation
 * @export
 * @interface AutoAllocatedTopologyShowResponse
 */
export interface AutoAllocatedTopologyShowResponse {
    /**
     * 
     * @type {AutoAllocatedTopologyCreateResponseAutoAllocatedTopology}
     * @memberof AutoAllocatedTopologyShowResponse
     */
    'auto_allocated_topology'?: AutoAllocatedTopologyCreateResponseAutoAllocatedTopology;
}
/**
 * Request of the auto-allocated-topology/id:put operation
 * @export
 * @interface AutoAllocatedTopologyUpdateRequest
 */
export interface AutoAllocatedTopologyUpdateRequest {
    /**
     * 
     * @type {object}
     * @memberof AutoAllocatedTopologyUpdateRequest
     */
    'auto_allocated_topology'?: object;
}
/**
 * Response of the auto-allocated-topology/id:put operation
 * @export
 * @interface AutoAllocatedTopologyUpdateResponse
 */
export interface AutoAllocatedTopologyUpdateResponse {
    /**
     * 
     * @type {AutoAllocatedTopologyCreateResponseAutoAllocatedTopology}
     * @memberof AutoAllocatedTopologyUpdateResponse
     */
    'auto_allocated_topology'?: AutoAllocatedTopologyCreateResponseAutoAllocatedTopology;
}
/**
 * Response of the availability_zones:get operation
 * @export
 * @interface AvailabilityZonesIndexResponse
 */
export interface AvailabilityZonesIndexResponse {
    /**
     * 
     * @type {Array<AvailabilityZonesIndexResponseAvailabilityZonesInner>}
     * @memberof AvailabilityZonesIndexResponse
     */
    'availability_zones'?: Array<AvailabilityZonesIndexResponseAvailabilityZonesInner>;
}
/**
 * 
 * @export
 * @interface AvailabilityZonesIndexResponseAvailabilityZonesInner
 */
export interface AvailabilityZonesIndexResponseAvailabilityZonesInner {
    /**
     * 
     * @type {string}
     * @memberof AvailabilityZonesIndexResponseAvailabilityZonesInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailabilityZonesIndexResponseAvailabilityZonesInner
     */
    'resource'?: string;
    /**
     * 
     * @type {string}
     * @memberof AvailabilityZonesIndexResponseAvailabilityZonesInner
     */
    'state'?: string;
}
/**
 * Response of the default-security-group-rules/id:get operation
 * @export
 * @interface DefaultSecurityGroupRuleShowResponse
 */
export interface DefaultSecurityGroupRuleShowResponse {
    /**
     * 
     * @type {DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule}
     * @memberof DefaultSecurityGroupRuleShowResponse
     */
    'default_security_group_rule'?: DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule;
}
/**
 * Request of the default-security-group-rules/id:put operation
 * @export
 * @interface DefaultSecurityGroupRuleUpdateRequest
 */
export interface DefaultSecurityGroupRuleUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRuleUpdateRequest
     */
    'default_security_group_rule'?: any;
}
/**
 * Response of the default-security-group-rules/id:put operation
 * @export
 * @interface DefaultSecurityGroupRuleUpdateResponse
 */
export interface DefaultSecurityGroupRuleUpdateResponse {
    /**
     * 
     * @type {DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule}
     * @memberof DefaultSecurityGroupRuleUpdateResponse
     */
    'default_security_group_rule'?: DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule;
}
/**
 * Request of the default-security-group-rules:post operation
 * @export
 * @interface DefaultSecurityGroupRulesCreateRequest
 */
export interface DefaultSecurityGroupRulesCreateRequest {
    /**
     * 
     * @type {DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule}
     * @memberof DefaultSecurityGroupRulesCreateRequest
     */
    'default_security_group_rule'?: DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
 */
export interface DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule {
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'remote_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'remote_address_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'direction'?: DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'protocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'port_range_min'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'port_range_max'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'ethertype'?: DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleEthertypeEnum;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'used_in_default_sg'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRule
     */
    'used_in_non_default_sg'?: any;
}

export const DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleDirectionEnum = typeof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleDirectionEnum[keyof typeof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleDirectionEnum];
export const DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleEthertypeEnum = typeof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleEthertypeEnum[keyof typeof DefaultSecurityGroupRulesCreateRequestDefaultSecurityGroupRuleEthertypeEnum];

/**
 * Response of the default-security-group-rules:post operation
 * @export
 * @interface DefaultSecurityGroupRulesCreateResponse
 */
export interface DefaultSecurityGroupRulesCreateResponse {
    /**
     * 
     * @type {DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule}
     * @memberof DefaultSecurityGroupRulesCreateResponse
     */
    'default_security_group_rule'?: DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
 */
export interface DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule {
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'remote_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'remote_address_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'direction'?: DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'protocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'port_range_min'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'port_range_max'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'ethertype'?: DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleEthertypeEnum;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'used_in_default_sg'?: any;
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRule
     */
    'used_in_non_default_sg'?: any;
}

export const DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleDirectionEnum = typeof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleDirectionEnum[keyof typeof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleDirectionEnum];
export const DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleEthertypeEnum = typeof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleEthertypeEnum[keyof typeof DefaultSecurityGroupRulesCreateResponseDefaultSecurityGroupRuleEthertypeEnum];

/**
 * Response of the default-security-group-rules:get operation
 * @export
 * @interface DefaultSecurityGroupRulesIndexResponse
 */
export interface DefaultSecurityGroupRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof DefaultSecurityGroupRulesIndexResponse
     */
    'default_security_group_rules'?: any;
}
/**
 * Response of the extensions/id:get operation
 * @export
 * @interface ExtensionShowResponse
 */
export interface ExtensionShowResponse {
    /**
     * 
     * @type {ExtensionsIndexResponseExtensionsInner}
     * @memberof ExtensionShowResponse
     */
    'extension'?: ExtensionsIndexResponseExtensionsInner;
}
/**
 * Response of the extensions:get operation
 * @export
 * @interface ExtensionsIndexResponse
 */
export interface ExtensionsIndexResponse {
    /**
     * 
     * @type {Array<ExtensionsIndexResponseExtensionsInner>}
     * @memberof ExtensionsIndexResponse
     */
    'extensions'?: Array<ExtensionsIndexResponseExtensionsInner>;
}
/**
 * 
 * @export
 * @interface ExtensionsIndexResponseExtensionsInner
 */
export interface ExtensionsIndexResponseExtensionsInner {
    /**
     * A short name by which this extension is also known.
     * @type {string}
     * @memberof ExtensionsIndexResponseExtensionsInner
     */
    'alias'?: string;
    /**
     * Text describing this extensionâ€™s purpose.
     * @type {string}
     * @memberof ExtensionsIndexResponseExtensionsInner
     */
    'description'?: string;
    /**
     * Name of the extension.
     * @type {string}
     * @memberof ExtensionsIndexResponseExtensionsInner
     */
    'name'?: string;
    /**
     * A URL pointing to the namespace for this extension.
     * @type {string}
     * @memberof ExtensionsIndexResponseExtensionsInner
     */
    'namespace'?: string;
    /**
     * The date and time when the resource was updated.
     * @type {string}
     * @memberof ExtensionsIndexResponseExtensionsInner
     */
    'updated'?: string;
}
/**
 * Response of the flavors/id:get operation
 * @export
 * @interface FlavorShowResponse
 */
export interface FlavorShowResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorShowResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * Request of the flavors/id:put operation
 * @export
 * @interface FlavorUpdateRequest
 */
export interface FlavorUpdateRequest {
    /**
     * 
     * @type {FlavorUpdateRequestFlavor}
     * @memberof FlavorUpdateRequest
     */
    'flavor'?: FlavorUpdateRequestFlavor;
}
/**
 * 
 * @export
 * @interface FlavorUpdateRequestFlavor
 */
export interface FlavorUpdateRequestFlavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorUpdateRequestFlavor
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorUpdateRequestFlavor
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorUpdateRequestFlavor
     */
    'service_profiles'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorUpdateRequestFlavor
     */
    'enabled'?: any;
}
/**
 * Response of the flavors/id:put operation
 * @export
 * @interface FlavorUpdateResponse
 */
export interface FlavorUpdateResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorUpdateResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * Request of the flavors:post operation
 * @export
 * @interface FlavorsCreateRequest
 */
export interface FlavorsCreateRequest {
    /**
     * 
     * @type {FlavorsCreateRequestFlavor}
     * @memberof FlavorsCreateRequest
     */
    'flavor'?: FlavorsCreateRequestFlavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreateRequestFlavor
 */
export interface FlavorsCreateRequestFlavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateRequestFlavor
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateRequestFlavor
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateRequestFlavor
     */
    'service_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateRequestFlavor
     */
    'service_profiles'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateRequestFlavor
     */
    'enabled'?: any;
}
/**
 * Response of the flavors:post operation
 * @export
 * @interface FlavorsCreateResponse
 */
export interface FlavorsCreateResponse {
    /**
     * 
     * @type {FlavorsCreateResponseFlavor}
     * @memberof FlavorsCreateResponse
     */
    'flavor'?: FlavorsCreateResponseFlavor;
}
/**
 * 
 * @export
 * @interface FlavorsCreateResponseFlavor
 */
export interface FlavorsCreateResponseFlavor {
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'service_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'service_profiles'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsCreateResponseFlavor
     */
    'enabled'?: any;
}
/**
 * Response of the flavors:get operation
 * @export
 * @interface FlavorsIndexResponse
 */
export interface FlavorsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsIndexResponse
     */
    'flavors'?: any;
}
/**
 * Response of the flavors/flavor_id/next_providers/id:get operation
 * @export
 * @interface FlavorsNextProviderShowResponse
 */
export interface FlavorsNextProviderShowResponse {
    /**
     * 
     * @type {FlavorsNextProvidersCreateResponseNextProvider}
     * @memberof FlavorsNextProviderShowResponse
     */
    'next_provider'?: FlavorsNextProvidersCreateResponseNextProvider;
}
/**
 * Request of the flavors/flavor_id/next_providers/id:put operation
 * @export
 * @interface FlavorsNextProviderUpdateRequest
 */
export interface FlavorsNextProviderUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProviderUpdateRequest
     */
    'next_provider'?: any;
}
/**
 * Response of the flavors/flavor_id/next_providers/id:put operation
 * @export
 * @interface FlavorsNextProviderUpdateResponse
 */
export interface FlavorsNextProviderUpdateResponse {
    /**
     * 
     * @type {FlavorsNextProvidersCreateResponseNextProvider}
     * @memberof FlavorsNextProviderUpdateResponse
     */
    'next_provider'?: FlavorsNextProvidersCreateResponseNextProvider;
}
/**
 * Request of the flavors/flavor_id/next_providers:post operation
 * @export
 * @interface FlavorsNextProvidersCreateRequest
 */
export interface FlavorsNextProvidersCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProvidersCreateRequest
     */
    'next_provider'?: any;
}
/**
 * Response of the flavors/flavor_id/next_providers:post operation
 * @export
 * @interface FlavorsNextProvidersCreateResponse
 */
export interface FlavorsNextProvidersCreateResponse {
    /**
     * 
     * @type {FlavorsNextProvidersCreateResponseNextProvider}
     * @memberof FlavorsNextProvidersCreateResponse
     */
    'next_provider'?: FlavorsNextProvidersCreateResponseNextProvider;
}
/**
 * 
 * @export
 * @interface FlavorsNextProvidersCreateResponseNextProvider
 */
export interface FlavorsNextProvidersCreateResponseNextProvider {
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProvidersCreateResponseNextProvider
     */
    'provider'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProvidersCreateResponseNextProvider
     */
    'driver'?: any;
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProvidersCreateResponseNextProvider
     */
    'metainfo'?: any;
}
/**
 * Response of the flavors/flavor_id/next_providers:get operation
 * @export
 * @interface FlavorsNextProvidersIndexResponse
 */
export interface FlavorsNextProvidersIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsNextProvidersIndexResponse
     */
    'next_providers'?: any;
}
/**
 * Response of the flavors/flavor_id/service_profiles/id:get operation
 * @export
 * @interface FlavorsServiceProfileShowResponse
 */
export interface FlavorsServiceProfileShowResponse {
    /**
     * 
     * @type {FlavorsServiceProfilesCreateRequestServiceProfile}
     * @memberof FlavorsServiceProfileShowResponse
     */
    'service_profile'?: FlavorsServiceProfilesCreateRequestServiceProfile;
}
/**
 * Request of the flavors/flavor_id/service_profiles/id:put operation
 * @export
 * @interface FlavorsServiceProfileUpdateRequest
 */
export interface FlavorsServiceProfileUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof FlavorsServiceProfileUpdateRequest
     */
    'service_profile'?: any;
}
/**
 * Response of the flavors/flavor_id/service_profiles/id:put operation
 * @export
 * @interface FlavorsServiceProfileUpdateResponse
 */
export interface FlavorsServiceProfileUpdateResponse {
    /**
     * 
     * @type {FlavorsServiceProfilesCreateRequestServiceProfile}
     * @memberof FlavorsServiceProfileUpdateResponse
     */
    'service_profile'?: FlavorsServiceProfilesCreateRequestServiceProfile;
}
/**
 * Request of the flavors/flavor_id/service_profiles:post operation
 * @export
 * @interface FlavorsServiceProfilesCreateRequest
 */
export interface FlavorsServiceProfilesCreateRequest {
    /**
     * 
     * @type {FlavorsServiceProfilesCreateRequestServiceProfile}
     * @memberof FlavorsServiceProfilesCreateRequest
     */
    'service_profile'?: FlavorsServiceProfilesCreateRequestServiceProfile;
}
/**
 * 
 * @export
 * @interface FlavorsServiceProfilesCreateRequestServiceProfile
 */
export interface FlavorsServiceProfilesCreateRequestServiceProfile {
    /**
     * 
     * @type {any}
     * @memberof FlavorsServiceProfilesCreateRequestServiceProfile
     */
    'id'?: any;
}
/**
 * Response of the flavors/flavor_id/service_profiles:post operation
 * @export
 * @interface FlavorsServiceProfilesCreateResponse
 */
export interface FlavorsServiceProfilesCreateResponse {
    /**
     * 
     * @type {FlavorsServiceProfilesCreateRequestServiceProfile}
     * @memberof FlavorsServiceProfilesCreateResponse
     */
    'service_profile'?: FlavorsServiceProfilesCreateRequestServiceProfile;
}
/**
 * Response of the flavors/flavor_id/service_profiles:get operation
 * @export
 * @interface FlavorsServiceProfilesIndexResponse
 */
export interface FlavorsServiceProfilesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FlavorsServiceProfilesIndexResponse
     */
    'service_profiles'?: any;
}
/**
 * Response of the floatingip-pools/id:get operation
 * @export
 * @interface FloatingipPoolShowResponse
 */
export interface FloatingipPoolShowResponse {
    /**
     * 
     * @type {FloatingipPoolsCreateResponseFloatingipPool}
     * @memberof FloatingipPoolShowResponse
     */
    'floatingip_pool'?: FloatingipPoolsCreateResponseFloatingipPool;
}
/**
 * Request of the floatingip-pools/id:put operation
 * @export
 * @interface FloatingipPoolUpdateRequest
 */
export interface FloatingipPoolUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolUpdateRequest
     */
    'floatingip_pool'?: any;
}
/**
 * Response of the floatingip-pools/id:put operation
 * @export
 * @interface FloatingipPoolUpdateResponse
 */
export interface FloatingipPoolUpdateResponse {
    /**
     * 
     * @type {FloatingipPoolsCreateResponseFloatingipPool}
     * @memberof FloatingipPoolUpdateResponse
     */
    'floatingip_pool'?: FloatingipPoolsCreateResponseFloatingipPool;
}
/**
 * Request of the floatingip-pools:post operation
 * @export
 * @interface FloatingipPoolsCreateRequest
 */
export interface FloatingipPoolsCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateRequest
     */
    'floatingip_pool'?: any;
}
/**
 * Response of the floatingip-pools:post operation
 * @export
 * @interface FloatingipPoolsCreateResponse
 */
export interface FloatingipPoolsCreateResponse {
    /**
     * 
     * @type {FloatingipPoolsCreateResponseFloatingipPool}
     * @memberof FloatingipPoolsCreateResponse
     */
    'floatingip_pool'?: FloatingipPoolsCreateResponseFloatingipPool;
}
/**
 * 
 * @export
 * @interface FloatingipPoolsCreateResponseFloatingipPool
 */
export interface FloatingipPoolsCreateResponseFloatingipPool {
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateResponseFloatingipPool
     */
    'subnet_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateResponseFloatingipPool
     */
    'subnet_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateResponseFloatingipPool
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateResponseFloatingipPool
     */
    'cidr'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsCreateResponseFloatingipPool
     */
    'project_id'?: any;
}
/**
 * Response of the floatingip-pools:get operation
 * @export
 * @interface FloatingipPoolsIndexResponse
 */
export interface FloatingipPoolsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FloatingipPoolsIndexResponse
     */
    'floatingip_pools'?: any;
}
/**
 * Response of the floatingips/id:get operation
 * @export
 * @interface FloatingipShowResponse
 */
export interface FloatingipShowResponse {
    /**
     * 
     * @type {FloatingipsCreateResponseFloatingip}
     * @memberof FloatingipShowResponse
     */
    'floatingip'?: FloatingipsCreateResponseFloatingip;
}
/**
 * Request of the floatingips/id:put operation
 * @export
 * @interface FloatingipUpdateRequest
 */
export interface FloatingipUpdateRequest {
    /**
     * 
     * @type {FloatingipUpdateRequestFloatingip}
     * @memberof FloatingipUpdateRequest
     */
    'floatingip'?: FloatingipUpdateRequestFloatingip;
}
/**
 * 
 * @export
 * @interface FloatingipUpdateRequestFloatingip
 */
export interface FloatingipUpdateRequestFloatingip {
    /**
     * 
     * @type {any}
     * @memberof FloatingipUpdateRequestFloatingip
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipUpdateRequestFloatingip
     */
    'fixed_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipUpdateRequestFloatingip
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipUpdateRequestFloatingip
     */
    'description'?: any;
}
/**
 * Response of the floatingips/id:put operation
 * @export
 * @interface FloatingipUpdateResponse
 */
export interface FloatingipUpdateResponse {
    /**
     * 
     * @type {FloatingipsCreateResponseFloatingip}
     * @memberof FloatingipUpdateResponse
     */
    'floatingip'?: FloatingipsCreateResponseFloatingip;
}
/**
 * Request of the floatingips:post operation
 * @export
 * @interface FloatingipsCreateRequest
 */
export interface FloatingipsCreateRequest {
    /**
     * 
     * @type {FloatingipsCreateRequestFloatingip}
     * @memberof FloatingipsCreateRequest
     */
    'floatingip'?: FloatingipsCreateRequestFloatingip;
}
/**
 * 
 * @export
 * @interface FloatingipsCreateRequestFloatingip
 */
export interface FloatingipsCreateRequestFloatingip {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'floating_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'subnet_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'floating_network_id': any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'fixed_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'dns_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateRequestFloatingip
     */
    'description'?: any;
}
/**
 * Response of the floatingips:post operation
 * @export
 * @interface FloatingipsCreateResponse
 */
export interface FloatingipsCreateResponse {
    /**
     * 
     * @type {FloatingipsCreateResponseFloatingip}
     * @memberof FloatingipsCreateResponse
     */
    'floatingip'?: FloatingipsCreateResponseFloatingip;
}
/**
 * 
 * @export
 * @interface FloatingipsCreateResponseFloatingip
 */
export interface FloatingipsCreateResponseFloatingip {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'floating_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'floating_network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'router_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'fixed_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'dns_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'port_details'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'port_forwardings'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsCreateResponseFloatingip
     */
    'description'?: any;
}
/**
 * Response of the floatingips:get operation
 * @export
 * @interface FloatingipsIndexResponse
 */
export interface FloatingipsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsIndexResponse
     */
    'floatingips'?: any;
}
/**
 * Response of the floatingips/floatingip_id/port_forwardings/id:get operation
 * @export
 * @interface FloatingipsPortForwardingShowResponse
 */
export interface FloatingipsPortForwardingShowResponse {
    /**
     * 
     * @type {FloatingipsPortForwardingsCreateResponsePortForwarding}
     * @memberof FloatingipsPortForwardingShowResponse
     */
    'port_forwarding'?: FloatingipsPortForwardingsCreateResponsePortForwarding;
}
/**
 * Request of the floatingips/floatingip_id/port_forwardings/id:put operation
 * @export
 * @interface FloatingipsPortForwardingUpdateRequest
 */
export interface FloatingipsPortForwardingUpdateRequest {
    /**
     * 
     * @type {FloatingipsPortForwardingUpdateRequestPortForwarding}
     * @memberof FloatingipsPortForwardingUpdateRequest
     */
    'port_forwarding'?: FloatingipsPortForwardingUpdateRequestPortForwarding;
}
/**
 * 
 * @export
 * @interface FloatingipsPortForwardingUpdateRequestPortForwarding
 */
export interface FloatingipsPortForwardingUpdateRequestPortForwarding {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'external_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'internal_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'internal_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'protocol'?: FloatingipsPortForwardingUpdateRequestPortForwardingProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'internal_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'external_port_range'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingUpdateRequestPortForwarding
     */
    'internal_port_range'?: any;
}

export const FloatingipsPortForwardingUpdateRequestPortForwardingProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type FloatingipsPortForwardingUpdateRequestPortForwardingProtocolEnum = typeof FloatingipsPortForwardingUpdateRequestPortForwardingProtocolEnum[keyof typeof FloatingipsPortForwardingUpdateRequestPortForwardingProtocolEnum];

/**
 * Response of the floatingips/floatingip_id/port_forwardings/id:put operation
 * @export
 * @interface FloatingipsPortForwardingUpdateResponse
 */
export interface FloatingipsPortForwardingUpdateResponse {
    /**
     * 
     * @type {FloatingipsPortForwardingsCreateResponsePortForwarding}
     * @memberof FloatingipsPortForwardingUpdateResponse
     */
    'port_forwarding'?: FloatingipsPortForwardingsCreateResponsePortForwarding;
}
/**
 * Request of the floatingips/floatingip_id/port_forwardings:post operation
 * @export
 * @interface FloatingipsPortForwardingsCreateRequest
 */
export interface FloatingipsPortForwardingsCreateRequest {
    /**
     * 
     * @type {FloatingipsPortForwardingsCreateRequestPortForwarding}
     * @memberof FloatingipsPortForwardingsCreateRequest
     */
    'port_forwarding'?: FloatingipsPortForwardingsCreateRequestPortForwarding;
}
/**
 * 
 * @export
 * @interface FloatingipsPortForwardingsCreateRequestPortForwarding
 */
export interface FloatingipsPortForwardingsCreateRequestPortForwarding {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'external_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'internal_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'internal_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'protocol'?: FloatingipsPortForwardingsCreateRequestPortForwardingProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'internal_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'external_port_range'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateRequestPortForwarding
     */
    'internal_port_range'?: any;
}

export const FloatingipsPortForwardingsCreateRequestPortForwardingProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type FloatingipsPortForwardingsCreateRequestPortForwardingProtocolEnum = typeof FloatingipsPortForwardingsCreateRequestPortForwardingProtocolEnum[keyof typeof FloatingipsPortForwardingsCreateRequestPortForwardingProtocolEnum];

/**
 * Response of the floatingips/floatingip_id/port_forwardings:post operation
 * @export
 * @interface FloatingipsPortForwardingsCreateResponse
 */
export interface FloatingipsPortForwardingsCreateResponse {
    /**
     * 
     * @type {FloatingipsPortForwardingsCreateResponsePortForwarding}
     * @memberof FloatingipsPortForwardingsCreateResponse
     */
    'port_forwarding'?: FloatingipsPortForwardingsCreateResponsePortForwarding;
}
/**
 * 
 * @export
 * @interface FloatingipsPortForwardingsCreateResponsePortForwarding
 */
export interface FloatingipsPortForwardingsCreateResponsePortForwarding {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'external_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'internal_port'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'internal_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'protocol'?: FloatingipsPortForwardingsCreateResponsePortForwardingProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'internal_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'external_port_range'?: any;
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsCreateResponsePortForwarding
     */
    'internal_port_range'?: any;
}

export const FloatingipsPortForwardingsCreateResponsePortForwardingProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type FloatingipsPortForwardingsCreateResponsePortForwardingProtocolEnum = typeof FloatingipsPortForwardingsCreateResponsePortForwardingProtocolEnum[keyof typeof FloatingipsPortForwardingsCreateResponsePortForwardingProtocolEnum];

/**
 * Response of the floatingips/floatingip_id/port_forwardings:get operation
 * @export
 * @interface FloatingipsPortForwardingsIndexResponse
 */
export interface FloatingipsPortForwardingsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsPortForwardingsIndexResponse
     */
    'port_forwardings'?: any;
}
/**
 * Response of the floatingips/floatingip_id/tags:get operation
 * @export
 * @interface FloatingipsTagsIndexResponse
 */
export interface FloatingipsTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the floatingips/floatingip_id/tags:put operation
 * @export
 * @interface FloatingipsTagsUpdateAllRequest
 */
export interface FloatingipsTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the floatingips/floatingip_id/tags:put operation
 * @export
 * @interface FloatingipsTagsUpdateAllResponse
 */
export interface FloatingipsTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof FloatingipsTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the local-ips/id:get operation
 * @export
 * @interface LocalIpShowResponse
 */
export interface LocalIpShowResponse {
    /**
     * 
     * @type {LocalIpsCreateResponseLocalIp}
     * @memberof LocalIpShowResponse
     */
    'local_ip'?: LocalIpsCreateResponseLocalIp;
}
/**
 * Request of the local-ips/id:put operation
 * @export
 * @interface LocalIpUpdateRequest
 */
export interface LocalIpUpdateRequest {
    /**
     * 
     * @type {NdpProxyUpdateRequestNdpProxy}
     * @memberof LocalIpUpdateRequest
     */
    'local_ip'?: NdpProxyUpdateRequestNdpProxy;
}
/**
 * Response of the local-ips/id:put operation
 * @export
 * @interface LocalIpUpdateResponse
 */
export interface LocalIpUpdateResponse {
    /**
     * 
     * @type {LocalIpsCreateResponseLocalIp}
     * @memberof LocalIpUpdateResponse
     */
    'local_ip'?: LocalIpsCreateResponseLocalIp;
}
/**
 * Request of the local-ips:post operation
 * @export
 * @interface LocalIpsCreateRequest
 */
export interface LocalIpsCreateRequest {
    /**
     * 
     * @type {LocalIpsCreateRequestLocalIp}
     * @memberof LocalIpsCreateRequest
     */
    'local_ip'?: LocalIpsCreateRequestLocalIp;
}
/**
 * 
 * @export
 * @interface LocalIpsCreateRequestLocalIp
 */
export interface LocalIpsCreateRequestLocalIp {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'local_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'local_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateRequestLocalIp
     */
    'ip_mode'?: LocalIpsCreateRequestLocalIpIpModeEnum;
}

export const LocalIpsCreateRequestLocalIpIpModeEnum = {
    Translate: 'translate',
    Passthrough: 'passthrough'
} as const;

export type LocalIpsCreateRequestLocalIpIpModeEnum = typeof LocalIpsCreateRequestLocalIpIpModeEnum[keyof typeof LocalIpsCreateRequestLocalIpIpModeEnum];

/**
 * Response of the local-ips:post operation
 * @export
 * @interface LocalIpsCreateResponse
 */
export interface LocalIpsCreateResponse {
    /**
     * 
     * @type {LocalIpsCreateResponseLocalIp}
     * @memberof LocalIpsCreateResponse
     */
    'local_ip'?: LocalIpsCreateResponseLocalIp;
}
/**
 * 
 * @export
 * @interface LocalIpsCreateResponseLocalIp
 */
export interface LocalIpsCreateResponseLocalIp {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'local_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'local_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'ip_mode'?: LocalIpsCreateResponseLocalIpIpModeEnum;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsCreateResponseLocalIp
     */
    'updated_at'?: any;
}

export const LocalIpsCreateResponseLocalIpIpModeEnum = {
    Translate: 'translate',
    Passthrough: 'passthrough'
} as const;

export type LocalIpsCreateResponseLocalIpIpModeEnum = typeof LocalIpsCreateResponseLocalIpIpModeEnum[keyof typeof LocalIpsCreateResponseLocalIpIpModeEnum];

/**
 * Response of the local-ips:get operation
 * @export
 * @interface LocalIpsIndexResponse
 */
export interface LocalIpsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsIndexResponse
     */
    'local_ips'?: any;
}
/**
 * Response of the local_ips/local_ip_id/port_associations/id:get operation
 * @export
 * @interface LocalIpsPortAssociationShowResponse
 */
export interface LocalIpsPortAssociationShowResponse {
    /**
     * 
     * @type {LocalIpsPortAssociationsCreateResponsePortAssociation}
     * @memberof LocalIpsPortAssociationShowResponse
     */
    'port_association'?: LocalIpsPortAssociationsCreateResponsePortAssociation;
}
/**
 * Request of the local_ips/local_ip_id/port_associations/id:put operation
 * @export
 * @interface LocalIpsPortAssociationUpdateRequest
 */
export interface LocalIpsPortAssociationUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationUpdateRequest
     */
    'port_association'?: any;
}
/**
 * Response of the local_ips/local_ip_id/port_associations/id:put operation
 * @export
 * @interface LocalIpsPortAssociationUpdateResponse
 */
export interface LocalIpsPortAssociationUpdateResponse {
    /**
     * 
     * @type {LocalIpsPortAssociationsCreateResponsePortAssociation}
     * @memberof LocalIpsPortAssociationUpdateResponse
     */
    'port_association'?: LocalIpsPortAssociationsCreateResponsePortAssociation;
}
/**
 * Request of the local_ips/local_ip_id/port_associations:post operation
 * @export
 * @interface LocalIpsPortAssociationsCreateRequest
 */
export interface LocalIpsPortAssociationsCreateRequest {
    /**
     * 
     * @type {LocalIpsPortAssociationsCreateRequestPortAssociation}
     * @memberof LocalIpsPortAssociationsCreateRequest
     */
    'port_association'?: LocalIpsPortAssociationsCreateRequestPortAssociation;
}
/**
 * 
 * @export
 * @interface LocalIpsPortAssociationsCreateRequestPortAssociation
 */
export interface LocalIpsPortAssociationsCreateRequestPortAssociation {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateRequestPortAssociation
     */
    'fixed_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateRequestPortAssociation
     */
    'fixed_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateRequestPortAssociation
     */
    'project_id'?: any;
}
/**
 * Response of the local_ips/local_ip_id/port_associations:post operation
 * @export
 * @interface LocalIpsPortAssociationsCreateResponse
 */
export interface LocalIpsPortAssociationsCreateResponse {
    /**
     * 
     * @type {LocalIpsPortAssociationsCreateResponsePortAssociation}
     * @memberof LocalIpsPortAssociationsCreateResponse
     */
    'port_association'?: LocalIpsPortAssociationsCreateResponsePortAssociation;
}
/**
 * 
 * @export
 * @interface LocalIpsPortAssociationsCreateResponsePortAssociation
 */
export interface LocalIpsPortAssociationsCreateResponsePortAssociation {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateResponsePortAssociation
     */
    'local_ip_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateResponsePortAssociation
     */
    'local_ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateResponsePortAssociation
     */
    'fixed_port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateResponsePortAssociation
     */
    'fixed_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsCreateResponsePortAssociation
     */
    'host'?: any;
}
/**
 * Response of the local_ips/local_ip_id/port_associations:get operation
 * @export
 * @interface LocalIpsPortAssociationsIndexResponse
 */
export interface LocalIpsPortAssociationsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof LocalIpsPortAssociationsIndexResponse
     */
    'port_associations'?: any;
}
/**
 * Response of the log/logs/id:get operation
 * @export
 * @interface LogLogShowResponse
 */
export interface LogLogShowResponse {
    /**
     * 
     * @type {LogLogsCreateResponseLog}
     * @memberof LogLogShowResponse
     */
    'log'?: LogLogsCreateResponseLog;
}
/**
 * Request of the log/logs/id:put operation
 * @export
 * @interface LogLogUpdateRequest
 */
export interface LogLogUpdateRequest {
    /**
     * 
     * @type {LogLogUpdateRequestLog}
     * @memberof LogLogUpdateRequest
     */
    'log'?: LogLogUpdateRequestLog;
}
/**
 * 
 * @export
 * @interface LogLogUpdateRequestLog
 */
export interface LogLogUpdateRequestLog {
    /**
     * 
     * @type {any}
     * @memberof LogLogUpdateRequestLog
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogUpdateRequestLog
     */
    'enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogUpdateRequestLog
     */
    'description'?: any;
}
/**
 * Response of the log/logs/id:put operation
 * @export
 * @interface LogLogUpdateResponse
 */
export interface LogLogUpdateResponse {
    /**
     * 
     * @type {LogLogsCreateResponseLog}
     * @memberof LogLogUpdateResponse
     */
    'log'?: LogLogsCreateResponseLog;
}
/**
 * Response of the log/loggable-resources/id:get operation
 * @export
 * @interface LogLoggableResourceShowResponse
 */
export interface LogLoggableResourceShowResponse {
    /**
     * 
     * @type {LogLoggableResourcesCreateResponseLoggableResource}
     * @memberof LogLoggableResourceShowResponse
     */
    'loggable_resource'?: LogLoggableResourcesCreateResponseLoggableResource;
}
/**
 * Request of the log/loggable-resources/id:put operation
 * @export
 * @interface LogLoggableResourceUpdateRequest
 */
export interface LogLoggableResourceUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof LogLoggableResourceUpdateRequest
     */
    'loggable_resource'?: any;
}
/**
 * Response of the log/loggable-resources/id:put operation
 * @export
 * @interface LogLoggableResourceUpdateResponse
 */
export interface LogLoggableResourceUpdateResponse {
    /**
     * 
     * @type {LogLoggableResourcesCreateResponseLoggableResource}
     * @memberof LogLoggableResourceUpdateResponse
     */
    'loggable_resource'?: LogLoggableResourcesCreateResponseLoggableResource;
}
/**
 * Request of the log/loggable-resources:post operation
 * @export
 * @interface LogLoggableResourcesCreateRequest
 */
export interface LogLoggableResourcesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof LogLoggableResourcesCreateRequest
     */
    'loggable_resource'?: any;
}
/**
 * Response of the log/loggable-resources:post operation
 * @export
 * @interface LogLoggableResourcesCreateResponse
 */
export interface LogLoggableResourcesCreateResponse {
    /**
     * 
     * @type {LogLoggableResourcesCreateResponseLoggableResource}
     * @memberof LogLoggableResourcesCreateResponse
     */
    'loggable_resource'?: LogLoggableResourcesCreateResponseLoggableResource;
}
/**
 * 
 * @export
 * @interface LogLoggableResourcesCreateResponseLoggableResource
 */
export interface LogLoggableResourcesCreateResponseLoggableResource {
    /**
     * 
     * @type {any}
     * @memberof LogLoggableResourcesCreateResponseLoggableResource
     */
    'type'?: any;
}
/**
 * Response of the log/loggable-resources:get operation
 * @export
 * @interface LogLoggableResourcesIndexResponse
 */
export interface LogLoggableResourcesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof LogLoggableResourcesIndexResponse
     */
    'loggable_resources'?: any;
}
/**
 * Request of the log/logs:post operation
 * @export
 * @interface LogLogsCreateRequest
 */
export interface LogLogsCreateRequest {
    /**
     * 
     * @type {LogLogsCreateRequestLog}
     * @memberof LogLogsCreateRequest
     */
    'log'?: LogLogsCreateRequestLog;
}
/**
 * 
 * @export
 * @interface LogLogsCreateRequestLog
 */
export interface LogLogsCreateRequestLog {
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'resource_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'resource_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'event'?: LogLogsCreateRequestLogEventEnum;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'target_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateRequestLog
     */
    'description'?: any;
}

export const LogLogsCreateRequestLogEventEnum = {
    Accept: 'ACCEPT',
    Drop: 'DROP',
    All: 'ALL'
} as const;

export type LogLogsCreateRequestLogEventEnum = typeof LogLogsCreateRequestLogEventEnum[keyof typeof LogLogsCreateRequestLogEventEnum];

/**
 * Response of the log/logs:post operation
 * @export
 * @interface LogLogsCreateResponse
 */
export interface LogLogsCreateResponse {
    /**
     * 
     * @type {LogLogsCreateResponseLog}
     * @memberof LogLogsCreateResponse
     */
    'log'?: LogLogsCreateResponseLog;
}
/**
 * 
 * @export
 * @interface LogLogsCreateResponseLog
 */
export interface LogLogsCreateResponseLog {
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'resource_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'resource_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'event'?: LogLogsCreateResponseLogEventEnum;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'target_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof LogLogsCreateResponseLog
     */
    'description'?: any;
}

export const LogLogsCreateResponseLogEventEnum = {
    Accept: 'ACCEPT',
    Drop: 'DROP',
    All: 'ALL'
} as const;

export type LogLogsCreateResponseLogEventEnum = typeof LogLogsCreateResponseLogEventEnum[keyof typeof LogLogsCreateResponseLogEventEnum];

/**
 * Response of the log/logs:get operation
 * @export
 * @interface LogLogsIndexResponse
 */
export interface LogLogsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof LogLogsIndexResponse
     */
    'logs'?: any;
}
/**
 * Response of the metering/metering-label-rules/id:get operation
 * @export
 * @interface MeteringMeteringLabelRuleShowResponse
 */
export interface MeteringMeteringLabelRuleShowResponse {
    /**
     * 
     * @type {MeteringMeteringLabelRulesCreateResponseMeteringLabelRule}
     * @memberof MeteringMeteringLabelRuleShowResponse
     */
    'metering_label_rule'?: MeteringMeteringLabelRulesCreateResponseMeteringLabelRule;
}
/**
 * Request of the metering/metering-label-rules/id:put operation
 * @export
 * @interface MeteringMeteringLabelRuleUpdateRequest
 */
export interface MeteringMeteringLabelRuleUpdateRequest {
    /**
     * 
     * @type {MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule}
     * @memberof MeteringMeteringLabelRuleUpdateRequest
     */
    'metering_label_rule'?: MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule;
}
/**
 * 
 * @export
 * @interface MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule
 */
export interface MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule
     */
    'source_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRuleUpdateRequestMeteringLabelRule
     */
    'destination_ip_prefix'?: any;
}
/**
 * Response of the metering/metering-label-rules/id:put operation
 * @export
 * @interface MeteringMeteringLabelRuleUpdateResponse
 */
export interface MeteringMeteringLabelRuleUpdateResponse {
    /**
     * 
     * @type {MeteringMeteringLabelRulesCreateResponseMeteringLabelRule}
     * @memberof MeteringMeteringLabelRuleUpdateResponse
     */
    'metering_label_rule'?: MeteringMeteringLabelRulesCreateResponseMeteringLabelRule;
}
/**
 * Request of the metering/metering-label-rules:post operation
 * @export
 * @interface MeteringMeteringLabelRulesCreateRequest
 */
export interface MeteringMeteringLabelRulesCreateRequest {
    /**
     * 
     * @type {MeteringMeteringLabelRulesCreateRequestMeteringLabelRule}
     * @memberof MeteringMeteringLabelRulesCreateRequest
     */
    'metering_label_rule'?: MeteringMeteringLabelRulesCreateRequestMeteringLabelRule;
}
/**
 * 
 * @export
 * @interface MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
 */
export interface MeteringMeteringLabelRulesCreateRequestMeteringLabelRule {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'metering_label_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'direction'?: MeteringMeteringLabelRulesCreateRequestMeteringLabelRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'excluded'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'source_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateRequestMeteringLabelRule
     */
    'destination_ip_prefix'?: any;
}

export const MeteringMeteringLabelRulesCreateRequestMeteringLabelRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type MeteringMeteringLabelRulesCreateRequestMeteringLabelRuleDirectionEnum = typeof MeteringMeteringLabelRulesCreateRequestMeteringLabelRuleDirectionEnum[keyof typeof MeteringMeteringLabelRulesCreateRequestMeteringLabelRuleDirectionEnum];

/**
 * Response of the metering/metering-label-rules:post operation
 * @export
 * @interface MeteringMeteringLabelRulesCreateResponse
 */
export interface MeteringMeteringLabelRulesCreateResponse {
    /**
     * 
     * @type {MeteringMeteringLabelRulesCreateResponseMeteringLabelRule}
     * @memberof MeteringMeteringLabelRulesCreateResponse
     */
    'metering_label_rule'?: MeteringMeteringLabelRulesCreateResponseMeteringLabelRule;
}
/**
 * 
 * @export
 * @interface MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
 */
export interface MeteringMeteringLabelRulesCreateResponseMeteringLabelRule {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'metering_label_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'direction'?: MeteringMeteringLabelRulesCreateResponseMeteringLabelRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'excluded'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'source_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesCreateResponseMeteringLabelRule
     */
    'destination_ip_prefix'?: any;
}

export const MeteringMeteringLabelRulesCreateResponseMeteringLabelRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type MeteringMeteringLabelRulesCreateResponseMeteringLabelRuleDirectionEnum = typeof MeteringMeteringLabelRulesCreateResponseMeteringLabelRuleDirectionEnum[keyof typeof MeteringMeteringLabelRulesCreateResponseMeteringLabelRuleDirectionEnum];

/**
 * Response of the metering/metering-label-rules:get operation
 * @export
 * @interface MeteringMeteringLabelRulesIndexResponse
 */
export interface MeteringMeteringLabelRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelRulesIndexResponse
     */
    'metering_label_rules'?: any;
}
/**
 * Response of the metering/metering-labels/id:get operation
 * @export
 * @interface MeteringMeteringLabelShowResponse
 */
export interface MeteringMeteringLabelShowResponse {
    /**
     * 
     * @type {MeteringMeteringLabelsCreateResponseMeteringLabel}
     * @memberof MeteringMeteringLabelShowResponse
     */
    'metering_label'?: MeteringMeteringLabelsCreateResponseMeteringLabel;
}
/**
 * Request of the metering/metering-labels/id:put operation
 * @export
 * @interface MeteringMeteringLabelUpdateRequest
 */
export interface MeteringMeteringLabelUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelUpdateRequest
     */
    'metering_label'?: any;
}
/**
 * Response of the metering/metering-labels/id:put operation
 * @export
 * @interface MeteringMeteringLabelUpdateResponse
 */
export interface MeteringMeteringLabelUpdateResponse {
    /**
     * 
     * @type {MeteringMeteringLabelsCreateResponseMeteringLabel}
     * @memberof MeteringMeteringLabelUpdateResponse
     */
    'metering_label'?: MeteringMeteringLabelsCreateResponseMeteringLabel;
}
/**
 * Request of the metering/metering-labels:post operation
 * @export
 * @interface MeteringMeteringLabelsCreateRequest
 */
export interface MeteringMeteringLabelsCreateRequest {
    /**
     * 
     * @type {MeteringMeteringLabelsCreateRequestMeteringLabel}
     * @memberof MeteringMeteringLabelsCreateRequest
     */
    'metering_label'?: MeteringMeteringLabelsCreateRequestMeteringLabel;
}
/**
 * 
 * @export
 * @interface MeteringMeteringLabelsCreateRequestMeteringLabel
 */
export interface MeteringMeteringLabelsCreateRequestMeteringLabel {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateRequestMeteringLabel
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateRequestMeteringLabel
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateRequestMeteringLabel
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateRequestMeteringLabel
     */
    'shared'?: any;
}
/**
 * Response of the metering/metering-labels:post operation
 * @export
 * @interface MeteringMeteringLabelsCreateResponse
 */
export interface MeteringMeteringLabelsCreateResponse {
    /**
     * 
     * @type {MeteringMeteringLabelsCreateResponseMeteringLabel}
     * @memberof MeteringMeteringLabelsCreateResponse
     */
    'metering_label'?: MeteringMeteringLabelsCreateResponseMeteringLabel;
}
/**
 * 
 * @export
 * @interface MeteringMeteringLabelsCreateResponseMeteringLabel
 */
export interface MeteringMeteringLabelsCreateResponseMeteringLabel {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateResponseMeteringLabel
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateResponseMeteringLabel
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateResponseMeteringLabel
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateResponseMeteringLabel
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsCreateResponseMeteringLabel
     */
    'shared'?: any;
}
/**
 * Response of the metering/metering-labels:get operation
 * @export
 * @interface MeteringMeteringLabelsIndexResponse
 */
export interface MeteringMeteringLabelsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof MeteringMeteringLabelsIndexResponse
     */
    'metering_labels'?: any;
}
/**
 * Request of the ndp-proxies:post operation
 * @export
 * @interface NdpProxiesCreateRequest
 */
export interface NdpProxiesCreateRequest {
    /**
     * 
     * @type {NdpProxiesCreateRequestNdpProxy}
     * @memberof NdpProxiesCreateRequest
     */
    'ndp_proxy'?: NdpProxiesCreateRequestNdpProxy;
}
/**
 * 
 * @export
 * @interface NdpProxiesCreateRequestNdpProxy
 */
export interface NdpProxiesCreateRequestNdpProxy {
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'router_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateRequestNdpProxy
     */
    'description'?: any;
}
/**
 * Response of the ndp-proxies:post operation
 * @export
 * @interface NdpProxiesCreateResponse
 */
export interface NdpProxiesCreateResponse {
    /**
     * 
     * @type {NdpProxiesCreateResponseNdpProxy}
     * @memberof NdpProxiesCreateResponse
     */
    'ndp_proxy'?: NdpProxiesCreateResponseNdpProxy;
}
/**
 * 
 * @export
 * @interface NdpProxiesCreateResponseNdpProxy
 */
export interface NdpProxiesCreateResponseNdpProxy {
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'router_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'port_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'ip_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesCreateResponseNdpProxy
     */
    'updated_at'?: any;
}
/**
 * Response of the ndp-proxies:get operation
 * @export
 * @interface NdpProxiesIndexResponse
 */
export interface NdpProxiesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NdpProxiesIndexResponse
     */
    'ndp_proxies'?: any;
}
/**
 * Response of the ndp-proxies/id:get operation
 * @export
 * @interface NdpProxyShowResponse
 */
export interface NdpProxyShowResponse {
    /**
     * 
     * @type {NdpProxiesCreateResponseNdpProxy}
     * @memberof NdpProxyShowResponse
     */
    'ndp_proxy'?: NdpProxiesCreateResponseNdpProxy;
}
/**
 * Request of the ndp-proxies/id:put operation
 * @export
 * @interface NdpProxyUpdateRequest
 */
export interface NdpProxyUpdateRequest {
    /**
     * 
     * @type {NdpProxyUpdateRequestNdpProxy}
     * @memberof NdpProxyUpdateRequest
     */
    'ndp_proxy'?: NdpProxyUpdateRequestNdpProxy;
}
/**
 * 
 * @export
 * @interface NdpProxyUpdateRequestNdpProxy
 */
export interface NdpProxyUpdateRequestNdpProxy {
    /**
     * 
     * @type {any}
     * @memberof NdpProxyUpdateRequestNdpProxy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NdpProxyUpdateRequestNdpProxy
     */
    'description'?: any;
}
/**
 * Response of the ndp-proxies/id:put operation
 * @export
 * @interface NdpProxyUpdateResponse
 */
export interface NdpProxyUpdateResponse {
    /**
     * 
     * @type {NdpProxiesCreateResponseNdpProxy}
     * @memberof NdpProxyUpdateResponse
     */
    'ndp_proxy'?: NdpProxiesCreateResponseNdpProxy;
}
/**
 * Request of the network-ip-availabilities:post operation
 * @export
 * @interface NetworkIpAvailabilitiesCreateRequest
 */
export interface NetworkIpAvailabilitiesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateRequest
     */
    'network_ip_availability'?: any;
}
/**
 * Response of the network-ip-availabilities:post operation
 * @export
 * @interface NetworkIpAvailabilitiesCreateResponse
 */
export interface NetworkIpAvailabilitiesCreateResponse {
    /**
     * 
     * @type {NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability}
     * @memberof NetworkIpAvailabilitiesCreateResponse
     */
    'network_ip_availability'?: NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability;
}
/**
 * 
 * @export
 * @interface NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
 */
export interface NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability {
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'network_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'total_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'used_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability
     */
    'subnet_ip_availability'?: any;
}
/**
 * Response of the network-ip-availabilities:get operation
 * @export
 * @interface NetworkIpAvailabilitiesIndexResponse
 */
export interface NetworkIpAvailabilitiesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilitiesIndexResponse
     */
    'network_ip_availabilities'?: any;
}
/**
 * Response of the network-ip-availabilities/id:get operation
 * @export
 * @interface NetworkIpAvailabilityShowResponse
 */
export interface NetworkIpAvailabilityShowResponse {
    /**
     * 
     * @type {NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability}
     * @memberof NetworkIpAvailabilityShowResponse
     */
    'network_ip_availability'?: NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability;
}
/**
 * Request of the network-ip-availabilities/id:put operation
 * @export
 * @interface NetworkIpAvailabilityUpdateRequest
 */
export interface NetworkIpAvailabilityUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof NetworkIpAvailabilityUpdateRequest
     */
    'network_ip_availability'?: any;
}
/**
 * Response of the network-ip-availabilities/id:put operation
 * @export
 * @interface NetworkIpAvailabilityUpdateResponse
 */
export interface NetworkIpAvailabilityUpdateResponse {
    /**
     * 
     * @type {NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability}
     * @memberof NetworkIpAvailabilityUpdateResponse
     */
    'network_ip_availability'?: NetworkIpAvailabilitiesCreateResponseNetworkIpAvailability;
}
/**
 * Response of the network-segment-ranges/id:get operation
 * @export
 * @interface NetworkSegmentRangeShowResponse
 */
export interface NetworkSegmentRangeShowResponse {
    /**
     * 
     * @type {NetworkSegmentRangesCreateResponseNetworkSegmentRange}
     * @memberof NetworkSegmentRangeShowResponse
     */
    'network_segment_range'?: NetworkSegmentRangesCreateResponseNetworkSegmentRange;
}
/**
 * Request of the network-segment-ranges/id:put operation
 * @export
 * @interface NetworkSegmentRangeUpdateRequest
 */
export interface NetworkSegmentRangeUpdateRequest {
    /**
     * 
     * @type {NetworkSegmentRangeUpdateRequestNetworkSegmentRange}
     * @memberof NetworkSegmentRangeUpdateRequest
     */
    'network_segment_range'?: NetworkSegmentRangeUpdateRequestNetworkSegmentRange;
}
/**
 * 
 * @export
 * @interface NetworkSegmentRangeUpdateRequestNetworkSegmentRange
 */
export interface NetworkSegmentRangeUpdateRequestNetworkSegmentRange {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangeUpdateRequestNetworkSegmentRange
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangeUpdateRequestNetworkSegmentRange
     */
    'minimum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangeUpdateRequestNetworkSegmentRange
     */
    'maximum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangeUpdateRequestNetworkSegmentRange
     */
    'description'?: any;
}
/**
 * Response of the network-segment-ranges/id:put operation
 * @export
 * @interface NetworkSegmentRangeUpdateResponse
 */
export interface NetworkSegmentRangeUpdateResponse {
    /**
     * 
     * @type {NetworkSegmentRangesCreateResponseNetworkSegmentRange}
     * @memberof NetworkSegmentRangeUpdateResponse
     */
    'network_segment_range'?: NetworkSegmentRangesCreateResponseNetworkSegmentRange;
}
/**
 * Request of the network-segment-ranges:post operation
 * @export
 * @interface NetworkSegmentRangesCreateRequest
 */
export interface NetworkSegmentRangesCreateRequest {
    /**
     * 
     * @type {NetworkSegmentRangesCreateRequestNetworkSegmentRange}
     * @memberof NetworkSegmentRangesCreateRequest
     */
    'network_segment_range'?: NetworkSegmentRangesCreateRequestNetworkSegmentRange;
}
/**
 * 
 * @export
 * @interface NetworkSegmentRangesCreateRequestNetworkSegmentRange
 */
export interface NetworkSegmentRangesCreateRequestNetworkSegmentRange {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'network_type'?: NetworkSegmentRangesCreateRequestNetworkSegmentRangeNetworkTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'minimum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'maximum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateRequestNetworkSegmentRange
     */
    'description'?: any;
}

export const NetworkSegmentRangesCreateRequestNetworkSegmentRangeNetworkTypeEnum = {
    Vlan: 'vlan',
    Vxlan: 'vxlan',
    Gre: 'gre',
    Geneve: 'geneve'
} as const;

export type NetworkSegmentRangesCreateRequestNetworkSegmentRangeNetworkTypeEnum = typeof NetworkSegmentRangesCreateRequestNetworkSegmentRangeNetworkTypeEnum[keyof typeof NetworkSegmentRangesCreateRequestNetworkSegmentRangeNetworkTypeEnum];

/**
 * Response of the network-segment-ranges:post operation
 * @export
 * @interface NetworkSegmentRangesCreateResponse
 */
export interface NetworkSegmentRangesCreateResponse {
    /**
     * 
     * @type {NetworkSegmentRangesCreateResponseNetworkSegmentRange}
     * @memberof NetworkSegmentRangesCreateResponse
     */
    'network_segment_range'?: NetworkSegmentRangesCreateResponseNetworkSegmentRange;
}
/**
 * 
 * @export
 * @interface NetworkSegmentRangesCreateResponseNetworkSegmentRange
 */
export interface NetworkSegmentRangesCreateResponseNetworkSegmentRange {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'default'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'network_type'?: NetworkSegmentRangesCreateResponseNetworkSegmentRangeNetworkTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'minimum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'maximum'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'used'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'available'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesCreateResponseNetworkSegmentRange
     */
    'description'?: any;
}

export const NetworkSegmentRangesCreateResponseNetworkSegmentRangeNetworkTypeEnum = {
    Vlan: 'vlan',
    Vxlan: 'vxlan',
    Gre: 'gre',
    Geneve: 'geneve'
} as const;

export type NetworkSegmentRangesCreateResponseNetworkSegmentRangeNetworkTypeEnum = typeof NetworkSegmentRangesCreateResponseNetworkSegmentRangeNetworkTypeEnum[keyof typeof NetworkSegmentRangesCreateResponseNetworkSegmentRangeNetworkTypeEnum];

/**
 * Response of the network-segment-ranges:get operation
 * @export
 * @interface NetworkSegmentRangesIndexResponse
 */
export interface NetworkSegmentRangesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesIndexResponse
     */
    'network_segment_ranges'?: any;
}
/**
 * Response of the network_segment_ranges/network_segment_range_id/tags:get operation
 * @export
 * @interface NetworkSegmentRangesTagsIndexResponse
 */
export interface NetworkSegmentRangesTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the network_segment_ranges/network_segment_range_id/tags:put operation
 * @export
 * @interface NetworkSegmentRangesTagsUpdateAllRequest
 */
export interface NetworkSegmentRangesTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the network_segment_ranges/network_segment_range_id/tags:put operation
 * @export
 * @interface NetworkSegmentRangesTagsUpdateAllResponse
 */
export interface NetworkSegmentRangesTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworkSegmentRangesTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the networks/network_id:get operation
 * @export
 * @interface NetworkShowResponse
 */
export interface NetworkShowResponse {
    /**
     * 
     * @type {NetworksCreateResponseNetwork}
     * @memberof NetworkShowResponse
     */
    'network'?: NetworksCreateResponseNetwork;
}
/**
 * Request of the networks/network_id:put operation
 * @export
 * @interface NetworkUpdateRequest
 */
export interface NetworkUpdateRequest {
    /**
     * 
     * @type {NetworkUpdateRequestNetwork}
     * @memberof NetworkUpdateRequest
     */
    'network'?: NetworkUpdateRequestNetwork;
}
/**
 * 
 * @export
 * @interface NetworkUpdateRequestNetwork
 */
export interface NetworkUpdateRequestNetwork {
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'router:external'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'segments'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'mtu'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'provider:network_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'provider:physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'provider:segmentation_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworkUpdateRequestNetwork
     */
    'description'?: any;
}
/**
 * Response of the networks/network_id:put operation
 * @export
 * @interface NetworkUpdateResponse
 */
export interface NetworkUpdateResponse {
    /**
     * 
     * @type {NetworksCreateResponseNetwork}
     * @memberof NetworkUpdateResponse
     */
    'network'?: NetworksCreateResponseNetwork;
}
/**
 * Request of the networks:post operation
 * @export
 * @interface NetworksCreateRequest
 */
export interface NetworksCreateRequest {
    /**
     * 
     * @type {NetworksCreateRequestNetwork}
     * @memberof NetworksCreateRequest
     */
    'network'?: NetworksCreateRequestNetwork;
}
/**
 * 
 * @export
 * @interface NetworksCreateRequestNetwork
 */
export interface NetworksCreateRequestNetwork {
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'router:external'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'segments'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'mtu'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'availability_zone_hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'ha'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'provider:network_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'provider:physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'provider:segmentation_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateRequestNetwork
     */
    'description'?: any;
}
/**
 * Response of the networks:post operation
 * @export
 * @interface NetworksCreateResponse
 */
export interface NetworksCreateResponse {
    /**
     * 
     * @type {NetworksCreateResponseNetwork}
     * @memberof NetworksCreateResponse
     */
    'network'?: NetworksCreateResponseNetwork;
}
/**
 * 
 * @export
 * @interface NetworksCreateResponseNetwork
 */
export interface NetworksCreateResponseNetwork {
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'subnets'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'ipv4_address_scope'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'ipv6_address_scope'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'router:external'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'l2_adjacency'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'segments'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'mtu'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'availability_zones'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'availability_zone_hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'provider:network_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'provider:physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'provider:segmentation_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof NetworksCreateResponseNetwork
     */
    'description'?: any;
}
/**
 * Response of the networks:get operation
 * @export
 * @interface NetworksIndexResponse
 */
export interface NetworksIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworksIndexResponse
     */
    'networks'?: any;
}
/**
 * Response of the networks/network_id/tags:get operation
 * @export
 * @interface NetworksTagsIndexResponse
 */
export interface NetworksTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworksTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the networks/network_id/tags:put operation
 * @export
 * @interface NetworksTagsUpdateAllRequest
 */
export interface NetworksTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof NetworksTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the networks/network_id/tags:put operation
 * @export
 * @interface NetworksTagsUpdateAllResponse
 */
export interface NetworksTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof NetworksTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the policies/policy_id/packet_rate_limit_rules/id:get operation
 * @export
 * @interface PoliciesPacketRateLimitRuleShowResponse
 */
export interface PoliciesPacketRateLimitRuleShowResponse {
    /**
     * 
     * @type {PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule}
     * @memberof PoliciesPacketRateLimitRuleShowResponse
     */
    'packet_rate_limit_rule'?: PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule;
}
/**
 * Request of the policies/policy_id/packet_rate_limit_rules/id:put operation
 * @export
 * @interface PoliciesPacketRateLimitRuleUpdateRequest
 */
export interface PoliciesPacketRateLimitRuleUpdateRequest {
    /**
     * 
     * @type {PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule}
     * @memberof PoliciesPacketRateLimitRuleUpdateRequest
     */
    'packet_rate_limit_rule'?: PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule;
}
/**
 * Response of the policies/policy_id/packet_rate_limit_rules/id:put operation
 * @export
 * @interface PoliciesPacketRateLimitRuleUpdateResponse
 */
export interface PoliciesPacketRateLimitRuleUpdateResponse {
    /**
     * 
     * @type {PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule}
     * @memberof PoliciesPacketRateLimitRuleUpdateResponse
     */
    'packet_rate_limit_rule'?: PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule;
}
/**
 * Request of the policies/policy_id/packet_rate_limit_rules:post operation
 * @export
 * @interface PoliciesPacketRateLimitRulesCreateRequest
 */
export interface PoliciesPacketRateLimitRulesCreateRequest {
    /**
     * 
     * @type {PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule}
     * @memberof PoliciesPacketRateLimitRulesCreateRequest
     */
    'packet_rate_limit_rule'?: PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule;
}
/**
 * 
 * @export
 * @interface PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule
 */
export interface PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule {
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule
     */
    'max_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule
     */
    'max_burst_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRule
     */
    'direction'?: PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRuleDirectionEnum;
}

export const PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRuleDirectionEnum = typeof PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRuleDirectionEnum[keyof typeof PoliciesPacketRateLimitRulesCreateRequestPacketRateLimitRuleDirectionEnum];

/**
 * Response of the policies/policy_id/packet_rate_limit_rules:post operation
 * @export
 * @interface PoliciesPacketRateLimitRulesCreateResponse
 */
export interface PoliciesPacketRateLimitRulesCreateResponse {
    /**
     * 
     * @type {PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule}
     * @memberof PoliciesPacketRateLimitRulesCreateResponse
     */
    'packet_rate_limit_rule'?: PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule;
}
/**
 * 
 * @export
 * @interface PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule
 */
export interface PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule {
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule
     */
    'max_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule
     */
    'max_burst_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRule
     */
    'direction'?: PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRuleDirectionEnum;
}

export const PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRuleDirectionEnum = typeof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRuleDirectionEnum[keyof typeof PoliciesPacketRateLimitRulesCreateResponsePacketRateLimitRuleDirectionEnum];

/**
 * Response of the policies/policy_id/packet_rate_limit_rules:get operation
 * @export
 * @interface PoliciesPacketRateLimitRulesIndexResponse
 */
export interface PoliciesPacketRateLimitRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof PoliciesPacketRateLimitRulesIndexResponse
     */
    'packet_rate_limit_rules'?: any;
}
/**
 * Response of the policies/policy_id/tags:get operation
 * @export
 * @interface PoliciesTagsIndexResponse
 */
export interface PoliciesTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof PoliciesTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the policies/policy_id/tags:put operation
 * @export
 * @interface PoliciesTagsUpdateAllRequest
 */
export interface PoliciesTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof PoliciesTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the policies/policy_id/tags:put operation
 * @export
 * @interface PoliciesTagsUpdateAllResponse
 */
export interface PoliciesTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof PoliciesTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the ports/port_id:get operation
 * @export
 * @interface PortShowResponse
 */
export interface PortShowResponse {
    /**
     * 
     * @type {PortsCreateResponsePort}
     * @memberof PortShowResponse
     */
    'port'?: PortsCreateResponsePort;
}
/**
 * Request of the ports/port_id:put operation
 * @export
 * @interface PortUpdateRequest
 */
export interface PortUpdateRequest {
    /**
     * 
     * @type {PortUpdateRequestPort}
     * @memberof PortUpdateRequest
     */
    'port'?: PortUpdateRequestPort;
}
/**
 * 
 * @export
 * @interface PortUpdateRequestPort
 */
export interface PortUpdateRequestPort {
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'mac_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'device_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'device_owner'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'allowed_address_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'data_plane_status'?: PortUpdateRequestPortDataPlaneStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'extra_dhcp_opts'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'numa_affinity_policy'?: PortUpdateRequestPortNumaAffinityPolicyEnum;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'binding:vnic_type'?: PortUpdateRequestPortBindingvnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'binding:host_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'binding:profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'dns_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortUpdateRequestPort
     */
    'security_groups'?: any;
}

export const PortUpdateRequestPortDataPlaneStatusEnum = {
    Null: 'null',
    Active: 'ACTIVE',
    Down: 'DOWN'
} as const;

export type PortUpdateRequestPortDataPlaneStatusEnum = typeof PortUpdateRequestPortDataPlaneStatusEnum[keyof typeof PortUpdateRequestPortDataPlaneStatusEnum];
export const PortUpdateRequestPortNumaAffinityPolicyEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Legacy: 'legacy',
    Socket: 'socket',
    Null: 'null'
} as const;

export type PortUpdateRequestPortNumaAffinityPolicyEnum = typeof PortUpdateRequestPortNumaAffinityPolicyEnum[keyof typeof PortUpdateRequestPortNumaAffinityPolicyEnum];
export const PortUpdateRequestPortBindingvnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortUpdateRequestPortBindingvnicTypeEnum = typeof PortUpdateRequestPortBindingvnicTypeEnum[keyof typeof PortUpdateRequestPortBindingvnicTypeEnum];

/**
 * Response of the ports/port_id:put operation
 * @export
 * @interface PortUpdateResponse
 */
export interface PortUpdateResponse {
    /**
     * 
     * @type {PortsCreateResponsePort}
     * @memberof PortUpdateResponse
     */
    'port'?: PortsCreateResponsePort;
}
/**
 * Response of the ports/port_id/bindings/id:get operation
 * @export
 * @interface PortsBindingShowResponse
 */
export interface PortsBindingShowResponse {
    /**
     * 
     * @type {PortsBindingsCreateResponseBinding}
     * @memberof PortsBindingShowResponse
     */
    'binding'?: PortsBindingsCreateResponseBinding;
}
/**
 * Request of the ports/port_id/bindings/id:put operation
 * @export
 * @interface PortsBindingUpdateRequest
 */
export interface PortsBindingUpdateRequest {
    /**
     * 
     * @type {PortsBindingUpdateRequestBinding}
     * @memberof PortsBindingUpdateRequest
     */
    'binding'?: PortsBindingUpdateRequestBinding;
}
/**
 * 
 * @export
 * @interface PortsBindingUpdateRequestBinding
 */
export interface PortsBindingUpdateRequestBinding {
    /**
     * 
     * @type {any}
     * @memberof PortsBindingUpdateRequestBinding
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingUpdateRequestBinding
     */
    'vnic_type'?: PortsBindingUpdateRequestBindingVnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingUpdateRequestBinding
     */
    'profile'?: any;
}

export const PortsBindingUpdateRequestBindingVnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortsBindingUpdateRequestBindingVnicTypeEnum = typeof PortsBindingUpdateRequestBindingVnicTypeEnum[keyof typeof PortsBindingUpdateRequestBindingVnicTypeEnum];

/**
 * Response of the ports/port_id/bindings/id:put operation
 * @export
 * @interface PortsBindingUpdateResponse
 */
export interface PortsBindingUpdateResponse {
    /**
     * 
     * @type {PortsBindingsCreateResponseBinding}
     * @memberof PortsBindingUpdateResponse
     */
    'binding'?: PortsBindingsCreateResponseBinding;
}
/**
 * 
 * @export
 * @interface PortsBindingsActivateActivateRequest
 */
export interface PortsBindingsActivateActivateRequest {
    /**
     * The hostname of the system the agent is running on.
     * @type {any}
     * @memberof PortsBindingsActivateActivateRequest
     */
    'host'?: any;
}
/**
 * Request of the ports/port_id/bindings:post operation
 * @export
 * @interface PortsBindingsCreateRequest
 */
export interface PortsBindingsCreateRequest {
    /**
     * 
     * @type {PortsBindingsCreateRequestBinding}
     * @memberof PortsBindingsCreateRequest
     */
    'binding'?: PortsBindingsCreateRequestBinding;
}
/**
 * 
 * @export
 * @interface PortsBindingsCreateRequestBinding
 */
export interface PortsBindingsCreateRequestBinding {
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateRequestBinding
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateRequestBinding
     */
    'vnic_type'?: PortsBindingsCreateRequestBindingVnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateRequestBinding
     */
    'profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateRequestBinding
     */
    'project_id'?: any;
}

export const PortsBindingsCreateRequestBindingVnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortsBindingsCreateRequestBindingVnicTypeEnum = typeof PortsBindingsCreateRequestBindingVnicTypeEnum[keyof typeof PortsBindingsCreateRequestBindingVnicTypeEnum];

/**
 * Response of the ports/port_id/bindings:post operation
 * @export
 * @interface PortsBindingsCreateResponse
 */
export interface PortsBindingsCreateResponse {
    /**
     * 
     * @type {PortsBindingsCreateResponseBinding}
     * @memberof PortsBindingsCreateResponse
     */
    'binding'?: PortsBindingsCreateResponseBinding;
}
/**
 * 
 * @export
 * @interface PortsBindingsCreateResponseBinding
 */
export interface PortsBindingsCreateResponseBinding {
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'host'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'vif_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'vif_details'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'vnic_type'?: PortsBindingsCreateResponseBindingVnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsCreateResponseBinding
     */
    'project_id'?: any;
}

export const PortsBindingsCreateResponseBindingVnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortsBindingsCreateResponseBindingVnicTypeEnum = typeof PortsBindingsCreateResponseBindingVnicTypeEnum[keyof typeof PortsBindingsCreateResponseBindingVnicTypeEnum];

/**
 * Response of the ports/port_id/bindings:get operation
 * @export
 * @interface PortsBindingsIndexResponse
 */
export interface PortsBindingsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof PortsBindingsIndexResponse
     */
    'bindings'?: any;
}
/**
 * Request of the ports:post operation
 * @export
 * @interface PortsCreateRequest
 */
export interface PortsCreateRequest {
    /**
     * 
     * @type {PortsCreateRequestPort}
     * @memberof PortsCreateRequest
     */
    'port'?: PortsCreateRequestPort;
}
/**
 * 
 * @export
 * @interface PortsCreateRequestPort
 */
export interface PortsCreateRequestPort {
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'mac_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'device_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'device_owner'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'allowed_address_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'extra_dhcp_opts'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'device_profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'numa_affinity_policy'?: PortsCreateRequestPortNumaAffinityPolicyEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'binding:vnic_type'?: PortsCreateRequestPortBindingvnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'binding:host_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'binding:profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'propagate_uplink_status'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'dns_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateRequestPort
     */
    'security_groups'?: any;
}

export const PortsCreateRequestPortNumaAffinityPolicyEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Legacy: 'legacy',
    Socket: 'socket',
    Null: 'null'
} as const;

export type PortsCreateRequestPortNumaAffinityPolicyEnum = typeof PortsCreateRequestPortNumaAffinityPolicyEnum[keyof typeof PortsCreateRequestPortNumaAffinityPolicyEnum];
export const PortsCreateRequestPortBindingvnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortsCreateRequestPortBindingvnicTypeEnum = typeof PortsCreateRequestPortBindingvnicTypeEnum[keyof typeof PortsCreateRequestPortBindingvnicTypeEnum];

/**
 * Response of the ports:post operation
 * @export
 * @interface PortsCreateResponse
 */
export interface PortsCreateResponse {
    /**
     * 
     * @type {PortsCreateResponsePort}
     * @memberof PortsCreateResponse
     */
    'port'?: PortsCreateResponsePort;
}
/**
 * 
 * @export
 * @interface PortsCreateResponsePort
 */
export interface PortsCreateResponsePort {
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'mac_address'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'fixed_ips'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'device_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'device_owner'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'allowed_address_pairs'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'data_plane_status'?: PortsCreateResponsePortDataPlaneStatusEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'extra_dhcp_opts'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'ip_allocation'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'device_profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'numa_affinity_policy'?: PortsCreateResponsePortNumaAffinityPolicyEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'resource_request'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'binding:vif_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'binding:vif_details'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'binding:vnic_type'?: PortsCreateResponsePortBindingvnicTypeEnum;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'binding:host_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'binding:profile'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'port_security_enabled'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'qos_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'qos_network_policy_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'propagate_uplink_status'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'dns_name'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'dns_assignment'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'dns_domain'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof PortsCreateResponsePort
     */
    'security_groups'?: any;
}

export const PortsCreateResponsePortDataPlaneStatusEnum = {
    Null: 'null',
    Active: 'ACTIVE',
    Down: 'DOWN'
} as const;

export type PortsCreateResponsePortDataPlaneStatusEnum = typeof PortsCreateResponsePortDataPlaneStatusEnum[keyof typeof PortsCreateResponsePortDataPlaneStatusEnum];
export const PortsCreateResponsePortNumaAffinityPolicyEnum = {
    Required: 'required',
    Preferred: 'preferred',
    Legacy: 'legacy',
    Socket: 'socket',
    Null: 'null'
} as const;

export type PortsCreateResponsePortNumaAffinityPolicyEnum = typeof PortsCreateResponsePortNumaAffinityPolicyEnum[keyof typeof PortsCreateResponsePortNumaAffinityPolicyEnum];
export const PortsCreateResponsePortBindingvnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;

export type PortsCreateResponsePortBindingvnicTypeEnum = typeof PortsCreateResponsePortBindingvnicTypeEnum[keyof typeof PortsCreateResponsePortBindingvnicTypeEnum];

/**
 * Response of the ports:get operation
 * @export
 * @interface PortsIndexResponse
 */
export interface PortsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof PortsIndexResponse
     */
    'ports'?: any;
}
/**
 * Response of the ports/port_id/tags:get operation
 * @export
 * @interface PortsTagsIndexResponse
 */
export interface PortsTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof PortsTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the ports/port_id/tags:put operation
 * @export
 * @interface PortsTagsUpdateAllRequest
 */
export interface PortsTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof PortsTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the ports/port_id/tags:put operation
 * @export
 * @interface PortsTagsUpdateAllResponse
 */
export interface PortsTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof PortsTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the qos/alias-bandwidth-limit-rules/id:get operation
 * @export
 * @interface QosAliasBandwidthLimitRuleShowResponse
 */
export interface QosAliasBandwidthLimitRuleShowResponse {
    /**
     * 
     * @type {QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule}
     * @memberof QosAliasBandwidthLimitRuleShowResponse
     */
    'alias_bandwidth_limit_rule'?: QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule;
}
/**
 * Request of the qos/alias-bandwidth-limit-rules/id:put operation
 * @export
 * @interface QosAliasBandwidthLimitRuleUpdateRequest
 */
export interface QosAliasBandwidthLimitRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule}
     * @memberof QosAliasBandwidthLimitRuleUpdateRequest
     */
    'alias_bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule;
}
/**
 * Response of the qos/alias-bandwidth-limit-rules/id:put operation
 * @export
 * @interface QosAliasBandwidthLimitRuleUpdateResponse
 */
export interface QosAliasBandwidthLimitRuleUpdateResponse {
    /**
     * 
     * @type {QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule}
     * @memberof QosAliasBandwidthLimitRuleUpdateResponse
     */
    'alias_bandwidth_limit_rule'?: QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule;
}
/**
 * Request of the qos/alias-bandwidth-limit-rules:post operation
 * @export
 * @interface QosAliasBandwidthLimitRulesCreateRequest
 */
export interface QosAliasBandwidthLimitRulesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateRequest
     */
    'alias_bandwidth_limit_rule'?: any;
}
/**
 * Response of the qos/alias-bandwidth-limit-rules:post operation
 * @export
 * @interface QosAliasBandwidthLimitRulesCreateResponse
 */
export interface QosAliasBandwidthLimitRulesCreateResponse {
    /**
     * 
     * @type {QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule}
     * @memberof QosAliasBandwidthLimitRulesCreateResponse
     */
    'alias_bandwidth_limit_rule'?: QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule;
}
/**
 * 
 * @export
 * @interface QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
 */
export interface QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule {
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
     */
    'max_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
     */
    'direction'?: QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRule
     */
    'max_burst_kbps'?: any;
}

export const QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRuleDirectionEnum = typeof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRuleDirectionEnum[keyof typeof QosAliasBandwidthLimitRulesCreateResponseAliasBandwidthLimitRuleDirectionEnum];

/**
 * Response of the qos/alias-bandwidth-limit-rules:get operation
 * @export
 * @interface QosAliasBandwidthLimitRulesIndexResponse
 */
export interface QosAliasBandwidthLimitRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosAliasBandwidthLimitRulesIndexResponse
     */
    'alias_bandwidth_limit_rules'?: any;
}
/**
 * Response of the qos/alias-dscp-marking-rules/id:get operation
 * @export
 * @interface QosAliasDscpMarkingRuleShowResponse
 */
export interface QosAliasDscpMarkingRuleShowResponse {
    /**
     * 
     * @type {QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule}
     * @memberof QosAliasDscpMarkingRuleShowResponse
     */
    'alias_dscp_marking_rule'?: QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule;
}
/**
 * Request of the qos/alias-dscp-marking-rules/id:put operation
 * @export
 * @interface QosAliasDscpMarkingRuleUpdateRequest
 */
export interface QosAliasDscpMarkingRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule}
     * @memberof QosAliasDscpMarkingRuleUpdateRequest
     */
    'alias_dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule;
}
/**
 * Response of the qos/alias-dscp-marking-rules/id:put operation
 * @export
 * @interface QosAliasDscpMarkingRuleUpdateResponse
 */
export interface QosAliasDscpMarkingRuleUpdateResponse {
    /**
     * 
     * @type {QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule}
     * @memberof QosAliasDscpMarkingRuleUpdateResponse
     */
    'alias_dscp_marking_rule'?: QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule;
}
/**
 * Request of the qos/alias-dscp-marking-rules:post operation
 * @export
 * @interface QosAliasDscpMarkingRulesCreateRequest
 */
export interface QosAliasDscpMarkingRulesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof QosAliasDscpMarkingRulesCreateRequest
     */
    'alias_dscp_marking_rule'?: any;
}
/**
 * Response of the qos/alias-dscp-marking-rules:post operation
 * @export
 * @interface QosAliasDscpMarkingRulesCreateResponse
 */
export interface QosAliasDscpMarkingRulesCreateResponse {
    /**
     * 
     * @type {QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule}
     * @memberof QosAliasDscpMarkingRulesCreateResponse
     */
    'alias_dscp_marking_rule'?: QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule;
}
/**
 * 
 * @export
 * @interface QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule
 */
export interface QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule {
    /**
     * 
     * @type {any}
     * @memberof QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRule
     */
    'dscp_mark'?: QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRuleDscpMarkEnum;
}

export const QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRuleDscpMarkEnum = {
    _0: '0',
    _8: '8',
    _10: '10',
    _12: '12',
    _14: '14',
    _16: '16',
    _18: '18',
    _20: '20',
    _22: '22',
    _24: '24',
    _26: '26',
    _28: '28',
    _30: '30',
    _32: '32',
    _34: '34',
    _36: '36',
    _38: '38',
    _40: '40',
    _44: '44',
    _46: '46',
    _48: '48',
    _56: '56'
} as const;

export type QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRuleDscpMarkEnum = typeof QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRuleDscpMarkEnum[keyof typeof QosAliasDscpMarkingRulesCreateResponseAliasDscpMarkingRuleDscpMarkEnum];

/**
 * Response of the qos/alias-dscp-marking-rules:get operation
 * @export
 * @interface QosAliasDscpMarkingRulesIndexResponse
 */
export interface QosAliasDscpMarkingRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosAliasDscpMarkingRulesIndexResponse
     */
    'alias_dscp_marking_rules'?: any;
}
/**
 * Response of the qos/alias-minimum-bandwidth-rules/id:get operation
 * @export
 * @interface QosAliasMinimumBandwidthRuleShowResponse
 */
export interface QosAliasMinimumBandwidthRuleShowResponse {
    /**
     * 
     * @type {QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule}
     * @memberof QosAliasMinimumBandwidthRuleShowResponse
     */
    'alias_minimum_bandwidth_rule'?: QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule;
}
/**
 * Request of the qos/alias-minimum-bandwidth-rules/id:put operation
 * @export
 * @interface QosAliasMinimumBandwidthRuleUpdateRequest
 */
export interface QosAliasMinimumBandwidthRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule}
     * @memberof QosAliasMinimumBandwidthRuleUpdateRequest
     */
    'alias_minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule;
}
/**
 * Response of the qos/alias-minimum-bandwidth-rules/id:put operation
 * @export
 * @interface QosAliasMinimumBandwidthRuleUpdateResponse
 */
export interface QosAliasMinimumBandwidthRuleUpdateResponse {
    /**
     * 
     * @type {QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule}
     * @memberof QosAliasMinimumBandwidthRuleUpdateResponse
     */
    'alias_minimum_bandwidth_rule'?: QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule;
}
/**
 * Request of the qos/alias-minimum-bandwidth-rules:post operation
 * @export
 * @interface QosAliasMinimumBandwidthRulesCreateRequest
 */
export interface QosAliasMinimumBandwidthRulesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesCreateRequest
     */
    'alias_minimum_bandwidth_rule'?: any;
}
/**
 * Response of the qos/alias-minimum-bandwidth-rules:post operation
 * @export
 * @interface QosAliasMinimumBandwidthRulesCreateResponse
 */
export interface QosAliasMinimumBandwidthRulesCreateResponse {
    /**
     * 
     * @type {QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule}
     * @memberof QosAliasMinimumBandwidthRulesCreateResponse
     */
    'alias_minimum_bandwidth_rule'?: QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule;
}
/**
 * 
 * @export
 * @interface QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule
 */
export interface QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule {
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule
     */
    'min_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRule
     */
    'direction'?: QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRuleDirectionEnum;
}

export const QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRuleDirectionEnum = typeof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRuleDirectionEnum[keyof typeof QosAliasMinimumBandwidthRulesCreateResponseAliasMinimumBandwidthRuleDirectionEnum];

/**
 * Response of the qos/alias-minimum-bandwidth-rules:get operation
 * @export
 * @interface QosAliasMinimumBandwidthRulesIndexResponse
 */
export interface QosAliasMinimumBandwidthRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumBandwidthRulesIndexResponse
     */
    'alias_minimum_bandwidth_rules'?: any;
}
/**
 * Response of the qos/alias-minimum-packet-rate-rules/id:get operation
 * @export
 * @interface QosAliasMinimumPacketRateRuleShowResponse
 */
export interface QosAliasMinimumPacketRateRuleShowResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosAliasMinimumPacketRateRuleShowResponse
     */
    'alias_minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * Request of the qos/alias-minimum-packet-rate-rules/id:put operation
 * @export
 * @interface QosAliasMinimumPacketRateRuleUpdateRequest
 */
export interface QosAliasMinimumPacketRateRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule}
     * @memberof QosAliasMinimumPacketRateRuleUpdateRequest
     */
    'alias_minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule;
}
/**
 * Response of the qos/alias-minimum-packet-rate-rules/id:put operation
 * @export
 * @interface QosAliasMinimumPacketRateRuleUpdateResponse
 */
export interface QosAliasMinimumPacketRateRuleUpdateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosAliasMinimumPacketRateRuleUpdateResponse
     */
    'alias_minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * Request of the qos/alias-minimum-packet-rate-rules:post operation
 * @export
 * @interface QosAliasMinimumPacketRateRulesCreateRequest
 */
export interface QosAliasMinimumPacketRateRulesCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumPacketRateRulesCreateRequest
     */
    'alias_minimum_packet_rate_rule'?: any;
}
/**
 * Response of the qos/alias-minimum-packet-rate-rules:post operation
 * @export
 * @interface QosAliasMinimumPacketRateRulesCreateResponse
 */
export interface QosAliasMinimumPacketRateRulesCreateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosAliasMinimumPacketRateRulesCreateResponse
     */
    'alias_minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * Response of the qos/alias-minimum-packet-rate-rules:get operation
 * @export
 * @interface QosAliasMinimumPacketRateRulesIndexResponse
 */
export interface QosAliasMinimumPacketRateRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosAliasMinimumPacketRateRulesIndexResponse
     */
    'alias_minimum_packet_rate_rules'?: any;
}
/**
 * Response of the qos/policies/policy_id/bandwidth_limit_rules/id:get operation
 * @export
 * @interface QosPoliciesBandwidthLimitRuleShowResponse
 */
export interface QosPoliciesBandwidthLimitRuleShowResponse {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule}
     * @memberof QosPoliciesBandwidthLimitRuleShowResponse
     */
    'bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule;
}
/**
 * Request of the qos/policies/policy_id/bandwidth_limit_rules/id:put operation
 * @export
 * @interface QosPoliciesBandwidthLimitRuleUpdateRequest
 */
export interface QosPoliciesBandwidthLimitRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule}
     * @memberof QosPoliciesBandwidthLimitRuleUpdateRequest
     */
    'bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule;
}
/**
 * Response of the qos/policies/policy_id/bandwidth_limit_rules/id:put operation
 * @export
 * @interface QosPoliciesBandwidthLimitRuleUpdateResponse
 */
export interface QosPoliciesBandwidthLimitRuleUpdateResponse {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule}
     * @memberof QosPoliciesBandwidthLimitRuleUpdateResponse
     */
    'bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule;
}
/**
 * Request of the qos/policies/policy_id/bandwidth_limit_rules:post operation
 * @export
 * @interface QosPoliciesBandwidthLimitRulesCreateRequest
 */
export interface QosPoliciesBandwidthLimitRulesCreateRequest {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule}
     * @memberof QosPoliciesBandwidthLimitRulesCreateRequest
     */
    'bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule
 */
export interface QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule
     */
    'max_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule
     */
    'max_burst_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRule
     */
    'direction'?: QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRuleDirectionEnum;
}

export const QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRuleDirectionEnum = typeof QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRuleDirectionEnum[keyof typeof QosPoliciesBandwidthLimitRulesCreateRequestBandwidthLimitRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/bandwidth_limit_rules:post operation
 * @export
 * @interface QosPoliciesBandwidthLimitRulesCreateResponse
 */
export interface QosPoliciesBandwidthLimitRulesCreateResponse {
    /**
     * 
     * @type {QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule}
     * @memberof QosPoliciesBandwidthLimitRulesCreateResponse
     */
    'bandwidth_limit_rule'?: QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule
 */
export interface QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule
     */
    'max_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule
     */
    'max_burst_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRule
     */
    'direction'?: QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRuleDirectionEnum;
}

export const QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRuleDirectionEnum = typeof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRuleDirectionEnum[keyof typeof QosPoliciesBandwidthLimitRulesCreateResponseBandwidthLimitRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/bandwidth_limit_rules:get operation
 * @export
 * @interface QosPoliciesBandwidthLimitRulesIndexResponse
 */
export interface QosPoliciesBandwidthLimitRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesBandwidthLimitRulesIndexResponse
     */
    'bandwidth_limit_rules'?: any;
}
/**
 * Request of the qos/policies:post operation
 * @export
 * @interface QosPoliciesCreateRequest
 */
export interface QosPoliciesCreateRequest {
    /**
     * 
     * @type {QosPoliciesCreateRequestPolicy}
     * @memberof QosPoliciesCreateRequest
     */
    'policy'?: QosPoliciesCreateRequestPolicy;
}
/**
 * 
 * @export
 * @interface QosPoliciesCreateRequestPolicy
 */
export interface QosPoliciesCreateRequestPolicy {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateRequestPolicy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateRequestPolicy
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateRequestPolicy
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateRequestPolicy
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateRequestPolicy
     */
    'description'?: any;
}
/**
 * Response of the qos/policies:post operation
 * @export
 * @interface QosPoliciesCreateResponse
 */
export interface QosPoliciesCreateResponse {
    /**
     * 
     * @type {QosPoliciesCreateResponsePolicy}
     * @memberof QosPoliciesCreateResponse
     */
    'policy'?: QosPoliciesCreateResponsePolicy;
}
/**
 * 
 * @export
 * @interface QosPoliciesCreateResponsePolicy
 */
export interface QosPoliciesCreateResponsePolicy {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesCreateResponsePolicy
     */
    'description'?: any;
}
/**
 * Response of the qos/policies/policy_id/dscp_marking_rules/id:get operation
 * @export
 * @interface QosPoliciesDscpMarkingRuleShowResponse
 */
export interface QosPoliciesDscpMarkingRuleShowResponse {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule}
     * @memberof QosPoliciesDscpMarkingRuleShowResponse
     */
    'dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule;
}
/**
 * Request of the qos/policies/policy_id/dscp_marking_rules/id:put operation
 * @export
 * @interface QosPoliciesDscpMarkingRuleUpdateRequest
 */
export interface QosPoliciesDscpMarkingRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule}
     * @memberof QosPoliciesDscpMarkingRuleUpdateRequest
     */
    'dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule;
}
/**
 * Response of the qos/policies/policy_id/dscp_marking_rules/id:put operation
 * @export
 * @interface QosPoliciesDscpMarkingRuleUpdateResponse
 */
export interface QosPoliciesDscpMarkingRuleUpdateResponse {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule}
     * @memberof QosPoliciesDscpMarkingRuleUpdateResponse
     */
    'dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule;
}
/**
 * Request of the qos/policies/policy_id/dscp_marking_rules:post operation
 * @export
 * @interface QosPoliciesDscpMarkingRulesCreateRequest
 */
export interface QosPoliciesDscpMarkingRulesCreateRequest {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule}
     * @memberof QosPoliciesDscpMarkingRulesCreateRequest
     */
    'dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule
 */
export interface QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRule
     */
    'dscp_mark'?: QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRuleDscpMarkEnum;
}

export const QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRuleDscpMarkEnum = {
    _0: '0',
    _8: '8',
    _10: '10',
    _12: '12',
    _14: '14',
    _16: '16',
    _18: '18',
    _20: '20',
    _22: '22',
    _24: '24',
    _26: '26',
    _28: '28',
    _30: '30',
    _32: '32',
    _34: '34',
    _36: '36',
    _38: '38',
    _40: '40',
    _44: '44',
    _46: '46',
    _48: '48',
    _56: '56'
} as const;

export type QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRuleDscpMarkEnum = typeof QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRuleDscpMarkEnum[keyof typeof QosPoliciesDscpMarkingRulesCreateRequestDscpMarkingRuleDscpMarkEnum];

/**
 * Response of the qos/policies/policy_id/dscp_marking_rules:post operation
 * @export
 * @interface QosPoliciesDscpMarkingRulesCreateResponse
 */
export interface QosPoliciesDscpMarkingRulesCreateResponse {
    /**
     * 
     * @type {QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule}
     * @memberof QosPoliciesDscpMarkingRulesCreateResponse
     */
    'dscp_marking_rule'?: QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule
 */
export interface QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRule
     */
    'dscp_mark'?: QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRuleDscpMarkEnum;
}

export const QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRuleDscpMarkEnum = {
    _0: '0',
    _8: '8',
    _10: '10',
    _12: '12',
    _14: '14',
    _16: '16',
    _18: '18',
    _20: '20',
    _22: '22',
    _24: '24',
    _26: '26',
    _28: '28',
    _30: '30',
    _32: '32',
    _34: '34',
    _36: '36',
    _38: '38',
    _40: '40',
    _44: '44',
    _46: '46',
    _48: '48',
    _56: '56'
} as const;

export type QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRuleDscpMarkEnum = typeof QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRuleDscpMarkEnum[keyof typeof QosPoliciesDscpMarkingRulesCreateResponseDscpMarkingRuleDscpMarkEnum];

/**
 * Response of the qos/policies/policy_id/dscp_marking_rules:get operation
 * @export
 * @interface QosPoliciesDscpMarkingRulesIndexResponse
 */
export interface QosPoliciesDscpMarkingRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesDscpMarkingRulesIndexResponse
     */
    'dscp_marking_rules'?: any;
}
/**
 * Response of the qos/policies:get operation
 * @export
 * @interface QosPoliciesIndexResponse
 */
export interface QosPoliciesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesIndexResponse
     */
    'policies'?: any;
}
/**
 * Response of the qos/policies/policy_id/minimum_bandwidth_rules/id:get operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRuleShowResponse
 */
export interface QosPoliciesMinimumBandwidthRuleShowResponse {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule}
     * @memberof QosPoliciesMinimumBandwidthRuleShowResponse
     */
    'minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule;
}
/**
 * Request of the qos/policies/policy_id/minimum_bandwidth_rules/id:put operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRuleUpdateRequest
 */
export interface QosPoliciesMinimumBandwidthRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule}
     * @memberof QosPoliciesMinimumBandwidthRuleUpdateRequest
     */
    'minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule;
}
/**
 * Response of the qos/policies/policy_id/minimum_bandwidth_rules/id:put operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRuleUpdateResponse
 */
export interface QosPoliciesMinimumBandwidthRuleUpdateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule}
     * @memberof QosPoliciesMinimumBandwidthRuleUpdateResponse
     */
    'minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule;
}
/**
 * Request of the qos/policies/policy_id/minimum_bandwidth_rules:post operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRulesCreateRequest
 */
export interface QosPoliciesMinimumBandwidthRulesCreateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateRequest
     */
    'minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule
 */
export interface QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule
     */
    'min_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRule
     */
    'direction'?: QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRuleDirectionEnum;
}

export const QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRuleDirectionEnum = typeof QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRuleDirectionEnum[keyof typeof QosPoliciesMinimumBandwidthRulesCreateRequestMinimumBandwidthRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/minimum_bandwidth_rules:post operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRulesCreateResponse
 */
export interface QosPoliciesMinimumBandwidthRulesCreateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateResponse
     */
    'minimum_bandwidth_rule'?: QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule
 */
export interface QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule
     */
    'min_kbps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRule
     */
    'direction'?: QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRuleDirectionEnum;
}

export const QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRuleDirectionEnum = typeof QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRuleDirectionEnum[keyof typeof QosPoliciesMinimumBandwidthRulesCreateResponseMinimumBandwidthRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/minimum_bandwidth_rules:get operation
 * @export
 * @interface QosPoliciesMinimumBandwidthRulesIndexResponse
 */
export interface QosPoliciesMinimumBandwidthRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumBandwidthRulesIndexResponse
     */
    'minimum_bandwidth_rules'?: any;
}
/**
 * Response of the qos/policies/policy_id/minimum-packet-rate-rules/id:get operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRuleShowResponse
 */
export interface QosPoliciesMinimumPacketRateRuleShowResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosPoliciesMinimumPacketRateRuleShowResponse
     */
    'minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * Request of the qos/policies/policy_id/minimum-packet-rate-rules/id:put operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRuleUpdateRequest
 */
export interface QosPoliciesMinimumPacketRateRuleUpdateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule}
     * @memberof QosPoliciesMinimumPacketRateRuleUpdateRequest
     */
    'minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule;
}
/**
 * Response of the qos/policies/policy_id/minimum-packet-rate-rules/id:put operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRuleUpdateResponse
 */
export interface QosPoliciesMinimumPacketRateRuleUpdateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosPoliciesMinimumPacketRateRuleUpdateResponse
     */
    'minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * Request of the qos/policies/policy_id/minimum-packet-rate-rules:post operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRulesCreateRequest
 */
export interface QosPoliciesMinimumPacketRateRulesCreateRequest {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateRequest
     */
    'minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule
 */
export interface QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule
     */
    'min_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRule
     */
    'direction'?: QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRuleDirectionEnum;
}

export const QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRuleDirectionEnum = {
    Any: 'any',
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRuleDirectionEnum = typeof QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRuleDirectionEnum[keyof typeof QosPoliciesMinimumPacketRateRulesCreateRequestMinimumPacketRateRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/minimum-packet-rate-rules:post operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRulesCreateResponse
 */
export interface QosPoliciesMinimumPacketRateRulesCreateResponse {
    /**
     * 
     * @type {QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateResponse
     */
    'minimum_packet_rate_rule'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule;
}
/**
 * 
 * @export
 * @interface QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule
 */
export interface QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule
     */
    'min_kpps'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRule
     */
    'direction'?: QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRuleDirectionEnum;
}

export const QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRuleDirectionEnum = {
    Any: 'any',
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRuleDirectionEnum = typeof QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRuleDirectionEnum[keyof typeof QosPoliciesMinimumPacketRateRulesCreateResponseMinimumPacketRateRuleDirectionEnum];

/**
 * Response of the qos/policies/policy_id/minimum-packet-rate-rules:get operation
 * @export
 * @interface QosPoliciesMinimumPacketRateRulesIndexResponse
 */
export interface QosPoliciesMinimumPacketRateRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosPoliciesMinimumPacketRateRulesIndexResponse
     */
    'minimum_packet_rate_rules'?: any;
}
/**
 * Response of the qos/policies/id:get operation
 * @export
 * @interface QosPolicyShowResponse
 */
export interface QosPolicyShowResponse {
    /**
     * 
     * @type {QosPoliciesCreateResponsePolicy}
     * @memberof QosPolicyShowResponse
     */
    'policy'?: QosPoliciesCreateResponsePolicy;
}
/**
 * Request of the qos/policies/id:put operation
 * @export
 * @interface QosPolicyUpdateRequest
 */
export interface QosPolicyUpdateRequest {
    /**
     * 
     * @type {QosPolicyUpdateRequestPolicy}
     * @memberof QosPolicyUpdateRequest
     */
    'policy'?: QosPolicyUpdateRequestPolicy;
}
/**
 * 
 * @export
 * @interface QosPolicyUpdateRequestPolicy
 */
export interface QosPolicyUpdateRequestPolicy {
    /**
     * 
     * @type {any}
     * @memberof QosPolicyUpdateRequestPolicy
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPolicyUpdateRequestPolicy
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPolicyUpdateRequestPolicy
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosPolicyUpdateRequestPolicy
     */
    'description'?: any;
}
/**
 * Response of the qos/policies/id:put operation
 * @export
 * @interface QosPolicyUpdateResponse
 */
export interface QosPolicyUpdateResponse {
    /**
     * 
     * @type {QosPoliciesCreateResponsePolicy}
     * @memberof QosPolicyUpdateResponse
     */
    'policy'?: QosPoliciesCreateResponsePolicy;
}
/**
 * Response of the qos/rule-types/id:get operation
 * @export
 * @interface QosRuleTypeShowResponse
 */
export interface QosRuleTypeShowResponse {
    /**
     * 
     * @type {QosRuleTypesCreateResponseRuleType}
     * @memberof QosRuleTypeShowResponse
     */
    'rule_type'?: QosRuleTypesCreateResponseRuleType;
}
/**
 * Request of the qos/rule-types/id:put operation
 * @export
 * @interface QosRuleTypeUpdateRequest
 */
export interface QosRuleTypeUpdateRequest {
    /**
     * 
     * @type {QosRuleTypesCreateRequestRuleType}
     * @memberof QosRuleTypeUpdateRequest
     */
    'rule_type'?: QosRuleTypesCreateRequestRuleType;
}
/**
 * Response of the qos/rule-types/id:put operation
 * @export
 * @interface QosRuleTypeUpdateResponse
 */
export interface QosRuleTypeUpdateResponse {
    /**
     * 
     * @type {QosRuleTypesCreateResponseRuleType}
     * @memberof QosRuleTypeUpdateResponse
     */
    'rule_type'?: QosRuleTypesCreateResponseRuleType;
}
/**
 * Request of the qos/rule-types:post operation
 * @export
 * @interface QosRuleTypesCreateRequest
 */
export interface QosRuleTypesCreateRequest {
    /**
     * 
     * @type {QosRuleTypesCreateRequestRuleType}
     * @memberof QosRuleTypesCreateRequest
     */
    'rule_type'?: QosRuleTypesCreateRequestRuleType;
}
/**
 * 
 * @export
 * @interface QosRuleTypesCreateRequestRuleType
 */
export interface QosRuleTypesCreateRequestRuleType {
    /**
     * 
     * @type {any}
     * @memberof QosRuleTypesCreateRequestRuleType
     */
    'all_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosRuleTypesCreateRequestRuleType
     */
    'all_supported'?: any;
}
/**
 * Response of the qos/rule-types:post operation
 * @export
 * @interface QosRuleTypesCreateResponse
 */
export interface QosRuleTypesCreateResponse {
    /**
     * 
     * @type {QosRuleTypesCreateResponseRuleType}
     * @memberof QosRuleTypesCreateResponse
     */
    'rule_type'?: QosRuleTypesCreateResponseRuleType;
}
/**
 * 
 * @export
 * @interface QosRuleTypesCreateResponseRuleType
 */
export interface QosRuleTypesCreateResponseRuleType {
    /**
     * 
     * @type {any}
     * @memberof QosRuleTypesCreateResponseRuleType
     */
    'type'?: any;
    /**
     * 
     * @type {any}
     * @memberof QosRuleTypesCreateResponseRuleType
     */
    'drivers'?: any;
}
/**
 * Response of the qos/rule-types:get operation
 * @export
 * @interface QosRuleTypesIndexResponse
 */
export interface QosRuleTypesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QosRuleTypesIndexResponse
     */
    'rule_types'?: any;
}
/**
 * Response of the quotas/id:get operation
 * @export
 * @interface QuotaShowResponse
 */
export interface QuotaShowResponse {
    /**
     * 
     * @type {QuotasDefaultDefaultResponseQuota}
     * @memberof QuotaShowResponse
     */
    'quota'?: QuotasDefaultDefaultResponseQuota;
}
/**
 * Request of the quotas/id:put operation
 * @export
 * @interface QuotaUpdateRequest
 */
export interface QuotaUpdateRequest {
    /**
     * 
     * @type {QuotasDefaultDefaultResponseQuota}
     * @memberof QuotaUpdateRequest
     */
    'quota'?: QuotasDefaultDefaultResponseQuota;
}
/**
 * Response of the quotas/id:put operation
 * @export
 * @interface QuotaUpdateResponse
 */
export interface QuotaUpdateResponse {
    /**
     * 
     * @type {QuotasDefaultDefaultResponseQuota}
     * @memberof QuotaUpdateResponse
     */
    'quota'?: QuotasDefaultDefaultResponseQuota;
}
/**
 * Response of the quotas/id/default:get operation
 * @export
 * @interface QuotasDefaultDefaultResponse
 */
export interface QuotasDefaultDefaultResponse {
    /**
     * 
     * @type {QuotasDefaultDefaultResponseQuota}
     * @memberof QuotasDefaultDefaultResponse
     */
    'quota'?: QuotasDefaultDefaultResponseQuota;
}
/**
 * 
 * @export
 * @interface QuotasDefaultDefaultResponseQuota
 */
export interface QuotasDefaultDefaultResponseQuota {
    /**
     * The number of floating IP addresses allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'floatingip'?: any;
    /**
     * The number of networks allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'network'?: any;
    /**
     * The number of ports allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'port'?: any;
    /**
     * The number of role-based access control (RBAC) policies for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'rbac_policy'?: any;
    /**
     * The number of routers allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'router'?: any;
    /**
     * The number of security groups allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'security_group'?: any;
    /**
     * The number of security group rules allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'security_group_rule'?: any;
    /**
     * The number of subnets allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'subnet'?: any;
    /**
     * The number of subnet pools allowed for each project. A value of -1 means no limit.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'subnetpool'?: any;
    /**
     * The ID of the project.
     * @type {any}
     * @memberof QuotasDefaultDefaultResponseQuota
     */
    'project_id'?: any;
}
/**
 * Response of the quotas/id/details:get operation
 * @export
 * @interface QuotasDetailsDetailsResponse
 */
export interface QuotasDetailsDetailsResponse {
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuota}
     * @memberof QuotasDetailsDetailsResponse
     */
    'quota'?: QuotasDetailsDetailsResponseQuota;
}
/**
 * 
 * @export
 * @interface QuotasDetailsDetailsResponseQuota
 */
export interface QuotasDetailsDetailsResponseQuota {
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaFloatingip}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'floatingip'?: QuotasDetailsDetailsResponseQuotaFloatingip;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaNetwork}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'network'?: QuotasDetailsDetailsResponseQuotaNetwork;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaPort}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'port'?: QuotasDetailsDetailsResponseQuotaPort;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaRbacPolicy}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'rbac_policy'?: QuotasDetailsDetailsResponseQuotaRbacPolicy;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaRouter}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'router'?: QuotasDetailsDetailsResponseQuotaRouter;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaSecurityGroup}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'security_group'?: QuotasDetailsDetailsResponseQuotaSecurityGroup;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaSecurityGroupRule}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'security_group_rule'?: QuotasDetailsDetailsResponseQuotaSecurityGroupRule;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaSubnet}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'subnet'?: QuotasDetailsDetailsResponseQuotaSubnet;
    /**
     * 
     * @type {QuotasDetailsDetailsResponseQuotaSubnetpool}
     * @memberof QuotasDetailsDetailsResponseQuota
     */
    'subnetpool'?: QuotasDetailsDetailsResponseQuotaSubnetpool;
}
/**
 * The number of floating IP addresses allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaFloatingip
 */
export interface QuotasDetailsDetailsResponseQuotaFloatingip {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaFloatingip
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaFloatingip
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaFloatingip
     */
    'reserved'?: any;
}
/**
 * The number of networks allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaNetwork
 */
export interface QuotasDetailsDetailsResponseQuotaNetwork {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaNetwork
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaNetwork
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaNetwork
     */
    'reserved'?: any;
}
/**
 * The number of ports allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaPort
 */
export interface QuotasDetailsDetailsResponseQuotaPort {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaPort
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaPort
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaPort
     */
    'reserved'?: any;
}
/**
 * The number of role-based access control (RBAC) policies for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaRbacPolicy
 */
export interface QuotasDetailsDetailsResponseQuotaRbacPolicy {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRbacPolicy
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRbacPolicy
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRbacPolicy
     */
    'reserved'?: any;
}
/**
 * The number of routers allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaRouter
 */
export interface QuotasDetailsDetailsResponseQuotaRouter {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRouter
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRouter
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaRouter
     */
    'reserved'?: any;
}
/**
 * The number of security groups allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaSecurityGroup
 */
export interface QuotasDetailsDetailsResponseQuotaSecurityGroup {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroup
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroup
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroup
     */
    'reserved'?: any;
}
/**
 * The number of security group rules allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaSecurityGroupRule
 */
export interface QuotasDetailsDetailsResponseQuotaSecurityGroupRule {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroupRule
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroupRule
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSecurityGroupRule
     */
    'reserved'?: any;
}
/**
 * The number of subnets allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaSubnet
 */
export interface QuotasDetailsDetailsResponseQuotaSubnet {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnet
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnet
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnet
     */
    'reserved'?: any;
}
/**
 * The number of subnet pools allowed for each project.
 * @export
 * @interface QuotasDetailsDetailsResponseQuotaSubnetpool
 */
export interface QuotasDetailsDetailsResponseQuotaSubnetpool {
    /**
     * Used quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnetpool
     */
    'used'?: any;
    /**
     * Current quota limit
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnetpool
     */
    'limit'?: any;
    /**
     * Reserved quota
     * @type {any}
     * @memberof QuotasDetailsDetailsResponseQuotaSubnetpool
     */
    'reserved'?: any;
}
/**
 * Response of the quotas:get operation
 * @export
 * @interface QuotasIndexResponse
 */
export interface QuotasIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof QuotasIndexResponse
     */
    'quotas'?: any;
}
/**
 * Request of the rbac-policies:post operation
 * @export
 * @interface RbacPoliciesCreateRequest
 */
export interface RbacPoliciesCreateRequest {
    /**
     * 
     * @type {RbacPoliciesCreateRequestRbacPolicy}
     * @memberof RbacPoliciesCreateRequest
     */
    'rbac_policy'?: RbacPoliciesCreateRequestRbacPolicy;
}
/**
 * 
 * @export
 * @interface RbacPoliciesCreateRequestRbacPolicy
 */
export interface RbacPoliciesCreateRequestRbacPolicy {
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateRequestRbacPolicy
     */
    'object_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateRequestRbacPolicy
     */
    'object_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateRequestRbacPolicy
     */
    'target_tenant'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateRequestRbacPolicy
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateRequestRbacPolicy
     */
    'action'?: any;
}
/**
 * Response of the rbac-policies:post operation
 * @export
 * @interface RbacPoliciesCreateResponse
 */
export interface RbacPoliciesCreateResponse {
    /**
     * 
     * @type {RbacPoliciesCreateResponseRbacPolicy}
     * @memberof RbacPoliciesCreateResponse
     */
    'rbac_policy'?: RbacPoliciesCreateResponseRbacPolicy;
}
/**
 * 
 * @export
 * @interface RbacPoliciesCreateResponseRbacPolicy
 */
export interface RbacPoliciesCreateResponseRbacPolicy {
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'object_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'object_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'target_tenant'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesCreateResponseRbacPolicy
     */
    'action'?: any;
}
/**
 * Response of the rbac-policies:get operation
 * @export
 * @interface RbacPoliciesIndexResponse
 */
export interface RbacPoliciesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof RbacPoliciesIndexResponse
     */
    'rbac_policies'?: any;
}
/**
 * Response of the rbac-policies/id:get operation
 * @export
 * @interface RbacPolicyShowResponse
 */
export interface RbacPolicyShowResponse {
    /**
     * 
     * @type {RbacPoliciesCreateResponseRbacPolicy}
     * @memberof RbacPolicyShowResponse
     */
    'rbac_policy'?: RbacPoliciesCreateResponseRbacPolicy;
}
/**
 * Request of the rbac-policies/id:put operation
 * @export
 * @interface RbacPolicyUpdateRequest
 */
export interface RbacPolicyUpdateRequest {
    /**
     * 
     * @type {RbacPolicyUpdateRequestRbacPolicy}
     * @memberof RbacPolicyUpdateRequest
     */
    'rbac_policy'?: RbacPolicyUpdateRequestRbacPolicy;
}
/**
 * 
 * @export
 * @interface RbacPolicyUpdateRequestRbacPolicy
 */
export interface RbacPolicyUpdateRequestRbacPolicy {
    /**
     * 
     * @type {any}
     * @memberof RbacPolicyUpdateRequestRbacPolicy
     */
    'target_tenant'?: any;
}
/**
 * Response of the rbac-policies/id:put operation
 * @export
 * @interface RbacPolicyUpdateResponse
 */
export interface RbacPolicyUpdateResponse {
    /**
     * 
     * @type {RbacPoliciesCreateResponseRbacPolicy}
     * @memberof RbacPolicyUpdateResponse
     */
    'rbac_policy'?: RbacPoliciesCreateResponseRbacPolicy;
}
/**
 * Response of the routers/id:get operation
 * @export
 * @interface RouterShowResponse
 */
export interface RouterShowResponse {
    /**
     * 
     * @type {RouterUpdateResponseRouter}
     * @memberof RouterShowResponse
     */
    'router'?: RouterUpdateResponseRouter;
}
/**
 * Request of the routers/id:put operation
 * @export
 * @interface RouterUpdateRequest
 */
export interface RouterUpdateRequest {
    /**
     * 
     * @type {RouterUpdateRequestRouter}
     * @memberof RouterUpdateRequest
     */
    'router'?: RouterUpdateRequestRouter;
}
/**
 * 
 * @export
 * @interface RouterUpdateRequestRouter
 */
export interface RouterUpdateRequestRouter {
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {RouterUpdateRequestRouterExternalGatewayInfo}
     * @memberof RouterUpdateRequestRouter
     */
    'external_gateway_info'?: RouterUpdateRequestRouterExternalGatewayInfo;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'ha'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'enable_ndp_proxy'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'distributed'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'routes'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouter
     */
    'description'?: any;
}
/**
 * 
 * @export
 * @interface RouterUpdateRequestRouterExternalGatewayInfo
 */
export interface RouterUpdateRequestRouterExternalGatewayInfo {
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouterExternalGatewayInfo
     */
    'network_id': any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouterExternalGatewayInfo
     */
    'enable_snat'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateRequestRouterExternalGatewayInfo
     */
    'external_fixed_ips'?: any;
}
/**
 * Response of the routers/id:put operation
 * @export
 * @interface RouterUpdateResponse
 */
export interface RouterUpdateResponse {
    /**
     * 
     * @type {RouterUpdateResponseRouter}
     * @memberof RouterUpdateResponse
     */
    'router'?: RouterUpdateResponseRouter;
}
/**
 * 
 * @export
 * @interface RouterUpdateResponseRouter
 */
export interface RouterUpdateResponseRouter {
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'admin_state_up'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'status'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {RouterUpdateRequestRouterExternalGatewayInfo}
     * @memberof RouterUpdateResponseRouter
     */
    'external_gateway_info'?: RouterUpdateRequestRouterExternalGatewayInfo;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'ha'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'enable_ndp_proxy'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'flavor_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'availability_zones'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'availability_zone_hints'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'distributed'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'conntrack_helpers'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'routes'?: any;
    /**
     * 
     * @type {any}
     * @memberof RouterUpdateResponseRouter
     */
    'description'?: any;
}
/**
 * Request body
 * @export
 * @interface RoutersAddExternalGatewaysAddExternalGatewaysRequest
 */
export interface RoutersAddExternalGatewaysAddExternalGatewaysRequest {
    /**
     * 
     * @type {RoutersAddExternalGatewaysAddExternalGatewaysRequestRouter}
     * @memberof RoutersAddExternalGatewaysAddExternalGatewaysRequest
     */
    'router'?: RoutersAddExternalGatewaysAddExternalGatewaysRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersAddExternalGatewaysAddExternalGatewaysRequestRouter
 */
export interface RoutersAddExternalGatewaysAddExternalGatewaysRequestRouter {
    /**
     * The list of external gateways of the router.
     * @type {any}
     * @memberof RoutersAddExternalGatewaysAddExternalGatewaysRequestRouter
     */
    'external_gateways'?: any;
}
/**
 * Request body
 * @export
 * @interface RoutersAddExternalGatewaysAddExternalGatewaysResponse
 */
export interface RoutersAddExternalGatewaysAddExternalGatewaysResponse {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesRequestRouter}
     * @memberof RoutersAddExternalGatewaysAddExternalGatewaysResponse
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesRequestRouter;
}
/**
 * Request body
 * @export
 * @interface RoutersAddExtraroutesAddExtraroutesRequest
 */
export interface RoutersAddExtraroutesAddExtraroutesRequest {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesRequestRouter}
     * @memberof RoutersAddExtraroutesAddExtraroutesRequest
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersAddExtraroutesAddExtraroutesRequestRouter
 */
export interface RoutersAddExtraroutesAddExtraroutesRequestRouter {
    /**
     * The extra routes configuration for L3 router. A list of dictionaries with destination and nexthop parameters. It is available when extraroute extension is enabled.
     * @type {any}
     * @memberof RoutersAddExtraroutesAddExtraroutesRequestRouter
     */
    'routes'?: any;
}
/**
 * 
 * @export
 * @interface RoutersAddExtraroutesAddExtraroutesResponse
 */
export interface RoutersAddExtraroutesAddExtraroutesResponse {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesResponseRouter}
     * @memberof RoutersAddExtraroutesAddExtraroutesResponse
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesResponseRouter;
}
/**
 * 
 * @export
 * @interface RoutersAddExtraroutesAddExtraroutesResponseRouter
 */
export interface RoutersAddExtraroutesAddExtraroutesResponseRouter {
    /**
     * The ID of the router.
     * @type {any}
     * @memberof RoutersAddExtraroutesAddExtraroutesResponseRouter
     */
    'id'?: any;
    /**
     * The name of the router.
     * @type {any}
     * @memberof RoutersAddExtraroutesAddExtraroutesResponseRouter
     */
    'name'?: any;
    /**
     * The extra routes configuration for L3 router. A list of dictionaries with destination and nexthop parameters. It is available when extraroute extension is enabled.
     * @type {any}
     * @memberof RoutersAddExtraroutesAddExtraroutesResponseRouter
     */
    'routes'?: any;
}
/**
 * @type RoutersAddRouterInterfaceAddRouterInterfaceRequest
 * Request body
 * @export
 */
export type RoutersAddRouterInterfaceAddRouterInterfaceRequest = any;

/**
 * 
 * @export
 * @interface RoutersAddRouterInterfaceAddRouterInterfaceResponse
 */
export interface RoutersAddRouterInterfaceAddRouterInterfaceResponse {
    /**
     * The ID of the router.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'id'?: any;
    /**
     * The ID of the subnet which the router interface belongs to.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'subnet_id'?: any;
    /**
     * A list of the ID of the subnet which the router interface belongs to. The list contains only one member.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'subnet_ids'?: any;
    /**
     * The ID of the project who owns the router interface.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'tenant_id'?: any;
    /**
     * The ID of the project who owns the router interface.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'project_id'?: any;
    /**
     * The ID of the port which represents the router interface.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'port_id'?: any;
    /**
     * Network ID which the router interface is connected to.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'network_id'?: any;
    /**
     * The list of tags on the resource.
     * @type {any}
     * @memberof RoutersAddRouterInterfaceAddRouterInterfaceResponse
     */
    'tags'?: any;
}
/**
 * Response of the routers/router_id/conntrack_helpers/id:get operation
 * @export
 * @interface RoutersConntrackHelperShowResponse
 */
export interface RoutersConntrackHelperShowResponse {
    /**
     * 
     * @type {RoutersConntrackHelpersCreateResponseConntrackHelper}
     * @memberof RoutersConntrackHelperShowResponse
     */
    'conntrack_helper'?: RoutersConntrackHelpersCreateResponseConntrackHelper;
}
/**
 * Request of the routers/router_id/conntrack_helpers/id:put operation
 * @export
 * @interface RoutersConntrackHelperUpdateRequest
 */
export interface RoutersConntrackHelperUpdateRequest {
    /**
     * 
     * @type {RoutersConntrackHelperUpdateRequestConntrackHelper}
     * @memberof RoutersConntrackHelperUpdateRequest
     */
    'conntrack_helper'?: RoutersConntrackHelperUpdateRequestConntrackHelper;
}
/**
 * 
 * @export
 * @interface RoutersConntrackHelperUpdateRequestConntrackHelper
 */
export interface RoutersConntrackHelperUpdateRequestConntrackHelper {
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelperUpdateRequestConntrackHelper
     */
    'protocol'?: RoutersConntrackHelperUpdateRequestConntrackHelperProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelperUpdateRequestConntrackHelper
     */
    'port'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelperUpdateRequestConntrackHelper
     */
    'helper'?: any;
}

export const RoutersConntrackHelperUpdateRequestConntrackHelperProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type RoutersConntrackHelperUpdateRequestConntrackHelperProtocolEnum = typeof RoutersConntrackHelperUpdateRequestConntrackHelperProtocolEnum[keyof typeof RoutersConntrackHelperUpdateRequestConntrackHelperProtocolEnum];

/**
 * Response of the routers/router_id/conntrack_helpers/id:put operation
 * @export
 * @interface RoutersConntrackHelperUpdateResponse
 */
export interface RoutersConntrackHelperUpdateResponse {
    /**
     * 
     * @type {RoutersConntrackHelpersCreateResponseConntrackHelper}
     * @memberof RoutersConntrackHelperUpdateResponse
     */
    'conntrack_helper'?: RoutersConntrackHelpersCreateResponseConntrackHelper;
}
/**
 * Request of the routers/router_id/conntrack_helpers:post operation
 * @export
 * @interface RoutersConntrackHelpersCreateRequest
 */
export interface RoutersConntrackHelpersCreateRequest {
    /**
     * 
     * @type {RoutersConntrackHelpersCreateRequestConntrackHelper}
     * @memberof RoutersConntrackHelpersCreateRequest
     */
    'conntrack_helper'?: RoutersConntrackHelpersCreateRequestConntrackHelper;
}
/**
 * 
 * @export
 * @interface RoutersConntrackHelpersCreateRequestConntrackHelper
 */
export interface RoutersConntrackHelpersCreateRequestConntrackHelper {
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateRequestConntrackHelper
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateRequestConntrackHelper
     */
    'protocol'?: RoutersConntrackHelpersCreateRequestConntrackHelperProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateRequestConntrackHelper
     */
    'port'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateRequestConntrackHelper
     */
    'helper'?: any;
}

export const RoutersConntrackHelpersCreateRequestConntrackHelperProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type RoutersConntrackHelpersCreateRequestConntrackHelperProtocolEnum = typeof RoutersConntrackHelpersCreateRequestConntrackHelperProtocolEnum[keyof typeof RoutersConntrackHelpersCreateRequestConntrackHelperProtocolEnum];

/**
 * Response of the routers/router_id/conntrack_helpers:post operation
 * @export
 * @interface RoutersConntrackHelpersCreateResponse
 */
export interface RoutersConntrackHelpersCreateResponse {
    /**
     * 
     * @type {RoutersConntrackHelpersCreateResponseConntrackHelper}
     * @memberof RoutersConntrackHelpersCreateResponse
     */
    'conntrack_helper'?: RoutersConntrackHelpersCreateResponseConntrackHelper;
}
/**
 * 
 * @export
 * @interface RoutersConntrackHelpersCreateResponseConntrackHelper
 */
export interface RoutersConntrackHelpersCreateResponseConntrackHelper {
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateResponseConntrackHelper
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateResponseConntrackHelper
     */
    'protocol'?: RoutersConntrackHelpersCreateResponseConntrackHelperProtocolEnum;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateResponseConntrackHelper
     */
    'port'?: any;
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersCreateResponseConntrackHelper
     */
    'helper'?: any;
}

export const RoutersConntrackHelpersCreateResponseConntrackHelperProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;

export type RoutersConntrackHelpersCreateResponseConntrackHelperProtocolEnum = typeof RoutersConntrackHelpersCreateResponseConntrackHelperProtocolEnum[keyof typeof RoutersConntrackHelpersCreateResponseConntrackHelperProtocolEnum];

/**
 * Response of the routers/router_id/conntrack_helpers:get operation
 * @export
 * @interface RoutersConntrackHelpersIndexResponse
 */
export interface RoutersConntrackHelpersIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof RoutersConntrackHelpersIndexResponse
     */
    'conntrack_helpers'?: any;
}
/**
 * Request of the routers:post operation
 * @export
 * @interface RoutersCreateRequest
 */
export interface RoutersCreateRequest {
    /**
     * 
     * @type {RoutersCreateRequestRouter}
     * @memberof RoutersCreateRequest
     */
    'router'?: RoutersCreateRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersCreateRequestRouter
 */
export interface RoutersCreateRequestRouter {
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouter
     */
    'name'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof RoutersCreateRequestRouter
     */
    'admin_state_up'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouter
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {RoutersCreateRequestRouterExternalGatewayInfo}
     * @memberof RoutersCreateRequestRouter
     */
    'external_gateway_info'?: RoutersCreateRequestRouterExternalGatewayInfo;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateRequestRouter
     */
    'ha'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateRequestRouter
     */
    'enable_ndp_proxy'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouter
     */
    'flavor_id'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoutersCreateRequestRouter
     */
    'availability_zone_hints'?: Array<string>;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateRequestRouter
     */
    'distributed'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouter
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface RoutersCreateRequestRouterExternalGatewayInfo
 */
export interface RoutersCreateRequestRouterExternalGatewayInfo {
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouterExternalGatewayInfo
     */
    'network_id': string;
    /**
     * 
     * @type {boolean}
     * @memberof RoutersCreateRequestRouterExternalGatewayInfo
     */
    'enable_snat'?: boolean;
    /**
     * 
     * @type {Array<RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner>}
     * @memberof RoutersCreateRequestRouterExternalGatewayInfo
     */
    'external_fixed_ips'?: Array<RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner>;
}
/**
 * 
 * @export
 * @interface RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner
 */
export interface RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner {
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner
     */
    'ip_address'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateRequestRouterExternalGatewayInfoExternalFixedIpsInner
     */
    'subnet_id'?: string;
}
/**
 * 
 * @export
 * @interface RoutersCreateRequestRouterHa
 */
export interface RoutersCreateRequestRouterHa {
}
/**
 * Response of the routers:post operation
 * @export
 * @interface RoutersCreateResponse
 */
export interface RoutersCreateResponse {
    /**
     * 
     * @type {RoutersCreateResponseRouter}
     * @memberof RoutersCreateResponse
     */
    'router'?: RoutersCreateResponseRouter;
}
/**
 * 
 * @export
 * @interface RoutersCreateResponseRouter
 */
export interface RoutersCreateResponseRouter {
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'name'?: string;
    /**
     * 
     * @type {AddressScopesCreateRequestAddressScopeShared}
     * @memberof RoutersCreateResponseRouter
     */
    'admin_state_up'?: AddressScopesCreateRequestAddressScopeShared;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'status'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'tenant_id'?: string;
    /**
     * 
     * @type {RoutersCreateRequestRouterExternalGatewayInfo}
     * @memberof RoutersCreateResponseRouter
     */
    'external_gateway_info'?: RoutersCreateRequestRouterExternalGatewayInfo;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateResponseRouter
     */
    'ha'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateResponseRouter
     */
    'enable_ndp_proxy'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'flavor_id'?: string;
    /**
     * 
     * @type {number}
     * @memberof RoutersCreateResponseRouter
     */
    'revision_number'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoutersCreateResponseRouter
     */
    'availability_zones'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoutersCreateResponseRouter
     */
    'availability_zone_hints'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RoutersCreateResponseRouter
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'created_at'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'updated_at'?: string;
    /**
     * 
     * @type {RoutersCreateRequestRouterHa}
     * @memberof RoutersCreateResponseRouter
     */
    'distributed'?: RoutersCreateRequestRouterHa | null;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'conntrack_helpers'?: string;
    /**
     * 
     * @type {Array<RoutersCreateResponseRouterRoutesInner>}
     * @memberof RoutersCreateResponseRouter
     */
    'routes'?: Array<RoutersCreateResponseRouterRoutesInner>;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouter
     */
    'description'?: string;
}
/**
 * 
 * @export
 * @interface RoutersCreateResponseRouterRoutesInner
 */
export interface RoutersCreateResponseRouterRoutesInner {
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouterRoutesInner
     */
    'destination'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoutersCreateResponseRouterRoutesInner
     */
    'nexthop'?: string;
}
/**
 * Response of the routers:get operation
 * @export
 * @interface RoutersIndexResponse
 */
export interface RoutersIndexResponse {
    /**
     * 
     * @type {Array<RoutersCreateResponseRouter>}
     * @memberof RoutersIndexResponse
     */
    'routers'?: Array<RoutersCreateResponseRouter>;
}
/**
 * Request body
 * @export
 * @interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest
 */
export interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest {
    /**
     * 
     * @type {RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequestRouter}
     * @memberof RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest
     */
    'router'?: RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequestRouter
 */
export interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequestRouter {
    /**
     * The list of external gateways of the router.
     * @type {any}
     * @memberof RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequestRouter
     */
    'external_gateways'?: any;
}
/**
 * Request body
 * @export
 * @interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysResponse
 */
export interface RoutersRemoveExternalGatewaysRemoveExternalGatewaysResponse {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesRequestRouter}
     * @memberof RoutersRemoveExternalGatewaysRemoveExternalGatewaysResponse
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesRequestRouter;
}
/**
 * Request body
 * @export
 * @interface RoutersRemoveExtraroutesRemoveExtraroutesRequest
 */
export interface RoutersRemoveExtraroutesRemoveExtraroutesRequest {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesRequestRouter}
     * @memberof RoutersRemoveExtraroutesRemoveExtraroutesRequest
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersRemoveExtraroutesRemoveExtraroutesResponse
 */
export interface RoutersRemoveExtraroutesRemoveExtraroutesResponse {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesResponseRouter}
     * @memberof RoutersRemoveExtraroutesRemoveExtraroutesResponse
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesResponseRouter;
}
/**
 * @type RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest
 * Request body
 * @export
 */
export type RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest = any;

/**
 * 
 * @export
 * @interface RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
 */
export interface RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse {
    /**
     * The ID of the router.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'id'?: any;
    /**
     * The ID of the subnet which the router interface belongs to.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'subnet_id'?: any;
    /**
     * A list of the ID of the subnet which the router interface belongs to. The list contains only one member.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'subnet_ids'?: any;
    /**
     * The ID of the project who owns the router interface.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'tenant_id'?: any;
    /**
     * The ID of the project who owns the router interface.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'project_id'?: any;
    /**
     * The ID of the port which represents the router interface.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'port_id'?: any;
    /**
     * Network ID which the router interface is connected to.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'network_id'?: any;
    /**
     * The list of tags on the resource.
     * @type {any}
     * @memberof RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse
     */
    'tags'?: any;
}
/**
 * Response of the routers/router_id/tags:get operation
 * @export
 * @interface RoutersTagsIndexResponse
 */
export interface RoutersTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof RoutersTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the routers/router_id/tags:put operation
 * @export
 * @interface RoutersTagsUpdateAllRequest
 */
export interface RoutersTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof RoutersTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the routers/router_id/tags:put operation
 * @export
 * @interface RoutersTagsUpdateAllResponse
 */
export interface RoutersTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof RoutersTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Request body
 * @export
 * @interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest
 */
export interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest {
    /**
     * 
     * @type {RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequestRouter}
     * @memberof RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest
     */
    'router'?: RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequestRouter;
}
/**
 * 
 * @export
 * @interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequestRouter
 */
export interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequestRouter {
    /**
     * The list of external gateways of the router.
     * @type {any}
     * @memberof RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequestRouter
     */
    'external_gateways'?: any;
}
/**
 * Request body
 * @export
 * @interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysResponse
 */
export interface RoutersUpdateExternalGatewaysUpdateExternalGatewaysResponse {
    /**
     * 
     * @type {RoutersAddExtraroutesAddExtraroutesRequestRouter}
     * @memberof RoutersUpdateExternalGatewaysUpdateExternalGatewaysResponse
     */
    'router'?: RoutersAddExtraroutesAddExtraroutesRequestRouter;
}
/**
 * Response of the security-group-rules/id:get operation
 * @export
 * @interface SecurityGroupRuleShowResponse
 */
export interface SecurityGroupRuleShowResponse {
    /**
     * 
     * @type {SecurityGroupRulesCreateResponseSecurityGroupRule}
     * @memberof SecurityGroupRuleShowResponse
     */
    'security_group_rule'?: SecurityGroupRulesCreateResponseSecurityGroupRule;
}
/**
 * Request of the security-group-rules/id:put operation
 * @export
 * @interface SecurityGroupRuleUpdateRequest
 */
export interface SecurityGroupRuleUpdateRequest {
    /**
     * 
     * @type {SecurityGroupRuleUpdateRequestSecurityGroupRule}
     * @memberof SecurityGroupRuleUpdateRequest
     */
    'security_group_rule'?: SecurityGroupRuleUpdateRequestSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface SecurityGroupRuleUpdateRequestSecurityGroupRule
 */
export interface SecurityGroupRuleUpdateRequestSecurityGroupRule {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRuleUpdateRequestSecurityGroupRule
     */
    'description'?: any;
}
/**
 * Response of the security-group-rules/id:put operation
 * @export
 * @interface SecurityGroupRuleUpdateResponse
 */
export interface SecurityGroupRuleUpdateResponse {
    /**
     * 
     * @type {SecurityGroupRulesCreateResponseSecurityGroupRule}
     * @memberof SecurityGroupRuleUpdateResponse
     */
    'security_group_rule'?: SecurityGroupRulesCreateResponseSecurityGroupRule;
}
/**
 * Request of the security-group-rules:post operation
 * @export
 * @interface SecurityGroupRulesCreateRequest
 */
export interface SecurityGroupRulesCreateRequest {
    /**
     * 
     * @type {SecurityGroupRulesCreateRequestSecurityGroupRule}
     * @memberof SecurityGroupRulesCreateRequest
     */
    'security_group_rule'?: SecurityGroupRulesCreateRequestSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface SecurityGroupRulesCreateRequestSecurityGroupRule
 */
export interface SecurityGroupRulesCreateRequestSecurityGroupRule {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'security_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'remote_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'direction'?: SecurityGroupRulesCreateRequestSecurityGroupRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'protocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'port_range_min'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'port_range_max'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'ethertype'?: SecurityGroupRulesCreateRequestSecurityGroupRuleEthertypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateRequestSecurityGroupRule
     */
    'remote_address_group_id'?: any;
}

export const SecurityGroupRulesCreateRequestSecurityGroupRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type SecurityGroupRulesCreateRequestSecurityGroupRuleDirectionEnum = typeof SecurityGroupRulesCreateRequestSecurityGroupRuleDirectionEnum[keyof typeof SecurityGroupRulesCreateRequestSecurityGroupRuleDirectionEnum];
export const SecurityGroupRulesCreateRequestSecurityGroupRuleEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type SecurityGroupRulesCreateRequestSecurityGroupRuleEthertypeEnum = typeof SecurityGroupRulesCreateRequestSecurityGroupRuleEthertypeEnum[keyof typeof SecurityGroupRulesCreateRequestSecurityGroupRuleEthertypeEnum];

/**
 * Response of the security-group-rules:post operation
 * @export
 * @interface SecurityGroupRulesCreateResponse
 */
export interface SecurityGroupRulesCreateResponse {
    /**
     * 
     * @type {SecurityGroupRulesCreateResponseSecurityGroupRule}
     * @memberof SecurityGroupRulesCreateResponse
     */
    'security_group_rule'?: SecurityGroupRulesCreateResponseSecurityGroupRule;
}
/**
 * 
 * @export
 * @interface SecurityGroupRulesCreateResponseSecurityGroupRule
 */
export interface SecurityGroupRulesCreateResponseSecurityGroupRule {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'security_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'remote_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'direction'?: SecurityGroupRulesCreateResponseSecurityGroupRuleDirectionEnum;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'protocol'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'port_range_min'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'port_range_max'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'ethertype'?: SecurityGroupRulesCreateResponseSecurityGroupRuleEthertypeEnum;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'remote_ip_prefix'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'normalized_cidr'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'remote_address_group_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesCreateResponseSecurityGroupRule
     */
    'belongs_to_default_sg'?: any;
}

export const SecurityGroupRulesCreateResponseSecurityGroupRuleDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;

export type SecurityGroupRulesCreateResponseSecurityGroupRuleDirectionEnum = typeof SecurityGroupRulesCreateResponseSecurityGroupRuleDirectionEnum[keyof typeof SecurityGroupRulesCreateResponseSecurityGroupRuleDirectionEnum];
export const SecurityGroupRulesCreateResponseSecurityGroupRuleEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;

export type SecurityGroupRulesCreateResponseSecurityGroupRuleEthertypeEnum = typeof SecurityGroupRulesCreateResponseSecurityGroupRuleEthertypeEnum[keyof typeof SecurityGroupRulesCreateResponseSecurityGroupRuleEthertypeEnum];

/**
 * Response of the security-group-rules:get operation
 * @export
 * @interface SecurityGroupRulesIndexResponse
 */
export interface SecurityGroupRulesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupRulesIndexResponse
     */
    'security_group_rules'?: any;
}
/**
 * Response of the security-groups/id:get operation
 * @export
 * @interface SecurityGroupShowResponse
 */
export interface SecurityGroupShowResponse {
    /**
     * 
     * @type {SecurityGroupsCreateResponseSecurityGroup}
     * @memberof SecurityGroupShowResponse
     */
    'security_group'?: SecurityGroupsCreateResponseSecurityGroup;
}
/**
 * Request of the security-groups/id:put operation
 * @export
 * @interface SecurityGroupUpdateRequest
 */
export interface SecurityGroupUpdateRequest {
    /**
     * 
     * @type {SecurityGroupUpdateRequestSecurityGroup}
     * @memberof SecurityGroupUpdateRequest
     */
    'security_group'?: SecurityGroupUpdateRequestSecurityGroup;
}
/**
 * 
 * @export
 * @interface SecurityGroupUpdateRequestSecurityGroup
 */
export interface SecurityGroupUpdateRequestSecurityGroup {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupUpdateRequestSecurityGroup
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupUpdateRequestSecurityGroup
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupUpdateRequestSecurityGroup
     */
    'stateful'?: any;
}
/**
 * Response of the security-groups/id:put operation
 * @export
 * @interface SecurityGroupUpdateResponse
 */
export interface SecurityGroupUpdateResponse {
    /**
     * 
     * @type {SecurityGroupsCreateResponseSecurityGroup}
     * @memberof SecurityGroupUpdateResponse
     */
    'security_group'?: SecurityGroupsCreateResponseSecurityGroup;
}
/**
 * Request of the security-groups:post operation
 * @export
 * @interface SecurityGroupsCreateRequest
 */
export interface SecurityGroupsCreateRequest {
    /**
     * 
     * @type {SecurityGroupsCreateRequestSecurityGroup}
     * @memberof SecurityGroupsCreateRequest
     */
    'security_group'?: SecurityGroupsCreateRequestSecurityGroup;
}
/**
 * 
 * @export
 * @interface SecurityGroupsCreateRequestSecurityGroup
 */
export interface SecurityGroupsCreateRequestSecurityGroup {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateRequestSecurityGroup
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateRequestSecurityGroup
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateRequestSecurityGroup
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateRequestSecurityGroup
     */
    'stateful'?: any;
}
/**
 * Response of the security-groups:post operation
 * @export
 * @interface SecurityGroupsCreateResponse
 */
export interface SecurityGroupsCreateResponse {
    /**
     * 
     * @type {SecurityGroupsCreateResponseSecurityGroup}
     * @memberof SecurityGroupsCreateResponse
     */
    'security_group'?: SecurityGroupsCreateResponseSecurityGroup;
}
/**
 * 
 * @export
 * @interface SecurityGroupsCreateResponseSecurityGroup
 */
export interface SecurityGroupsCreateResponseSecurityGroup {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'tenant_id'?: any;
    /**
     * A list of security_group_rule objects.
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'security_group_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'stateful'?: any;
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsCreateResponseSecurityGroup
     */
    'shared'?: any;
}
/**
 * Response of the security-groups:get operation
 * @export
 * @interface SecurityGroupsIndexResponse
 */
export interface SecurityGroupsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsIndexResponse
     */
    'security_groups'?: any;
}
/**
 * Response of the security-groups/security_group_id/tags:get operation
 * @export
 * @interface SecurityGroupsTagsIndexResponse
 */
export interface SecurityGroupsTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the security-groups/security_group_id/tags:put operation
 * @export
 * @interface SecurityGroupsTagsUpdateAllRequest
 */
export interface SecurityGroupsTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the security-groups/security_group_id/tags:put operation
 * @export
 * @interface SecurityGroupsTagsUpdateAllResponse
 */
export interface SecurityGroupsTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof SecurityGroupsTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the segments/id:get operation
 * @export
 * @interface SegmentShowResponse
 */
export interface SegmentShowResponse {
    /**
     * 
     * @type {SegmentsCreateResponseSegment}
     * @memberof SegmentShowResponse
     */
    'segment'?: SegmentsCreateResponseSegment;
}
/**
 * Request of the segments/id:put operation
 * @export
 * @interface SegmentUpdateRequest
 */
export interface SegmentUpdateRequest {
    /**
     * 
     * @type {NdpProxyUpdateRequestNdpProxy}
     * @memberof SegmentUpdateRequest
     */
    'segment'?: NdpProxyUpdateRequestNdpProxy;
}
/**
 * Response of the segments/id:put operation
 * @export
 * @interface SegmentUpdateResponse
 */
export interface SegmentUpdateResponse {
    /**
     * 
     * @type {SegmentsCreateResponseSegment}
     * @memberof SegmentUpdateResponse
     */
    'segment'?: SegmentsCreateResponseSegment;
}
/**
 * Request of the segments:post operation
 * @export
 * @interface SegmentsCreateRequest
 */
export interface SegmentsCreateRequest {
    /**
     * 
     * @type {SegmentsCreateRequestSegment}
     * @memberof SegmentsCreateRequest
     */
    'segment'?: SegmentsCreateRequestSegment;
}
/**
 * 
 * @export
 * @interface SegmentsCreateRequestSegment
 */
export interface SegmentsCreateRequestSegment {
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'network_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'segmentation_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateRequestSegment
     */
    'description'?: any;
}
/**
 * Response of the segments:post operation
 * @export
 * @interface SegmentsCreateResponse
 */
export interface SegmentsCreateResponse {
    /**
     * 
     * @type {SegmentsCreateResponseSegment}
     * @memberof SegmentsCreateResponse
     */
    'segment'?: SegmentsCreateResponseSegment;
}
/**
 * 
 * @export
 * @interface SegmentsCreateResponseSegment
 */
export interface SegmentsCreateResponseSegment {
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'physical_network'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'network_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'segmentation_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SegmentsCreateResponseSegment
     */
    'description'?: any;
}
/**
 * Response of the segments:get operation
 * @export
 * @interface SegmentsIndexResponse
 */
export interface SegmentsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SegmentsIndexResponse
     */
    'segments'?: any;
}
/**
 * Response of the service_profiles/id:get operation
 * @export
 * @interface ServiceProfileShowResponse
 */
export interface ServiceProfileShowResponse {
    /**
     * 
     * @type {ServiceProfilesCreateResponseServiceProfile}
     * @memberof ServiceProfileShowResponse
     */
    'service_profile'?: ServiceProfilesCreateResponseServiceProfile;
}
/**
 * Request of the service_profiles/id:put operation
 * @export
 * @interface ServiceProfileUpdateRequest
 */
export interface ServiceProfileUpdateRequest {
    /**
     * 
     * @type {ServiceProfilesCreateRequestServiceProfile}
     * @memberof ServiceProfileUpdateRequest
     */
    'service_profile'?: ServiceProfilesCreateRequestServiceProfile;
}
/**
 * Response of the service_profiles/id:put operation
 * @export
 * @interface ServiceProfileUpdateResponse
 */
export interface ServiceProfileUpdateResponse {
    /**
     * 
     * @type {ServiceProfilesCreateResponseServiceProfile}
     * @memberof ServiceProfileUpdateResponse
     */
    'service_profile'?: ServiceProfilesCreateResponseServiceProfile;
}
/**
 * Request of the service_profiles:post operation
 * @export
 * @interface ServiceProfilesCreateRequest
 */
export interface ServiceProfilesCreateRequest {
    /**
     * 
     * @type {ServiceProfilesCreateRequestServiceProfile}
     * @memberof ServiceProfilesCreateRequest
     */
    'service_profile'?: ServiceProfilesCreateRequestServiceProfile;
}
/**
 * 
 * @export
 * @interface ServiceProfilesCreateRequestServiceProfile
 */
export interface ServiceProfilesCreateRequestServiceProfile {
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateRequestServiceProfile
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateRequestServiceProfile
     */
    'driver'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateRequestServiceProfile
     */
    'metainfo'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateRequestServiceProfile
     */
    'enabled'?: any;
}
/**
 * Response of the service_profiles:post operation
 * @export
 * @interface ServiceProfilesCreateResponse
 */
export interface ServiceProfilesCreateResponse {
    /**
     * 
     * @type {ServiceProfilesCreateResponseServiceProfile}
     * @memberof ServiceProfilesCreateResponse
     */
    'service_profile'?: ServiceProfilesCreateResponseServiceProfile;
}
/**
 * 
 * @export
 * @interface ServiceProfilesCreateResponseServiceProfile
 */
export interface ServiceProfilesCreateResponseServiceProfile {
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateResponseServiceProfile
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateResponseServiceProfile
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateResponseServiceProfile
     */
    'driver'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateResponseServiceProfile
     */
    'metainfo'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesCreateResponseServiceProfile
     */
    'enabled'?: any;
}
/**
 * Response of the service_profiles:get operation
 * @export
 * @interface ServiceProfilesIndexResponse
 */
export interface ServiceProfilesIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof ServiceProfilesIndexResponse
     */
    'service_profiles'?: any;
}
/**
 * Response of the service-providers/id:get operation
 * @export
 * @interface ServiceProviderShowResponse
 */
export interface ServiceProviderShowResponse {
    /**
     * 
     * @type {ServiceProvidersCreateResponseServiceProvider}
     * @memberof ServiceProviderShowResponse
     */
    'service_provider'?: ServiceProvidersCreateResponseServiceProvider;
}
/**
 * Request of the service-providers/id:put operation
 * @export
 * @interface ServiceProviderUpdateRequest
 */
export interface ServiceProviderUpdateRequest {
    /**
     * 
     * @type {any}
     * @memberof ServiceProviderUpdateRequest
     */
    'service_provider'?: any;
}
/**
 * Response of the service-providers/id:put operation
 * @export
 * @interface ServiceProviderUpdateResponse
 */
export interface ServiceProviderUpdateResponse {
    /**
     * 
     * @type {ServiceProvidersCreateResponseServiceProvider}
     * @memberof ServiceProviderUpdateResponse
     */
    'service_provider'?: ServiceProvidersCreateResponseServiceProvider;
}
/**
 * Request of the service-providers:post operation
 * @export
 * @interface ServiceProvidersCreateRequest
 */
export interface ServiceProvidersCreateRequest {
    /**
     * 
     * @type {any}
     * @memberof ServiceProvidersCreateRequest
     */
    'service_provider'?: any;
}
/**
 * Response of the service-providers:post operation
 * @export
 * @interface ServiceProvidersCreateResponse
 */
export interface ServiceProvidersCreateResponse {
    /**
     * 
     * @type {ServiceProvidersCreateResponseServiceProvider}
     * @memberof ServiceProvidersCreateResponse
     */
    'service_provider'?: ServiceProvidersCreateResponseServiceProvider;
}
/**
 * 
 * @export
 * @interface ServiceProvidersCreateResponseServiceProvider
 */
export interface ServiceProvidersCreateResponseServiceProvider {
    /**
     * 
     * @type {any}
     * @memberof ServiceProvidersCreateResponseServiceProvider
     */
    'service_type'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProvidersCreateResponseServiceProvider
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ServiceProvidersCreateResponseServiceProvider
     */
    'default'?: any;
}
/**
 * Response of the service-providers:get operation
 * @export
 * @interface ServiceProvidersIndexResponse
 */
export interface ServiceProvidersIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof ServiceProvidersIndexResponse
     */
    'service_providers'?: any;
}
/**
 * Response of the subnets/subnet_id:get operation
 * @export
 * @interface SubnetShowResponse
 */
export interface SubnetShowResponse {
    /**
     * 
     * @type {SubnetsCreateResponseSubnet}
     * @memberof SubnetShowResponse
     */
    'subnet'?: SubnetsCreateResponseSubnet;
}
/**
 * Request of the subnets/subnet_id:put operation
 * @export
 * @interface SubnetUpdateRequest
 */
export interface SubnetUpdateRequest {
    /**
     * 
     * @type {SubnetUpdateRequestSubnet}
     * @memberof SubnetUpdateRequest
     */
    'subnet'?: SubnetUpdateRequestSubnet;
}
/**
 * 
 * @export
 * @interface SubnetUpdateRequestSubnet
 */
export interface SubnetUpdateRequestSubnet {
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'gateway_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'allocation_pools'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'dns_nameservers'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'host_routes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'enable_dhcp'?: any;
    /**
     * The service types associated with the subnet
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'service_types'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'dns_publish_fixed_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetUpdateRequestSubnet
     */
    'segment_id'?: any;
}
/**
 * Response of the subnets/subnet_id:put operation
 * @export
 * @interface SubnetUpdateResponse
 */
export interface SubnetUpdateResponse {
    /**
     * 
     * @type {SubnetsCreateResponseSubnet}
     * @memberof SubnetUpdateResponse
     */
    'subnet'?: SubnetsCreateResponseSubnet;
}
/**
 * Response of the subnetpools/id:get operation
 * @export
 * @interface SubnetpoolShowResponse
 */
export interface SubnetpoolShowResponse {
    /**
     * 
     * @type {SubnetpoolsCreateResponseSubnetpool}
     * @memberof SubnetpoolShowResponse
     */
    'subnetpool'?: SubnetpoolsCreateResponseSubnetpool;
}
/**
 * Request of the subnetpools/id:put operation
 * @export
 * @interface SubnetpoolUpdateRequest
 */
export interface SubnetpoolUpdateRequest {
    /**
     * 
     * @type {SubnetpoolUpdateRequestSubnetpool}
     * @memberof SubnetpoolUpdateRequest
     */
    'subnetpool'?: SubnetpoolUpdateRequestSubnetpool;
}
/**
 * 
 * @export
 * @interface SubnetpoolUpdateRequestSubnetpool
 */
export interface SubnetpoolUpdateRequestSubnetpool {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'prefixes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'default_quota'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'default_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'min_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'max_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'address_scope_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolUpdateRequestSubnetpool
     */
    'description'?: any;
}
/**
 * Response of the subnetpools/id:put operation
 * @export
 * @interface SubnetpoolUpdateResponse
 */
export interface SubnetpoolUpdateResponse {
    /**
     * 
     * @type {SubnetpoolsCreateResponseSubnetpool}
     * @memberof SubnetpoolUpdateResponse
     */
    'subnetpool'?: SubnetpoolsCreateResponseSubnetpool;
}
/**
 * Request of the subnetpools:post operation
 * @export
 * @interface SubnetpoolsCreateRequest
 */
export interface SubnetpoolsCreateRequest {
    /**
     * 
     * @type {SubnetpoolsCreateRequestSubnetpool}
     * @memberof SubnetpoolsCreateRequest
     */
    'subnetpool'?: SubnetpoolsCreateRequestSubnetpool;
}
/**
 * 
 * @export
 * @interface SubnetpoolsCreateRequestSubnetpool
 */
export interface SubnetpoolsCreateRequestSubnetpool {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'prefixes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'default_quota'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'default_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'min_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'max_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'address_scope_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateRequestSubnetpool
     */
    'description'?: any;
}
/**
 * Response of the subnetpools:post operation
 * @export
 * @interface SubnetpoolsCreateResponse
 */
export interface SubnetpoolsCreateResponse {
    /**
     * 
     * @type {SubnetpoolsCreateResponseSubnetpool}
     * @memberof SubnetpoolsCreateResponse
     */
    'subnetpool'?: SubnetpoolsCreateResponseSubnetpool;
}
/**
 * 
 * @export
 * @interface SubnetpoolsCreateResponseSubnetpool
 */
export interface SubnetpoolsCreateResponseSubnetpool {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'prefixes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'default_quota'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'ip_version'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'default_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'min_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'max_prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'is_default'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'shared'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'address_scope_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsCreateResponseSubnetpool
     */
    'description'?: any;
}
/**
 * Response of the subnetpools:get operation
 * @export
 * @interface SubnetpoolsIndexResponse
 */
export interface SubnetpoolsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsIndexResponse
     */
    'subnetpools'?: any;
}
/**
 * Response of the subnetpools/subnetpool_id/tags:get operation
 * @export
 * @interface SubnetpoolsTagsIndexResponse
 */
export interface SubnetpoolsTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the subnetpools/subnetpool_id/tags:put operation
 * @export
 * @interface SubnetpoolsTagsUpdateAllRequest
 */
export interface SubnetpoolsTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the subnetpools/subnetpool_id/tags:put operation
 * @export
 * @interface SubnetpoolsTagsUpdateAllResponse
 */
export interface SubnetpoolsTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetpoolsTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Request of the subnets:post operation
 * @export
 * @interface SubnetsCreateRequest
 */
export interface SubnetsCreateRequest {
    /**
     * 
     * @type {SubnetsCreateRequestSubnet}
     * @memberof SubnetsCreateRequest
     */
    'subnet'?: SubnetsCreateRequestSubnet;
}
/**
 * 
 * @export
 * @interface SubnetsCreateRequestSubnet
 */
export interface SubnetsCreateRequestSubnet {
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'ip_version': SubnetsCreateRequestSubnetIpVersionEnum;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'network_id': any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'subnetpool_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'prefixlen'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'cidr'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'gateway_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'allocation_pools'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'dns_nameservers'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'host_routes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'enable_dhcp'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'ipv6_ra_mode'?: SubnetsCreateRequestSubnetIpv6RaModeEnum;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'ipv6_address_mode'?: SubnetsCreateRequestSubnetIpv6AddressModeEnum;
    /**
     * The service types associated with the subnet
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'service_types'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'use_default_subnetpool'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'dns_publish_fixed_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateRequestSubnet
     */
    'segment_id'?: any;
}

export const SubnetsCreateRequestSubnetIpVersionEnum = {
    _4: '4',
    _6: '6'
} as const;

export type SubnetsCreateRequestSubnetIpVersionEnum = typeof SubnetsCreateRequestSubnetIpVersionEnum[keyof typeof SubnetsCreateRequestSubnetIpVersionEnum];
export const SubnetsCreateRequestSubnetIpv6RaModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;

export type SubnetsCreateRequestSubnetIpv6RaModeEnum = typeof SubnetsCreateRequestSubnetIpv6RaModeEnum[keyof typeof SubnetsCreateRequestSubnetIpv6RaModeEnum];
export const SubnetsCreateRequestSubnetIpv6AddressModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;

export type SubnetsCreateRequestSubnetIpv6AddressModeEnum = typeof SubnetsCreateRequestSubnetIpv6AddressModeEnum[keyof typeof SubnetsCreateRequestSubnetIpv6AddressModeEnum];

/**
 * Response of the subnets:post operation
 * @export
 * @interface SubnetsCreateResponse
 */
export interface SubnetsCreateResponse {
    /**
     * 
     * @type {SubnetsCreateResponseSubnet}
     * @memberof SubnetsCreateResponse
     */
    'subnet'?: SubnetsCreateResponseSubnet;
}
/**
 * 
 * @export
 * @interface SubnetsCreateResponseSubnet
 */
export interface SubnetsCreateResponseSubnet {
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'ip_version'?: SubnetsCreateResponseSubnetIpVersionEnum;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'network_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'subnetpool_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'cidr'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'gateway_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'allocation_pools'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'dns_nameservers'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'host_routes'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'tenant_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'enable_dhcp'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'ipv6_ra_mode'?: SubnetsCreateResponseSubnetIpv6RaModeEnum;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'ipv6_address_mode'?: SubnetsCreateResponseSubnetIpv6AddressModeEnum;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'revision_number'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'router:external'?: any;
    /**
     * The service types associated with the subnet
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'service_types'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'tags'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'created_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'updated_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'dns_publish_fixed_ip'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof SubnetsCreateResponseSubnet
     */
    'segment_id'?: any;
}

export const SubnetsCreateResponseSubnetIpVersionEnum = {
    _4: '4',
    _6: '6'
} as const;

export type SubnetsCreateResponseSubnetIpVersionEnum = typeof SubnetsCreateResponseSubnetIpVersionEnum[keyof typeof SubnetsCreateResponseSubnetIpVersionEnum];
export const SubnetsCreateResponseSubnetIpv6RaModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;

export type SubnetsCreateResponseSubnetIpv6RaModeEnum = typeof SubnetsCreateResponseSubnetIpv6RaModeEnum[keyof typeof SubnetsCreateResponseSubnetIpv6RaModeEnum];
export const SubnetsCreateResponseSubnetIpv6AddressModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;

export type SubnetsCreateResponseSubnetIpv6AddressModeEnum = typeof SubnetsCreateResponseSubnetIpv6AddressModeEnum[keyof typeof SubnetsCreateResponseSubnetIpv6AddressModeEnum];

/**
 * Response of the subnets:get operation
 * @export
 * @interface SubnetsIndexResponse
 */
export interface SubnetsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetsIndexResponse
     */
    'subnets'?: any;
}
/**
 * Response of the subnets/subnet_id/tags:get operation
 * @export
 * @interface SubnetsTagsIndexResponse
 */
export interface SubnetsTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetsTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the subnets/subnet_id/tags:put operation
 * @export
 * @interface SubnetsTagsUpdateAllRequest
 */
export interface SubnetsTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof SubnetsTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the subnets/subnet_id/tags:put operation
 * @export
 * @interface SubnetsTagsUpdateAllResponse
 */
export interface SubnetsTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof SubnetsTagsUpdateAllResponse
     */
    'tags'?: any;
}
/**
 * Response of the trunks/trunk_id/tags:get operation
 * @export
 * @interface TrunksTagsIndexResponse
 */
export interface TrunksTagsIndexResponse {
    /**
     * 
     * @type {any}
     * @memberof TrunksTagsIndexResponse
     */
    'tags'?: any;
}
/**
 * Request of the trunks/trunk_id/tags:put operation
 * @export
 * @interface TrunksTagsUpdateAllRequest
 */
export interface TrunksTagsUpdateAllRequest {
    /**
     * 
     * @type {any}
     * @memberof TrunksTagsUpdateAllRequest
     */
    'tags'?: any;
}
/**
 * Response of the trunks/trunk_id/tags:put operation
 * @export
 * @interface TrunksTagsUpdateAllResponse
 */
export interface TrunksTagsUpdateAllResponse {
    /**
     * 
     * @type {any}
     * @memberof TrunksTagsUpdateAllResponse
     */
    'tags'?: any;
}

/**
 * AddressGroupsApi - axios parameter creator
 * @export
 */
export const AddressGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-groups API
         * @param {string} [name] name query parameter for /v2.0/address-groups API
         * @param {string} [description] description query parameter for /v2.0/address-groups API
         * @param {string} [projectId] project_id query parameter for /v2.0/address-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsGet: async (id?: string, name?: string, description?: string, projectId?: string, sortKey?: string, sortDir?: AddressGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/address-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsAddAddressesAddAddressesRequest} [addressGroupsAddAddressesAddAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdAddAddressesPut: async (id: string, addressGroupsAddAddressesAddAddressesRequest?: AddressGroupsAddAddressesAddAddressesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressGroupsIdAddAddressesPut', 'id', id)
            const localVarPath = `/v2.0/address-groups/{id}/add_addresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressGroupsAddAddressesAddAddressesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressGroupsIdDelete', 'id', id)
            const localVarPath = `/v2.0/address-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressGroupsIdGet', 'id', id)
            const localVarPath = `/v2.0/address-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupUpdateRequest} [addressGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdPut: async (id: string, addressGroupUpdateRequest?: AddressGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressGroupsIdPut', 'id', id)
            const localVarPath = `/v2.0/address-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsRemoveAddressesRemoveAddressesRequest} [addressGroupsRemoveAddressesRemoveAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdRemoveAddressesPut: async (id: string, addressGroupsRemoveAddressesRemoveAddressesRequest?: AddressGroupsRemoveAddressesRemoveAddressesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressGroupsIdRemoveAddressesPut', 'id', id)
            const localVarPath = `/v2.0/address-groups/{id}/remove_addresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressGroupsRemoveAddressesRemoveAddressesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddressGroupsCreateRequest} [addressGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsPost: async (addressGroupsCreateRequest?: AddressGroupsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/address-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressGroupsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressGroupsApi - functional programming interface
 * @export
 */
export const AddressGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-groups API
         * @param {string} [name] name query parameter for /v2.0/address-groups API
         * @param {string} [description] description query parameter for /v2.0/address-groups API
         * @param {string} [projectId] project_id query parameter for /v2.0/address-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsGet(id?: string, name?: string, description?: string, projectId?: string, sortKey?: string, sortDir?: AddressGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsGet(id, name, description, projectId, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsAddAddressesAddAddressesRequest} [addressGroupsAddAddressesAddAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsIdAddAddressesPut(id: string, addressGroupsAddAddressesAddAddressesRequest?: AddressGroupsAddAddressesAddAddressesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsIdAddAddressesPut(id, addressGroupsAddAddressesAddAddressesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsIdAddAddressesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupUpdateRequest} [addressGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsIdPut(id: string, addressGroupUpdateRequest?: AddressGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsIdPut(id, addressGroupUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsRemoveAddressesRemoveAddressesRequest} [addressGroupsRemoveAddressesRemoveAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsIdRemoveAddressesPut(id: string, addressGroupsRemoveAddressesRemoveAddressesRequest?: AddressGroupsRemoveAddressesRemoveAddressesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsIdRemoveAddressesPut(id, addressGroupsRemoveAddressesRemoveAddressesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsIdRemoveAddressesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AddressGroupsCreateRequest} [addressGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressGroupsPost(addressGroupsCreateRequest?: AddressGroupsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressGroupsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressGroupsPost(addressGroupsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressGroupsApi.addressGroupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AddressGroupsApi - factory interface
 * @export
 */
export const AddressGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressGroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-groups API
         * @param {string} [name] name query parameter for /v2.0/address-groups API
         * @param {string} [description] description query parameter for /v2.0/address-groups API
         * @param {string} [projectId] project_id query parameter for /v2.0/address-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsGet(id?: string, name?: string, description?: string, projectId?: string, sortKey?: string, sortDir?: AddressGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AddressGroupsIndexResponse> {
            return localVarFp.addressGroupsGet(id, name, description, projectId, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsAddAddressesAddAddressesRequest} [addressGroupsAddAddressesAddAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdAddAddressesPut(id: string, addressGroupsAddAddressesAddAddressesRequest?: AddressGroupsAddAddressesAddAddressesRequest, options?: any): AxiosPromise<AddressGroupShowResponse> {
            return localVarFp.addressGroupsIdAddAddressesPut(id, addressGroupsAddAddressesAddAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.addressGroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdGet(id: string, options?: any): AxiosPromise<AddressGroupShowResponse> {
            return localVarFp.addressGroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupUpdateRequest} [addressGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdPut(id: string, addressGroupUpdateRequest?: AddressGroupUpdateRequest, options?: any): AxiosPromise<AddressGroupUpdateResponse> {
            return localVarFp.addressGroupsIdPut(id, addressGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-groups/{id} API
         * @param {AddressGroupsRemoveAddressesRemoveAddressesRequest} [addressGroupsRemoveAddressesRemoveAddressesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsIdRemoveAddressesPut(id: string, addressGroupsRemoveAddressesRemoveAddressesRequest?: AddressGroupsRemoveAddressesRemoveAddressesRequest, options?: any): AxiosPromise<AddressGroupShowResponse> {
            return localVarFp.addressGroupsIdRemoveAddressesPut(id, addressGroupsRemoveAddressesRemoveAddressesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddressGroupsCreateRequest} [addressGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressGroupsPost(addressGroupsCreateRequest?: AddressGroupsCreateRequest, options?: any): AxiosPromise<AddressGroupsCreateResponse> {
            return localVarFp.addressGroupsPost(addressGroupsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressGroupsApi - object-oriented interface
 * @export
 * @class AddressGroupsApi
 * @extends {BaseAPI}
 */
export class AddressGroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/address-groups API
     * @param {string} [name] name query parameter for /v2.0/address-groups API
     * @param {string} [description] description query parameter for /v2.0/address-groups API
     * @param {string} [projectId] project_id query parameter for /v2.0/address-groups API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AddressGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsGet(id?: string, name?: string, description?: string, projectId?: string, sortKey?: string, sortDir?: AddressGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsGet(id, name, description, projectId, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-groups/{id} API
     * @param {AddressGroupsAddAddressesAddAddressesRequest} [addressGroupsAddAddressesAddAddressesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsIdAddAddressesPut(id: string, addressGroupsAddAddressesAddAddressesRequest?: AddressGroupsAddAddressesAddAddressesRequest, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsIdAddAddressesPut(id, addressGroupsAddAddressesAddAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-groups/{id} API
     * @param {AddressGroupUpdateRequest} [addressGroupUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsIdPut(id: string, addressGroupUpdateRequest?: AddressGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsIdPut(id, addressGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-groups/{id} API
     * @param {AddressGroupsRemoveAddressesRemoveAddressesRequest} [addressGroupsRemoveAddressesRemoveAddressesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsIdRemoveAddressesPut(id: string, addressGroupsRemoveAddressesRemoveAddressesRequest?: AddressGroupsRemoveAddressesRemoveAddressesRequest, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsIdRemoveAddressesPut(id, addressGroupsRemoveAddressesRemoveAddressesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddressGroupsCreateRequest} [addressGroupsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressGroupsApi
     */
    public addressGroupsPost(addressGroupsCreateRequest?: AddressGroupsCreateRequest, options?: RawAxiosRequestConfig) {
        return AddressGroupsApiFp(this.configuration).addressGroupsPost(addressGroupsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddressGroupsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AddressGroupsGetSortDirEnum = typeof AddressGroupsGetSortDirEnum[keyof typeof AddressGroupsGetSortDirEnum];


/**
 * AddressScopesApi - axios parameter creator
 * @export
 */
export const AddressScopesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-scopes API
         * @param {string} [name] name query parameter for /v2.0/address-scopes API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/address-scopes API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/address-scopes API
         * @param {AddressScopesGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/address-scopes API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressScopesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesGet: async (id?: string, name?: string, tenantId?: string, shared?: string | boolean, ipVersion?: AddressScopesGetIpVersionEnum, sortKey?: string, sortDir?: AddressScopesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/address-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (ipVersion !== undefined) {
                localVarQueryParameter['ip_version'] = ipVersion;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressScopesIdDelete', 'id', id)
            const localVarPath = `/v2.0/address-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressScopesIdGet', 'id', id)
            const localVarPath = `/v2.0/address-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {AddressScopeUpdateRequest} [addressScopeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdPut: async (id: string, addressScopeUpdateRequest?: AddressScopeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('addressScopesIdPut', 'id', id)
            const localVarPath = `/v2.0/address-scopes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressScopeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AddressScopesCreateRequest} [addressScopesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesPost: async (addressScopesCreateRequest?: AddressScopesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/address-scopes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressScopesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressScopesApi - functional programming interface
 * @export
 */
export const AddressScopesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressScopesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-scopes API
         * @param {string} [name] name query parameter for /v2.0/address-scopes API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/address-scopes API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/address-scopes API
         * @param {AddressScopesGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/address-scopes API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressScopesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressScopesGet(id?: string, name?: string, tenantId?: string, shared?: string | boolean, ipVersion?: AddressScopesGetIpVersionEnum, sortKey?: string, sortDir?: AddressScopesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressScopesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressScopesGet(id, name, tenantId, shared, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressScopesApi.addressScopesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressScopesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressScopesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressScopesApi.addressScopesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressScopesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressScopeShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressScopesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressScopesApi.addressScopesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {AddressScopeUpdateRequest} [addressScopeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressScopesIdPut(id: string, addressScopeUpdateRequest?: AddressScopeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressScopeUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressScopesIdPut(id, addressScopeUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressScopesApi.addressScopesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AddressScopesCreateRequest} [addressScopesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressScopesPost(addressScopesCreateRequest?: AddressScopesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AddressScopesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressScopesPost(addressScopesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AddressScopesApi.addressScopesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AddressScopesApi - factory interface
 * @export
 */
export const AddressScopesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressScopesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/address-scopes API
         * @param {string} [name] name query parameter for /v2.0/address-scopes API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/address-scopes API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/address-scopes API
         * @param {AddressScopesGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/address-scopes API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AddressScopesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesGet(id?: string, name?: string, tenantId?: string, shared?: string | boolean, ipVersion?: AddressScopesGetIpVersionEnum, sortKey?: string, sortDir?: AddressScopesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AddressScopesIndexResponse> {
            return localVarFp.addressScopesGet(id, name, tenantId, shared, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.addressScopesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdGet(id: string, options?: any): AxiosPromise<AddressScopeShowResponse> {
            return localVarFp.addressScopesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/address-scopes/{id} API
         * @param {AddressScopeUpdateRequest} [addressScopeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesIdPut(id: string, addressScopeUpdateRequest?: AddressScopeUpdateRequest, options?: any): AxiosPromise<AddressScopeUpdateResponse> {
            return localVarFp.addressScopesIdPut(id, addressScopeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AddressScopesCreateRequest} [addressScopesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressScopesPost(addressScopesCreateRequest?: AddressScopesCreateRequest, options?: any): AxiosPromise<AddressScopesCreateResponse> {
            return localVarFp.addressScopesPost(addressScopesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressScopesApi - object-oriented interface
 * @export
 * @class AddressScopesApi
 * @extends {BaseAPI}
 */
export class AddressScopesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/address-scopes API
     * @param {string} [name] name query parameter for /v2.0/address-scopes API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/address-scopes API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/address-scopes API
     * @param {AddressScopesGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/address-scopes API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AddressScopesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressScopesApi
     */
    public addressScopesGet(id?: string, name?: string, tenantId?: string, shared?: string | boolean, ipVersion?: AddressScopesGetIpVersionEnum, sortKey?: string, sortDir?: AddressScopesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return AddressScopesApiFp(this.configuration).addressScopesGet(id, name, tenantId, shared, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-scopes/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressScopesApi
     */
    public addressScopesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AddressScopesApiFp(this.configuration).addressScopesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-scopes/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressScopesApi
     */
    public addressScopesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AddressScopesApiFp(this.configuration).addressScopesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/address-scopes/{id} API
     * @param {AddressScopeUpdateRequest} [addressScopeUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressScopesApi
     */
    public addressScopesIdPut(id: string, addressScopeUpdateRequest?: AddressScopeUpdateRequest, options?: RawAxiosRequestConfig) {
        return AddressScopesApiFp(this.configuration).addressScopesIdPut(id, addressScopeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AddressScopesCreateRequest} [addressScopesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressScopesApi
     */
    public addressScopesPost(addressScopesCreateRequest?: AddressScopesCreateRequest, options?: RawAxiosRequestConfig) {
        return AddressScopesApiFp(this.configuration).addressScopesPost(addressScopesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AddressScopesGetIpVersionEnum = {
    _4: '4',
    _6: '6'
} as const;
export type AddressScopesGetIpVersionEnum = typeof AddressScopesGetIpVersionEnum[keyof typeof AddressScopesGetIpVersionEnum];
/**
 * @export
 */
export const AddressScopesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AddressScopesGetSortDirEnum = typeof AddressScopesGetSortDirEnum[keyof typeof AddressScopesGetSortDirEnum];


/**
 * AutoAllocatedTopologyApi - axios parameter creator
 * @export
 */
export const AutoAllocatedTopologyApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AutoAllocatedTopologyGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyGet: async (sortKey?: string, sortDir?: AutoAllocatedTopologyGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/auto-allocated-topology`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('autoAllocatedTopologyIdDelete', 'id', id)
            const localVarPath = `/v2.0/auto-allocated-topology/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('autoAllocatedTopologyIdGet', 'id', id)
            const localVarPath = `/v2.0/auto-allocated-topology/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {AutoAllocatedTopologyUpdateRequest} [autoAllocatedTopologyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdPut: async (id: string, autoAllocatedTopologyUpdateRequest?: AutoAllocatedTopologyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('autoAllocatedTopologyIdPut', 'id', id)
            const localVarPath = `/v2.0/auto-allocated-topology/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoAllocatedTopologyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AutoAllocatedTopologyCreateRequest} [autoAllocatedTopologyCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyPost: async (autoAllocatedTopologyCreateRequest?: AutoAllocatedTopologyCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/auto-allocated-topology`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(autoAllocatedTopologyCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AutoAllocatedTopologyApi - functional programming interface
 * @export
 */
export const AutoAllocatedTopologyApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AutoAllocatedTopologyApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AutoAllocatedTopologyGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoAllocatedTopologyGet(sortKey?: string, sortDir?: AutoAllocatedTopologyGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoAllocatedTopologyIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoAllocatedTopologyGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AutoAllocatedTopologyApi.autoAllocatedTopologyGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoAllocatedTopologyIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoAllocatedTopologyIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AutoAllocatedTopologyApi.autoAllocatedTopologyIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoAllocatedTopologyIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoAllocatedTopologyShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoAllocatedTopologyIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AutoAllocatedTopologyApi.autoAllocatedTopologyIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {AutoAllocatedTopologyUpdateRequest} [autoAllocatedTopologyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoAllocatedTopologyIdPut(id: string, autoAllocatedTopologyUpdateRequest?: AutoAllocatedTopologyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoAllocatedTopologyUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoAllocatedTopologyIdPut(id, autoAllocatedTopologyUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AutoAllocatedTopologyApi.autoAllocatedTopologyIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AutoAllocatedTopologyCreateRequest} [autoAllocatedTopologyCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest?: AutoAllocatedTopologyCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AutoAllocatedTopologyCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AutoAllocatedTopologyApi.autoAllocatedTopologyPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AutoAllocatedTopologyApi - factory interface
 * @export
 */
export const AutoAllocatedTopologyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AutoAllocatedTopologyApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AutoAllocatedTopologyGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyGet(sortKey?: string, sortDir?: AutoAllocatedTopologyGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AutoAllocatedTopologyIndexResponse> {
            return localVarFp.autoAllocatedTopologyGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.autoAllocatedTopologyIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdGet(id: string, options?: any): AxiosPromise<AutoAllocatedTopologyShowResponse> {
            return localVarFp.autoAllocatedTopologyIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
         * @param {AutoAllocatedTopologyUpdateRequest} [autoAllocatedTopologyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyIdPut(id: string, autoAllocatedTopologyUpdateRequest?: AutoAllocatedTopologyUpdateRequest, options?: any): AxiosPromise<AutoAllocatedTopologyUpdateResponse> {
            return localVarFp.autoAllocatedTopologyIdPut(id, autoAllocatedTopologyUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AutoAllocatedTopologyCreateRequest} [autoAllocatedTopologyCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest?: AutoAllocatedTopologyCreateRequest, options?: any): AxiosPromise<AutoAllocatedTopologyCreateResponse> {
            return localVarFp.autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutoAllocatedTopologyApi - object-oriented interface
 * @export
 * @class AutoAllocatedTopologyApi
 * @extends {BaseAPI}
 */
export class AutoAllocatedTopologyApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AutoAllocatedTopologyGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoAllocatedTopologyApi
     */
    public autoAllocatedTopologyGet(sortKey?: string, sortDir?: AutoAllocatedTopologyGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return AutoAllocatedTopologyApiFp(this.configuration).autoAllocatedTopologyGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoAllocatedTopologyApi
     */
    public autoAllocatedTopologyIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return AutoAllocatedTopologyApiFp(this.configuration).autoAllocatedTopologyIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoAllocatedTopologyApi
     */
    public autoAllocatedTopologyIdGet(id: string, options?: RawAxiosRequestConfig) {
        return AutoAllocatedTopologyApiFp(this.configuration).autoAllocatedTopologyIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/auto-allocated-topology/{id} API
     * @param {AutoAllocatedTopologyUpdateRequest} [autoAllocatedTopologyUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoAllocatedTopologyApi
     */
    public autoAllocatedTopologyIdPut(id: string, autoAllocatedTopologyUpdateRequest?: AutoAllocatedTopologyUpdateRequest, options?: RawAxiosRequestConfig) {
        return AutoAllocatedTopologyApiFp(this.configuration).autoAllocatedTopologyIdPut(id, autoAllocatedTopologyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AutoAllocatedTopologyCreateRequest} [autoAllocatedTopologyCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutoAllocatedTopologyApi
     */
    public autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest?: AutoAllocatedTopologyCreateRequest, options?: RawAxiosRequestConfig) {
        return AutoAllocatedTopologyApiFp(this.configuration).autoAllocatedTopologyPost(autoAllocatedTopologyCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AutoAllocatedTopologyGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AutoAllocatedTopologyGetSortDirEnum = typeof AutoAllocatedTopologyGetSortDirEnum[keyof typeof AutoAllocatedTopologyGetSortDirEnum];


/**
 * AvailabilityZonesApi - axios parameter creator
 * @export
 */
export const AvailabilityZonesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/availability_zones API
         * @param {string} [resource] resource query parameter for /v2.0/availability_zones API
         * @param {string} [state] state query parameter for /v2.0/availability_zones API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AvailabilityZonesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availabilityZonesGet: async (name?: string, resource?: string, state?: string, sortKey?: string, sortDir?: AvailabilityZonesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/availability_zones`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resource !== undefined) {
                localVarQueryParameter['resource'] = resource;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AvailabilityZonesApi - functional programming interface
 * @export
 */
export const AvailabilityZonesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AvailabilityZonesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/availability_zones API
         * @param {string} [resource] resource query parameter for /v2.0/availability_zones API
         * @param {string} [state] state query parameter for /v2.0/availability_zones API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AvailabilityZonesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async availabilityZonesGet(name?: string, resource?: string, state?: string, sortKey?: string, sortDir?: AvailabilityZonesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AvailabilityZonesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.availabilityZonesGet(name, resource, state, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AvailabilityZonesApi.availabilityZonesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AvailabilityZonesApi - factory interface
 * @export
 */
export const AvailabilityZonesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AvailabilityZonesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/availability_zones API
         * @param {string} [resource] resource query parameter for /v2.0/availability_zones API
         * @param {string} [state] state query parameter for /v2.0/availability_zones API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AvailabilityZonesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        availabilityZonesGet(name?: string, resource?: string, state?: string, sortKey?: string, sortDir?: AvailabilityZonesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AvailabilityZonesIndexResponse> {
            return localVarFp.availabilityZonesGet(name, resource, state, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AvailabilityZonesApi - object-oriented interface
 * @export
 * @class AvailabilityZonesApi
 * @extends {BaseAPI}
 */
export class AvailabilityZonesApi extends BaseAPI {
    /**
     * 
     * @param {string} [name] name query parameter for /v2.0/availability_zones API
     * @param {string} [resource] resource query parameter for /v2.0/availability_zones API
     * @param {string} [state] state query parameter for /v2.0/availability_zones API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AvailabilityZonesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AvailabilityZonesApi
     */
    public availabilityZonesGet(name?: string, resource?: string, state?: string, sortKey?: string, sortDir?: AvailabilityZonesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return AvailabilityZonesApiFp(this.configuration).availabilityZonesGet(name, resource, state, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AvailabilityZonesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AvailabilityZonesGetSortDirEnum = typeof AvailabilityZonesGetSortDirEnum[keyof typeof AvailabilityZonesGetSortDirEnum];


/**
 * DefaultSecurityGroupRulesApi - axios parameter creator
 * @export
 */
export const DefaultSecurityGroupRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/default-security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInDefaultSg] used_in_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInNonDefaultSg] used_in_non_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {DefaultSecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesGet: async (id?: string, description?: string, remoteGroupId?: string, remoteAddressGroupId?: string, direction?: DefaultSecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: DefaultSecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, usedInDefaultSg?: string | boolean, usedInNonDefaultSg?: string | boolean, sortKey?: string, sortDir?: DefaultSecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/default-security-group-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (remoteGroupId !== undefined) {
                localVarQueryParameter['remote_group_id'] = remoteGroupId;
            }

            if (remoteAddressGroupId !== undefined) {
                localVarQueryParameter['remote_address_group_id'] = remoteAddressGroupId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (portRangeMin !== undefined) {
                localVarQueryParameter['port_range_min'] = portRangeMin;
            }

            if (portRangeMax !== undefined) {
                localVarQueryParameter['port_range_max'] = portRangeMax;
            }

            if (ethertype !== undefined) {
                localVarQueryParameter['ethertype'] = ethertype;
            }

            if (remoteIpPrefix !== undefined) {
                localVarQueryParameter['remote_ip_prefix'] = remoteIpPrefix;
            }

            if (usedInDefaultSg !== undefined) {
                for (const [key, value] of Object.entries(usedInDefaultSg)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (usedInNonDefaultSg !== undefined) {
                for (const [key, value] of Object.entries(usedInNonDefaultSg)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('defaultSecurityGroupRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/default-security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('defaultSecurityGroupRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/default-security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {DefaultSecurityGroupRuleUpdateRequest} [defaultSecurityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdPut: async (id: string, defaultSecurityGroupRuleUpdateRequest?: DefaultSecurityGroupRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('defaultSecurityGroupRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/default-security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultSecurityGroupRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {DefaultSecurityGroupRulesCreateRequest} [defaultSecurityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesPost: async (defaultSecurityGroupRulesCreateRequest?: DefaultSecurityGroupRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/default-security-group-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(defaultSecurityGroupRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultSecurityGroupRulesApi - functional programming interface
 * @export
 */
export const DefaultSecurityGroupRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultSecurityGroupRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/default-security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInDefaultSg] used_in_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInNonDefaultSg] used_in_non_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {DefaultSecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultSecurityGroupRulesGet(id?: string, description?: string, remoteGroupId?: string, remoteAddressGroupId?: string, direction?: DefaultSecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: DefaultSecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, usedInDefaultSg?: string | boolean, usedInNonDefaultSg?: string | boolean, sortKey?: string, sortDir?: DefaultSecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSecurityGroupRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultSecurityGroupRulesGet(id, description, remoteGroupId, remoteAddressGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, usedInDefaultSg, usedInNonDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultSecurityGroupRulesApi.defaultSecurityGroupRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultSecurityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultSecurityGroupRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultSecurityGroupRulesApi.defaultSecurityGroupRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultSecurityGroupRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSecurityGroupRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultSecurityGroupRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultSecurityGroupRulesApi.defaultSecurityGroupRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {DefaultSecurityGroupRuleUpdateRequest} [defaultSecurityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultSecurityGroupRulesIdPut(id: string, defaultSecurityGroupRuleUpdateRequest?: DefaultSecurityGroupRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSecurityGroupRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultSecurityGroupRulesIdPut(id, defaultSecurityGroupRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultSecurityGroupRulesApi.defaultSecurityGroupRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {DefaultSecurityGroupRulesCreateRequest} [defaultSecurityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest?: DefaultSecurityGroupRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DefaultSecurityGroupRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DefaultSecurityGroupRulesApi.defaultSecurityGroupRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DefaultSecurityGroupRulesApi - factory interface
 * @export
 */
export const DefaultSecurityGroupRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultSecurityGroupRulesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/default-security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/default-security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/default-security-group-rules API
         * @param {DefaultSecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/default-security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInDefaultSg] used_in_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string | boolean} [usedInNonDefaultSg] used_in_non_default_sg query parameter for /v2.0/default-security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {DefaultSecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesGet(id?: string, description?: string, remoteGroupId?: string, remoteAddressGroupId?: string, direction?: DefaultSecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: DefaultSecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, usedInDefaultSg?: string | boolean, usedInNonDefaultSg?: string | boolean, sortKey?: string, sortDir?: DefaultSecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<DefaultSecurityGroupRulesIndexResponse> {
            return localVarFp.defaultSecurityGroupRulesGet(id, description, remoteGroupId, remoteAddressGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, usedInDefaultSg, usedInNonDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.defaultSecurityGroupRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdGet(id: string, options?: any): AxiosPromise<DefaultSecurityGroupRuleShowResponse> {
            return localVarFp.defaultSecurityGroupRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
         * @param {DefaultSecurityGroupRuleUpdateRequest} [defaultSecurityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesIdPut(id: string, defaultSecurityGroupRuleUpdateRequest?: DefaultSecurityGroupRuleUpdateRequest, options?: any): AxiosPromise<DefaultSecurityGroupRuleUpdateResponse> {
            return localVarFp.defaultSecurityGroupRulesIdPut(id, defaultSecurityGroupRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {DefaultSecurityGroupRulesCreateRequest} [defaultSecurityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest?: DefaultSecurityGroupRulesCreateRequest, options?: any): AxiosPromise<DefaultSecurityGroupRulesCreateResponse> {
            return localVarFp.defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultSecurityGroupRulesApi - object-oriented interface
 * @export
 * @class DefaultSecurityGroupRulesApi
 * @extends {BaseAPI}
 */
export class DefaultSecurityGroupRulesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/default-security-group-rules API
     * @param {string} [description] description query parameter for /v2.0/default-security-group-rules API
     * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/default-security-group-rules API
     * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/default-security-group-rules API
     * @param {DefaultSecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/default-security-group-rules API
     * @param {string} [protocol] protocol query parameter for /v2.0/default-security-group-rules API
     * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/default-security-group-rules API
     * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/default-security-group-rules API
     * @param {DefaultSecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/default-security-group-rules API
     * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/default-security-group-rules API
     * @param {string | boolean} [usedInDefaultSg] used_in_default_sg query parameter for /v2.0/default-security-group-rules API
     * @param {string | boolean} [usedInNonDefaultSg] used_in_non_default_sg query parameter for /v2.0/default-security-group-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {DefaultSecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultSecurityGroupRulesApi
     */
    public defaultSecurityGroupRulesGet(id?: string, description?: string, remoteGroupId?: string, remoteAddressGroupId?: string, direction?: DefaultSecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: DefaultSecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, usedInDefaultSg?: string | boolean, usedInNonDefaultSg?: string | boolean, sortKey?: string, sortDir?: DefaultSecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return DefaultSecurityGroupRulesApiFp(this.configuration).defaultSecurityGroupRulesGet(id, description, remoteGroupId, remoteAddressGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, usedInDefaultSg, usedInNonDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultSecurityGroupRulesApi
     */
    public defaultSecurityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return DefaultSecurityGroupRulesApiFp(this.configuration).defaultSecurityGroupRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultSecurityGroupRulesApi
     */
    public defaultSecurityGroupRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return DefaultSecurityGroupRulesApiFp(this.configuration).defaultSecurityGroupRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/default-security-group-rules/{id} API
     * @param {DefaultSecurityGroupRuleUpdateRequest} [defaultSecurityGroupRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultSecurityGroupRulesApi
     */
    public defaultSecurityGroupRulesIdPut(id: string, defaultSecurityGroupRuleUpdateRequest?: DefaultSecurityGroupRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return DefaultSecurityGroupRulesApiFp(this.configuration).defaultSecurityGroupRulesIdPut(id, defaultSecurityGroupRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {DefaultSecurityGroupRulesCreateRequest} [defaultSecurityGroupRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultSecurityGroupRulesApi
     */
    public defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest?: DefaultSecurityGroupRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return DefaultSecurityGroupRulesApiFp(this.configuration).defaultSecurityGroupRulesPost(defaultSecurityGroupRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const DefaultSecurityGroupRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type DefaultSecurityGroupRulesGetDirectionEnum = typeof DefaultSecurityGroupRulesGetDirectionEnum[keyof typeof DefaultSecurityGroupRulesGetDirectionEnum];
/**
 * @export
 */
export const DefaultSecurityGroupRulesGetEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;
export type DefaultSecurityGroupRulesGetEthertypeEnum = typeof DefaultSecurityGroupRulesGetEthertypeEnum[keyof typeof DefaultSecurityGroupRulesGetEthertypeEnum];
/**
 * @export
 */
export const DefaultSecurityGroupRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type DefaultSecurityGroupRulesGetSortDirEnum = typeof DefaultSecurityGroupRulesGetSortDirEnum[keyof typeof DefaultSecurityGroupRulesGetSortDirEnum];


/**
 * DhcpAgentSchedulerApi - axios parameter creator
 * @export
 */
export const DhcpAgentSchedulerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdDhcpNetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksGet: async (sortKey?: string, sortDir?: AgentsAgentIdDhcpNetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/agents/{agent_id}/dhcp-networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdDelete: async (agentId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdDelete', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdDelete', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/dhcp-networks/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdGet: async (agentId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdGet', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdGet', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/dhcp-networks/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdPut: async (agentId: string, id: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdPut', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksIdPut', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/dhcp-networks/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksPost: async (agentId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdDhcpNetworksPost', 'agentId', agentId)
            const localVarPath = `/v2.0/agents/{agent_id}/dhcp-networks`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DhcpAgentSchedulerApi - functional programming interface
 * @export
 */
export const DhcpAgentSchedulerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DhcpAgentSchedulerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdDhcpNetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdDhcpNetworksGet(sortKey?: string, sortDir?: AgentsAgentIdDhcpNetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdDhcpNetworksGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DhcpAgentSchedulerApi.agentsAgentIdDhcpNetworksGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdDhcpNetworksIdDelete(agentId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdDhcpNetworksIdDelete(agentId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DhcpAgentSchedulerApi.agentsAgentIdDhcpNetworksIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdDhcpNetworksIdGet(agentId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdDhcpNetworksIdGet(agentId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DhcpAgentSchedulerApi.agentsAgentIdDhcpNetworksIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdDhcpNetworksIdPut(agentId: string, id: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdDhcpNetworksIdPut(agentId, id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DhcpAgentSchedulerApi.agentsAgentIdDhcpNetworksIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdDhcpNetworksPost(agentId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdDhcpNetworksPost(agentId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DhcpAgentSchedulerApi.agentsAgentIdDhcpNetworksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DhcpAgentSchedulerApi - factory interface
 * @export
 */
export const DhcpAgentSchedulerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DhcpAgentSchedulerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdDhcpNetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksGet(sortKey?: string, sortDir?: AgentsAgentIdDhcpNetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.agentsAgentIdDhcpNetworksGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdDelete(agentId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.agentsAgentIdDhcpNetworksIdDelete(agentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdGet(agentId: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.agentsAgentIdDhcpNetworksIdGet(agentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksIdPut(agentId: string, id: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.agentsAgentIdDhcpNetworksIdPut(agentId, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdDhcpNetworksPost(agentId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.agentsAgentIdDhcpNetworksPost(agentId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DhcpAgentSchedulerApi - object-oriented interface
 * @export
 * @class DhcpAgentSchedulerApi
 * @extends {BaseAPI}
 */
export class DhcpAgentSchedulerApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AgentsAgentIdDhcpNetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpAgentSchedulerApi
     */
    public agentsAgentIdDhcpNetworksGet(sortKey?: string, sortDir?: AgentsAgentIdDhcpNetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return DhcpAgentSchedulerApiFp(this.configuration).agentsAgentIdDhcpNetworksGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpAgentSchedulerApi
     */
    public agentsAgentIdDhcpNetworksIdDelete(agentId: string, id: string, options?: RawAxiosRequestConfig) {
        return DhcpAgentSchedulerApiFp(this.configuration).agentsAgentIdDhcpNetworksIdDelete(agentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpAgentSchedulerApi
     */
    public agentsAgentIdDhcpNetworksIdGet(agentId: string, id: string, options?: RawAxiosRequestConfig) {
        return DhcpAgentSchedulerApiFp(this.configuration).agentsAgentIdDhcpNetworksIdGet(agentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpAgentSchedulerApi
     */
    public agentsAgentIdDhcpNetworksIdPut(agentId: string, id: string, body?: object, options?: RawAxiosRequestConfig) {
        return DhcpAgentSchedulerApiFp(this.configuration).agentsAgentIdDhcpNetworksIdPut(agentId, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/dhcp-networks/{id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DhcpAgentSchedulerApi
     */
    public agentsAgentIdDhcpNetworksPost(agentId: string, body?: object, options?: RawAxiosRequestConfig) {
        return DhcpAgentSchedulerApiFp(this.configuration).agentsAgentIdDhcpNetworksPost(agentId, body, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AgentsAgentIdDhcpNetworksGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AgentsAgentIdDhcpNetworksGetSortDirEnum = typeof AgentsAgentIdDhcpNetworksGetSortDirEnum[keyof typeof AgentsAgentIdDhcpNetworksGetSortDirEnum];


/**
 * ExtensionsApi - axios parameter creator
 * @export
 */
export const ExtensionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/extensions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('extensionsIdGet', 'id', id)
            const localVarPath = `/v2.0/extensions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExtensionsApi - functional programming interface
 * @export
 */
export const ExtensionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExtensionsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extensionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extensionsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.extensionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extensionsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtensionShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extensionsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ExtensionsApi.extensionsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ExtensionsApi - factory interface
 * @export
 */
export const ExtensionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExtensionsApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsGet(options?: any): AxiosPromise<ExtensionsIndexResponse> {
            return localVarFp.extensionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/extensions/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extensionsIdGet(id: string, options?: any): AxiosPromise<ExtensionShowResponse> {
            return localVarFp.extensionsIdGet(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExtensionsApi - object-oriented interface
 * @export
 * @class ExtensionsApi
 * @extends {BaseAPI}
 */
export class ExtensionsApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public extensionsGet(options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).extensionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/extensions/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExtensionsApi
     */
    public extensionsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ExtensionsApiFp(this.configuration).extensionsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FlavorsApi - axios parameter creator
 * @export
 */
export const FlavorsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdNextProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersGet: async (sortKey?: string, sortDir?: FlavorsFlavorIdNextProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/flavors/{flavor_id}/next_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdDelete: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdDelete', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdDelete', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/next_providers/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdGet: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdGet', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdGet', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/next_providers/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProviderUpdateRequest} [flavorsNextProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdPut: async (flavorId: string, id: string, flavorsNextProviderUpdateRequest?: FlavorsNextProviderUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdPut', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersIdPut', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/next_providers/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsNextProviderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProvidersCreateRequest} [flavorsNextProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersPost: async (flavorId: string, flavorsNextProvidersCreateRequest?: FlavorsNextProvidersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdNextProvidersPost', 'flavorId', flavorId)
            const localVarPath = `/v2.0/flavors/{flavor_id}/next_providers`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsNextProvidersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesGet: async (sortKey?: string, sortDir?: FlavorsFlavorIdServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/flavors/{flavor_id}/service_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdDelete: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdDelete', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdDelete', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/service_profiles/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdGet: async (flavorId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdGet', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdGet', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/service_profiles/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfileUpdateRequest} [flavorsServiceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdPut: async (flavorId: string, id: string, flavorsServiceProfileUpdateRequest?: FlavorsServiceProfileUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdPut', 'flavorId', flavorId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesIdPut', 'id', id)
            const localVarPath = `/v2.0/flavors/{flavor_id}/service_profiles/{id}`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsServiceProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfilesCreateRequest} [flavorsServiceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesPost: async (flavorId: string, flavorsServiceProfilesCreateRequest?: FlavorsServiceProfilesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'flavorId' is not null or undefined
            assertParamExists('flavorsFlavorIdServiceProfilesPost', 'flavorId', flavorId)
            const localVarPath = `/v2.0/flavors/{flavor_id}/service_profiles`
                .replace(`{${"flavor_id"}}`, encodeURIComponent(String(flavorId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsServiceProfilesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/flavors API
         * @param {string} [name] name query parameter for /v2.0/flavors API
         * @param {string | null} [description] description query parameter for /v2.0/flavors API
         * @param {string} [serviceType] service_type query parameter for /v2.0/flavors API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/flavors API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsGet: async (id?: string, name?: string, description?: string | null, serviceType?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: FlavorsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (serviceType !== undefined) {
                localVarQueryParameter['service_type'] = serviceType;
            }

            if (enabled !== undefined) {
                for (const [key, value] of Object.entries(enabled)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdDelete', 'id', id)
            const localVarPath = `/v2.0/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdGet', 'id', id)
            const localVarPath = `/v2.0/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {FlavorUpdateRequest} [flavorUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdPut: async (id: string, flavorUpdateRequest?: FlavorUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('flavorsIdPut', 'id', id)
            const localVarPath = `/v2.0/flavors/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsPost: async (flavorsCreateRequest?: FlavorsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/flavors`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(flavorsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FlavorsApi - functional programming interface
 * @export
 */
export const FlavorsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FlavorsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdNextProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdNextProvidersGet(sortKey?: string, sortDir?: FlavorsFlavorIdNextProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsNextProvidersIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdNextProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdNextProvidersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdNextProvidersIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdNextProvidersIdDelete(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdNextProvidersIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdNextProvidersIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsNextProviderShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdNextProvidersIdGet(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdNextProvidersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProviderUpdateRequest} [flavorsNextProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdNextProvidersIdPut(flavorId: string, id: string, flavorsNextProviderUpdateRequest?: FlavorsNextProviderUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsNextProviderUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdNextProvidersIdPut(flavorId, id, flavorsNextProviderUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdNextProvidersIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProvidersCreateRequest} [flavorsNextProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdNextProvidersPost(flavorId: string, flavorsNextProvidersCreateRequest?: FlavorsNextProvidersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsNextProvidersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdNextProvidersPost(flavorId, flavorsNextProvidersCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdNextProvidersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdServiceProfilesGet(sortKey?: string, sortDir?: FlavorsFlavorIdServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsServiceProfilesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdServiceProfilesGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdServiceProfilesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdServiceProfilesIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdServiceProfilesIdDelete(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdServiceProfilesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdServiceProfilesIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsServiceProfileShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdServiceProfilesIdGet(flavorId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdServiceProfilesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfileUpdateRequest} [flavorsServiceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdServiceProfilesIdPut(flavorId: string, id: string, flavorsServiceProfileUpdateRequest?: FlavorsServiceProfileUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsServiceProfileUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdServiceProfilesIdPut(flavorId, id, flavorsServiceProfileUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdServiceProfilesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfilesCreateRequest} [flavorsServiceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsFlavorIdServiceProfilesPost(flavorId: string, flavorsServiceProfilesCreateRequest?: FlavorsServiceProfilesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsServiceProfilesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsFlavorIdServiceProfilesPost(flavorId, flavorsServiceProfilesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsFlavorIdServiceProfilesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/flavors API
         * @param {string} [name] name query parameter for /v2.0/flavors API
         * @param {string | null} [description] description query parameter for /v2.0/flavors API
         * @param {string} [serviceType] service_type query parameter for /v2.0/flavors API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/flavors API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsGet(id?: string, name?: string, description?: string | null, serviceType?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: FlavorsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsGet(id, name, description, serviceType, enabled, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {FlavorUpdateRequest} [flavorUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsIdPut(id: string, flavorUpdateRequest?: FlavorUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsIdPut(id, flavorUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FlavorsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.flavorsPost(flavorsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FlavorsApi.flavorsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FlavorsApi - factory interface
 * @export
 */
export const FlavorsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FlavorsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdNextProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersGet(sortKey?: string, sortDir?: FlavorsFlavorIdNextProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FlavorsNextProvidersIndexResponse> {
            return localVarFp.flavorsFlavorIdNextProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdDelete(flavorId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.flavorsFlavorIdNextProvidersIdDelete(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdGet(flavorId: string, id: string, options?: any): AxiosPromise<FlavorsNextProviderShowResponse> {
            return localVarFp.flavorsFlavorIdNextProvidersIdGet(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProviderUpdateRequest} [flavorsNextProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersIdPut(flavorId: string, id: string, flavorsNextProviderUpdateRequest?: FlavorsNextProviderUpdateRequest, options?: any): AxiosPromise<FlavorsNextProviderUpdateResponse> {
            return localVarFp.flavorsFlavorIdNextProvidersIdPut(flavorId, id, flavorsNextProviderUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
         * @param {FlavorsNextProvidersCreateRequest} [flavorsNextProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdNextProvidersPost(flavorId: string, flavorsNextProvidersCreateRequest?: FlavorsNextProvidersCreateRequest, options?: any): AxiosPromise<FlavorsNextProvidersCreateResponse> {
            return localVarFp.flavorsFlavorIdNextProvidersPost(flavorId, flavorsNextProvidersCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsFlavorIdServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesGet(sortKey?: string, sortDir?: FlavorsFlavorIdServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FlavorsServiceProfilesIndexResponse> {
            return localVarFp.flavorsFlavorIdServiceProfilesGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdDelete(flavorId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.flavorsFlavorIdServiceProfilesIdDelete(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdGet(flavorId: string, id: string, options?: any): AxiosPromise<FlavorsServiceProfileShowResponse> {
            return localVarFp.flavorsFlavorIdServiceProfilesIdGet(flavorId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfileUpdateRequest} [flavorsServiceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesIdPut(flavorId: string, id: string, flavorsServiceProfileUpdateRequest?: FlavorsServiceProfileUpdateRequest, options?: any): AxiosPromise<FlavorsServiceProfileUpdateResponse> {
            return localVarFp.flavorsFlavorIdServiceProfilesIdPut(flavorId, id, flavorsServiceProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {FlavorsServiceProfilesCreateRequest} [flavorsServiceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsFlavorIdServiceProfilesPost(flavorId: string, flavorsServiceProfilesCreateRequest?: FlavorsServiceProfilesCreateRequest, options?: any): AxiosPromise<FlavorsServiceProfilesCreateResponse> {
            return localVarFp.flavorsFlavorIdServiceProfilesPost(flavorId, flavorsServiceProfilesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/flavors API
         * @param {string} [name] name query parameter for /v2.0/flavors API
         * @param {string | null} [description] description query parameter for /v2.0/flavors API
         * @param {string} [serviceType] service_type query parameter for /v2.0/flavors API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/flavors API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FlavorsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsGet(id?: string, name?: string, description?: string | null, serviceType?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: FlavorsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FlavorsIndexResponse> {
            return localVarFp.flavorsGet(id, name, description, serviceType, enabled, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.flavorsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdGet(id: string, options?: any): AxiosPromise<FlavorShowResponse> {
            return localVarFp.flavorsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{id} API
         * @param {FlavorUpdateRequest} [flavorUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsIdPut(id: string, flavorUpdateRequest?: FlavorUpdateRequest, options?: any): AxiosPromise<FlavorUpdateResponse> {
            return localVarFp.flavorsIdPut(id, flavorUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: any): AxiosPromise<FlavorsCreateResponse> {
            return localVarFp.flavorsPost(flavorsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FlavorsApi - object-oriented interface
 * @export
 * @class FlavorsApi
 * @extends {BaseAPI}
 */
export class FlavorsApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FlavorsFlavorIdNextProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdNextProvidersGet(sortKey?: string, sortDir?: FlavorsFlavorIdNextProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdNextProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdNextProvidersIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdNextProvidersIdDelete(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdNextProvidersIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdNextProvidersIdGet(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {FlavorsNextProviderUpdateRequest} [flavorsNextProviderUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdNextProvidersIdPut(flavorId: string, id: string, flavorsNextProviderUpdateRequest?: FlavorsNextProviderUpdateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdNextProvidersIdPut(flavorId, id, flavorsNextProviderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/next_providers/{id} API
     * @param {FlavorsNextProvidersCreateRequest} [flavorsNextProvidersCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdNextProvidersPost(flavorId: string, flavorsNextProvidersCreateRequest?: FlavorsNextProvidersCreateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdNextProvidersPost(flavorId, flavorsNextProvidersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FlavorsFlavorIdServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdServiceProfilesGet(sortKey?: string, sortDir?: FlavorsFlavorIdServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdServiceProfilesGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdServiceProfilesIdDelete(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdServiceProfilesIdDelete(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdServiceProfilesIdGet(flavorId: string, id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdServiceProfilesIdGet(flavorId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {FlavorsServiceProfileUpdateRequest} [flavorsServiceProfileUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdServiceProfilesIdPut(flavorId: string, id: string, flavorsServiceProfileUpdateRequest?: FlavorsServiceProfileUpdateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdServiceProfilesIdPut(flavorId, id, flavorsServiceProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} flavorId flavor_id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {FlavorsServiceProfilesCreateRequest} [flavorsServiceProfilesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsFlavorIdServiceProfilesPost(flavorId: string, flavorsServiceProfilesCreateRequest?: FlavorsServiceProfilesCreateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsFlavorIdServiceProfilesPost(flavorId, flavorsServiceProfilesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/flavors API
     * @param {string} [name] name query parameter for /v2.0/flavors API
     * @param {string | null} [description] description query parameter for /v2.0/flavors API
     * @param {string} [serviceType] service_type query parameter for /v2.0/flavors API
     * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/flavors API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FlavorsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsGet(id?: string, name?: string, description?: string | null, serviceType?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: FlavorsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsGet(id, name, description, serviceType, enabled, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{id} API
     * @param {FlavorUpdateRequest} [flavorUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsIdPut(id: string, flavorUpdateRequest?: FlavorUpdateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsIdPut(id, flavorUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FlavorsCreateRequest} [flavorsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FlavorsApi
     */
    public flavorsPost(flavorsCreateRequest?: FlavorsCreateRequest, options?: RawAxiosRequestConfig) {
        return FlavorsApiFp(this.configuration).flavorsPost(flavorsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FlavorsFlavorIdNextProvidersGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FlavorsFlavorIdNextProvidersGetSortDirEnum = typeof FlavorsFlavorIdNextProvidersGetSortDirEnum[keyof typeof FlavorsFlavorIdNextProvidersGetSortDirEnum];
/**
 * @export
 */
export const FlavorsFlavorIdServiceProfilesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FlavorsFlavorIdServiceProfilesGetSortDirEnum = typeof FlavorsFlavorIdServiceProfilesGetSortDirEnum[keyof typeof FlavorsFlavorIdServiceProfilesGetSortDirEnum];
/**
 * @export
 */
export const FlavorsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FlavorsGetSortDirEnum = typeof FlavorsGetSortDirEnum[keyof typeof FlavorsGetSortDirEnum];


/**
 * FloatingipPoolsApi - axios parameter creator
 * @export
 */
export const FloatingipPoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipPoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsGet: async (sortKey?: string, sortDir?: FloatingipPoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingip-pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipPoolsIdDelete', 'id', id)
            const localVarPath = `/v2.0/floatingip-pools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipPoolsIdGet', 'id', id)
            const localVarPath = `/v2.0/floatingip-pools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {FloatingipPoolUpdateRequest} [floatingipPoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdPut: async (id: string, floatingipPoolUpdateRequest?: FloatingipPoolUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipPoolsIdPut', 'id', id)
            const localVarPath = `/v2.0/floatingip-pools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipPoolUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FloatingipPoolsCreateRequest} [floatingipPoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsPost: async (floatingipPoolsCreateRequest?: FloatingipPoolsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingip-pools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipPoolsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FloatingipPoolsApi - functional programming interface
 * @export
 */
export const FloatingipPoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FloatingipPoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipPoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipPoolsGet(sortKey?: string, sortDir?: FloatingipPoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipPoolsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipPoolsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipPoolsApi.floatingipPoolsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipPoolsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipPoolsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipPoolsApi.floatingipPoolsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipPoolsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipPoolShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipPoolsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipPoolsApi.floatingipPoolsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {FloatingipPoolUpdateRequest} [floatingipPoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipPoolsIdPut(id: string, floatingipPoolUpdateRequest?: FloatingipPoolUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipPoolUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipPoolsIdPut(id, floatingipPoolUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipPoolsApi.floatingipPoolsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {FloatingipPoolsCreateRequest} [floatingipPoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipPoolsPost(floatingipPoolsCreateRequest?: FloatingipPoolsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipPoolsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipPoolsPost(floatingipPoolsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipPoolsApi.floatingipPoolsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FloatingipPoolsApi - factory interface
 * @export
 */
export const FloatingipPoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FloatingipPoolsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipPoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsGet(sortKey?: string, sortDir?: FloatingipPoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FloatingipPoolsIndexResponse> {
            return localVarFp.floatingipPoolsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipPoolsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdGet(id: string, options?: any): AxiosPromise<FloatingipPoolShowResponse> {
            return localVarFp.floatingipPoolsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
         * @param {FloatingipPoolUpdateRequest} [floatingipPoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsIdPut(id: string, floatingipPoolUpdateRequest?: FloatingipPoolUpdateRequest, options?: any): AxiosPromise<FloatingipPoolUpdateResponse> {
            return localVarFp.floatingipPoolsIdPut(id, floatingipPoolUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FloatingipPoolsCreateRequest} [floatingipPoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipPoolsPost(floatingipPoolsCreateRequest?: FloatingipPoolsCreateRequest, options?: any): AxiosPromise<FloatingipPoolsCreateResponse> {
            return localVarFp.floatingipPoolsPost(floatingipPoolsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FloatingipPoolsApi - object-oriented interface
 * @export
 * @class FloatingipPoolsApi
 * @extends {BaseAPI}
 */
export class FloatingipPoolsApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FloatingipPoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipPoolsApi
     */
    public floatingipPoolsGet(sortKey?: string, sortDir?: FloatingipPoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FloatingipPoolsApiFp(this.configuration).floatingipPoolsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipPoolsApi
     */
    public floatingipPoolsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return FloatingipPoolsApiFp(this.configuration).floatingipPoolsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipPoolsApi
     */
    public floatingipPoolsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return FloatingipPoolsApiFp(this.configuration).floatingipPoolsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingip-pools/{id} API
     * @param {FloatingipPoolUpdateRequest} [floatingipPoolUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipPoolsApi
     */
    public floatingipPoolsIdPut(id: string, floatingipPoolUpdateRequest?: FloatingipPoolUpdateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipPoolsApiFp(this.configuration).floatingipPoolsIdPut(id, floatingipPoolUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FloatingipPoolsCreateRequest} [floatingipPoolsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipPoolsApi
     */
    public floatingipPoolsPost(floatingipPoolsCreateRequest?: FloatingipPoolsCreateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipPoolsApiFp(this.configuration).floatingipPoolsPost(floatingipPoolsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FloatingipPoolsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FloatingipPoolsGetSortDirEnum = typeof FloatingipPoolsGetSortDirEnum[keyof typeof FloatingipPoolsGetSortDirEnum];


/**
 * FloatingipsApi - axios parameter creator
 * @export
 */
export const FloatingipsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number | null} [externalPort] external_port query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {FloatingipsFloatingipIdPortForwardingsGetProtocolEnum} [protocol] protocol query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [internalPortId] internal_port_id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [description] description query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number} [externalPortRange] external_port_range query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdPortForwardingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsGet: async (id?: string, externalPort?: number | null, protocol?: FloatingipsFloatingipIdPortForwardingsGetProtocolEnum, internalPortId?: string, description?: string, externalPortRange?: number, sortKey?: string, sortDir?: FloatingipsFloatingipIdPortForwardingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/port_forwardings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (externalPort !== undefined) {
                localVarQueryParameter['external_port'] = externalPort;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (internalPortId !== undefined) {
                localVarQueryParameter['internal_port_id'] = internalPortId;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (externalPortRange !== undefined) {
                localVarQueryParameter['external_port_range'] = externalPortRange;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingsCreateRequest} [floatingipsPortForwardingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsPost: async (floatingipId: string, floatingipsPortForwardingsCreateRequest?: FloatingipsPortForwardingsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsPost', 'floatingipId', floatingipId)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/port_forwardings`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipsPortForwardingsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsDelete: async (floatingipId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsDelete', 'floatingipId', floatingipId)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsGet: async (sortKey?: string, sortDir?: FloatingipsFloatingipIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdDelete: async (floatingipId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdDelete', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdGet: async (floatingipId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdGet', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdPut: async (floatingipId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdPut', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {FloatingipsTagsUpdateAllRequest} [floatingipsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsPut: async (floatingipId: string, floatingipsTagsUpdateAllRequest?: FloatingipsTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdTagsPut', 'floatingipId', floatingipId)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/tags`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipsTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips API
         * @param {string} [floatingIpAddress] floating_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [floatingNetworkId] floating_network_id query parameter for /v2.0/floatingips API
         * @param {string | null} [routerId] router_id query parameter for /v2.0/floatingips API
         * @param {string | null} [portId] port_id query parameter for /v2.0/floatingips API
         * @param {string} [fixedIpAddress] fixed_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/floatingips API
         * @param {string} [status] status query parameter for /v2.0/floatingips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/floatingips API
         * @param {string} [description] description query parameter for /v2.0/floatingips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsGet: async (id?: string, floatingIpAddress?: string, floatingNetworkId?: string, routerId?: string | null, portId?: string | null, fixedIpAddress?: string, tenantId?: string, status?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: FloatingipsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (floatingIpAddress !== undefined) {
                localVarQueryParameter['floating_ip_address'] = floatingIpAddress;
            }

            if (floatingNetworkId !== undefined) {
                localVarQueryParameter['floating_network_id'] = floatingNetworkId;
            }

            if (routerId !== undefined) {
                localVarQueryParameter['router_id'] = routerId;
            }

            if (portId !== undefined) {
                localVarQueryParameter['port_id'] = portId;
            }

            if (fixedIpAddress !== undefined) {
                localVarQueryParameter['fixed_ip_address'] = fixedIpAddress;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsIdDelete', 'id', id)
            const localVarPath = `/v2.0/floatingips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsIdGet', 'id', id)
            const localVarPath = `/v2.0/floatingips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {FloatingipUpdateRequest} [floatingipUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdPut: async (id: string, floatingipUpdateRequest?: FloatingipUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsIdPut', 'id', id)
            const localVarPath = `/v2.0/floatingips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {FloatingipsCreateRequest} [floatingipsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsPost: async (floatingipsCreateRequest?: FloatingipsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/floatingips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FloatingipsApi - functional programming interface
 * @export
 */
export const FloatingipsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FloatingipsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number | null} [externalPort] external_port query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {FloatingipsFloatingipIdPortForwardingsGetProtocolEnum} [protocol] protocol query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [internalPortId] internal_port_id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [description] description query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number} [externalPortRange] external_port_range query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdPortForwardingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdPortForwardingsGet(id?: string, externalPort?: number | null, protocol?: FloatingipsFloatingipIdPortForwardingsGetProtocolEnum, internalPortId?: string, description?: string, externalPortRange?: number, sortKey?: string, sortDir?: FloatingipsFloatingipIdPortForwardingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsPortForwardingsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdPortForwardingsGet(id, externalPort, protocol, internalPortId, description, externalPortRange, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdPortForwardingsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingsCreateRequest} [floatingipsPortForwardingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdPortForwardingsPost(floatingipId: string, floatingipsPortForwardingsCreateRequest?: FloatingipsPortForwardingsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsPortForwardingsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdPortForwardingsPost(floatingipId, floatingipsPortForwardingsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdPortForwardingsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsDelete(floatingipId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsDelete(floatingipId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsGet(sortKey?: string, sortDir?: FloatingipsFloatingipIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsIdDelete(floatingipId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsIdDelete(floatingipId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsIdGet(floatingipId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsIdGet(floatingipId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsIdPut(floatingipId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsIdPut(floatingipId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {FloatingipsTagsUpdateAllRequest} [floatingipsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdTagsPut(floatingipId: string, floatingipsTagsUpdateAllRequest?: FloatingipsTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdTagsPut(floatingipId, floatingipsTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsFloatingipIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips API
         * @param {string} [floatingIpAddress] floating_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [floatingNetworkId] floating_network_id query parameter for /v2.0/floatingips API
         * @param {string | null} [routerId] router_id query parameter for /v2.0/floatingips API
         * @param {string | null} [portId] port_id query parameter for /v2.0/floatingips API
         * @param {string} [fixedIpAddress] fixed_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/floatingips API
         * @param {string} [status] status query parameter for /v2.0/floatingips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/floatingips API
         * @param {string} [description] description query parameter for /v2.0/floatingips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsGet(id?: string, floatingIpAddress?: string, floatingNetworkId?: string, routerId?: string | null, portId?: string | null, fixedIpAddress?: string, tenantId?: string, status?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: FloatingipsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsGet(id, floatingIpAddress, floatingNetworkId, routerId, portId, fixedIpAddress, tenantId, status, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {FloatingipUpdateRequest} [floatingipUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsIdPut(id: string, floatingipUpdateRequest?: FloatingipUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsIdPut(id, floatingipUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {FloatingipsCreateRequest} [floatingipsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsPost(floatingipsCreateRequest?: FloatingipsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsPost(floatingipsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsApi.floatingipsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FloatingipsApi - factory interface
 * @export
 */
export const FloatingipsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FloatingipsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number | null} [externalPort] external_port query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {FloatingipsFloatingipIdPortForwardingsGetProtocolEnum} [protocol] protocol query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [internalPortId] internal_port_id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [description] description query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {number} [externalPortRange] external_port_range query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdPortForwardingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsGet(id?: string, externalPort?: number | null, protocol?: FloatingipsFloatingipIdPortForwardingsGetProtocolEnum, internalPortId?: string, description?: string, externalPortRange?: number, sortKey?: string, sortDir?: FloatingipsFloatingipIdPortForwardingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FloatingipsPortForwardingsIndexResponse> {
            return localVarFp.floatingipsFloatingipIdPortForwardingsGet(id, externalPort, protocol, internalPortId, description, externalPortRange, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingsCreateRequest} [floatingipsPortForwardingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsPost(floatingipId: string, floatingipsPortForwardingsCreateRequest?: FloatingipsPortForwardingsCreateRequest, options?: any): AxiosPromise<FloatingipsPortForwardingsCreateResponse> {
            return localVarFp.floatingipsFloatingipIdPortForwardingsPost(floatingipId, floatingipsPortForwardingsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsDelete(floatingipId: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsFloatingipIdTagsDelete(floatingipId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsFloatingipIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsGet(sortKey?: string, sortDir?: FloatingipsFloatingipIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FloatingipsTagsIndexResponse> {
            return localVarFp.floatingipsFloatingipIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdDelete(floatingipId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsFloatingipIdTagsIdDelete(floatingipId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdGet(floatingipId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsFloatingipIdTagsIdGet(floatingipId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsIdPut(floatingipId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsFloatingipIdTagsIdPut(floatingipId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
         * @param {FloatingipsTagsUpdateAllRequest} [floatingipsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdTagsPut(floatingipId: string, floatingipsTagsUpdateAllRequest?: FloatingipsTagsUpdateAllRequest, options?: any): AxiosPromise<FloatingipsTagsUpdateAllResponse> {
            return localVarFp.floatingipsFloatingipIdTagsPut(floatingipId, floatingipsTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/floatingips API
         * @param {string} [floatingIpAddress] floating_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [floatingNetworkId] floating_network_id query parameter for /v2.0/floatingips API
         * @param {string | null} [routerId] router_id query parameter for /v2.0/floatingips API
         * @param {string | null} [portId] port_id query parameter for /v2.0/floatingips API
         * @param {string} [fixedIpAddress] fixed_ip_address query parameter for /v2.0/floatingips API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/floatingips API
         * @param {string} [status] status query parameter for /v2.0/floatingips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/floatingips API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/floatingips API
         * @param {string} [description] description query parameter for /v2.0/floatingips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {FloatingipsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsGet(id?: string, floatingIpAddress?: string, floatingNetworkId?: string, routerId?: string | null, portId?: string | null, fixedIpAddress?: string, tenantId?: string, status?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: FloatingipsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<FloatingipsIndexResponse> {
            return localVarFp.floatingipsGet(id, floatingIpAddress, floatingNetworkId, routerId, portId, fixedIpAddress, tenantId, status, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdGet(id: string, options?: any): AxiosPromise<FloatingipShowResponse> {
            return localVarFp.floatingipsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/floatingips/{id} API
         * @param {FloatingipUpdateRequest} [floatingipUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsIdPut(id: string, floatingipUpdateRequest?: FloatingipUpdateRequest, options?: any): AxiosPromise<FloatingipUpdateResponse> {
            return localVarFp.floatingipsIdPut(id, floatingipUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {FloatingipsCreateRequest} [floatingipsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsPost(floatingipsCreateRequest?: FloatingipsCreateRequest, options?: any): AxiosPromise<FloatingipsCreateResponse> {
            return localVarFp.floatingipsPost(floatingipsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FloatingipsApi - object-oriented interface
 * @export
 * @class FloatingipsApi
 * @extends {BaseAPI}
 */
export class FloatingipsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {number | null} [externalPort] external_port query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {FloatingipsFloatingipIdPortForwardingsGetProtocolEnum} [protocol] protocol query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {string} [internalPortId] internal_port_id query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {string} [description] description query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {number} [externalPortRange] external_port_range query parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FloatingipsFloatingipIdPortForwardingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdPortForwardingsGet(id?: string, externalPort?: number | null, protocol?: FloatingipsFloatingipIdPortForwardingsGetProtocolEnum, internalPortId?: string, description?: string, externalPortRange?: number, sortKey?: string, sortDir?: FloatingipsFloatingipIdPortForwardingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdPortForwardingsGet(id, externalPort, protocol, internalPortId, description, externalPortRange, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {FloatingipsPortForwardingsCreateRequest} [floatingipsPortForwardingsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdPortForwardingsPost(floatingipId: string, floatingipsPortForwardingsCreateRequest?: FloatingipsPortForwardingsCreateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdPortForwardingsPost(floatingipId, floatingipsPortForwardingsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsDelete(floatingipId: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsDelete(floatingipId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FloatingipsFloatingipIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsGet(sortKey?: string, sortDir?: FloatingipsFloatingipIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsIdDelete(floatingipId: string, id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsIdDelete(floatingipId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsIdGet(floatingipId: string, id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsIdGet(floatingipId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsIdPut(floatingipId: string, id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsIdPut(floatingipId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/tags/{id} API
     * @param {FloatingipsTagsUpdateAllRequest} [floatingipsTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsFloatingipIdTagsPut(floatingipId: string, floatingipsTagsUpdateAllRequest?: FloatingipsTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsFloatingipIdTagsPut(floatingipId, floatingipsTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/floatingips API
     * @param {string} [floatingIpAddress] floating_ip_address query parameter for /v2.0/floatingips API
     * @param {string} [floatingNetworkId] floating_network_id query parameter for /v2.0/floatingips API
     * @param {string | null} [routerId] router_id query parameter for /v2.0/floatingips API
     * @param {string | null} [portId] port_id query parameter for /v2.0/floatingips API
     * @param {string} [fixedIpAddress] fixed_ip_address query parameter for /v2.0/floatingips API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/floatingips API
     * @param {string} [status] status query parameter for /v2.0/floatingips API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/floatingips API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/floatingips API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/floatingips API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/floatingips API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/floatingips API
     * @param {string} [description] description query parameter for /v2.0/floatingips API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {FloatingipsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsGet(id?: string, floatingIpAddress?: string, floatingNetworkId?: string, routerId?: string | null, portId?: string | null, fixedIpAddress?: string, tenantId?: string, status?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: FloatingipsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsGet(id, floatingIpAddress, floatingNetworkId, routerId, portId, fixedIpAddress, tenantId, status, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/floatingips/{id} API
     * @param {FloatingipUpdateRequest} [floatingipUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsIdPut(id: string, floatingipUpdateRequest?: FloatingipUpdateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsIdPut(id, floatingipUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {FloatingipsCreateRequest} [floatingipsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsApi
     */
    public floatingipsPost(floatingipsCreateRequest?: FloatingipsCreateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipsApiFp(this.configuration).floatingipsPost(floatingipsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const FloatingipsFloatingipIdPortForwardingsGetProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;
export type FloatingipsFloatingipIdPortForwardingsGetProtocolEnum = typeof FloatingipsFloatingipIdPortForwardingsGetProtocolEnum[keyof typeof FloatingipsFloatingipIdPortForwardingsGetProtocolEnum];
/**
 * @export
 */
export const FloatingipsFloatingipIdPortForwardingsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FloatingipsFloatingipIdPortForwardingsGetSortDirEnum = typeof FloatingipsFloatingipIdPortForwardingsGetSortDirEnum[keyof typeof FloatingipsFloatingipIdPortForwardingsGetSortDirEnum];
/**
 * @export
 */
export const FloatingipsFloatingipIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FloatingipsFloatingipIdTagsGetSortDirEnum = typeof FloatingipsFloatingipIdTagsGetSortDirEnum[keyof typeof FloatingipsFloatingipIdTagsGetSortDirEnum];
/**
 * @export
 */
export const FloatingipsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type FloatingipsGetSortDirEnum = typeof FloatingipsGetSortDirEnum[keyof typeof FloatingipsGetSortDirEnum];


/**
 * FloatingipsPortForwardingsApi - axios parameter creator
 * @export
 */
export const FloatingipsPortForwardingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdDelete: async (floatingipId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdDelete', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdDelete', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/port_forwardings/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdGet: async (floatingipId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdGet', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdGet', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/port_forwardings/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingUpdateRequest} [floatingipsPortForwardingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdPut: async (floatingipId: string, id: string, floatingipsPortForwardingUpdateRequest?: FloatingipsPortForwardingUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'floatingipId' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdPut', 'floatingipId', floatingipId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('floatingipsFloatingipIdPortForwardingsIdPut', 'id', id)
            const localVarPath = `/v2.0/floatingips/{floatingip_id}/port_forwardings/{id}`
                .replace(`{${"floatingip_id"}}`, encodeURIComponent(String(floatingipId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(floatingipsPortForwardingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FloatingipsPortForwardingsApi - functional programming interface
 * @export
 */
export const FloatingipsPortForwardingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FloatingipsPortForwardingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsPortForwardingsApi.floatingipsFloatingipIdPortForwardingsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdPortForwardingsIdGet(floatingipId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsPortForwardingShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdPortForwardingsIdGet(floatingipId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsPortForwardingsApi.floatingipsFloatingipIdPortForwardingsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingUpdateRequest} [floatingipsPortForwardingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async floatingipsFloatingipIdPortForwardingsIdPut(floatingipId: string, id: string, floatingipsPortForwardingUpdateRequest?: FloatingipsPortForwardingUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FloatingipsPortForwardingUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.floatingipsFloatingipIdPortForwardingsIdPut(floatingipId, id, floatingipsPortForwardingUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['FloatingipsPortForwardingsApi.floatingipsFloatingipIdPortForwardingsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * FloatingipsPortForwardingsApi - factory interface
 * @export
 */
export const FloatingipsPortForwardingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FloatingipsPortForwardingsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdGet(floatingipId: string, id: string, options?: any): AxiosPromise<FloatingipsPortForwardingShowResponse> {
            return localVarFp.floatingipsFloatingipIdPortForwardingsIdGet(floatingipId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
         * @param {FloatingipsPortForwardingUpdateRequest} [floatingipsPortForwardingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        floatingipsFloatingipIdPortForwardingsIdPut(floatingipId: string, id: string, floatingipsPortForwardingUpdateRequest?: FloatingipsPortForwardingUpdateRequest, options?: any): AxiosPromise<FloatingipsPortForwardingUpdateResponse> {
            return localVarFp.floatingipsFloatingipIdPortForwardingsIdPut(floatingipId, id, floatingipsPortForwardingUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FloatingipsPortForwardingsApi - object-oriented interface
 * @export
 * @class FloatingipsPortForwardingsApi
 * @extends {BaseAPI}
 */
export class FloatingipsPortForwardingsApi extends BaseAPI {
    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsPortForwardingsApi
     */
    public floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId: string, id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsPortForwardingsApiFp(this.configuration).floatingipsFloatingipIdPortForwardingsIdDelete(floatingipId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsPortForwardingsApi
     */
    public floatingipsFloatingipIdPortForwardingsIdGet(floatingipId: string, id: string, options?: RawAxiosRequestConfig) {
        return FloatingipsPortForwardingsApiFp(this.configuration).floatingipsFloatingipIdPortForwardingsIdGet(floatingipId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} floatingipId floatingip_id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {string} id id parameter for /v2.0/floatingips/{floatingip_id}/port_forwardings/{id} API
     * @param {FloatingipsPortForwardingUpdateRequest} [floatingipsPortForwardingUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FloatingipsPortForwardingsApi
     */
    public floatingipsFloatingipIdPortForwardingsIdPut(floatingipId: string, id: string, floatingipsPortForwardingUpdateRequest?: FloatingipsPortForwardingUpdateRequest, options?: RawAxiosRequestConfig) {
        return FloatingipsPortForwardingsApiFp(this.configuration).floatingipsFloatingipIdPortForwardingsIdPut(floatingipId, id, floatingipsPortForwardingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * L3AgentSchedulerApi - axios parameter creator
 * @export
 */
export const L3AgentSchedulerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdL3RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersGet: async (sortKey?: string, sortDir?: AgentsAgentIdL3RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/agents/{agent_id}/l3-routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdDelete: async (agentId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdDelete', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdDelete', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/l3-routers/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdGet: async (agentId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdGet', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdGet', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/l3-routers/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdPut: async (agentId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdPut', 'agentId', agentId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersIdPut', 'id', id)
            const localVarPath = `/v2.0/agents/{agent_id}/l3-routers/{id}`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {AgentsL3RoutersCreateRequest} [agentsL3RoutersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersPost: async (agentId: string, agentsL3RoutersCreateRequest?: AgentsL3RoutersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'agentId' is not null or undefined
            assertParamExists('agentsAgentIdL3RoutersPost', 'agentId', agentId)
            const localVarPath = `/v2.0/agents/{agent_id}/l3-routers`
                .replace(`{${"agent_id"}}`, encodeURIComponent(String(agentId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentsL3RoutersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * L3AgentSchedulerApi - functional programming interface
 * @export
 */
export const L3AgentSchedulerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = L3AgentSchedulerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdL3RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdL3RoutersGet(sortKey?: string, sortDir?: AgentsAgentIdL3RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsL3RoutersIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdL3RoutersGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['L3AgentSchedulerApi.agentsAgentIdL3RoutersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdL3RoutersIdDelete(agentId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdL3RoutersIdDelete(agentId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['L3AgentSchedulerApi.agentsAgentIdL3RoutersIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdL3RoutersIdGet(agentId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdL3RoutersIdGet(agentId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['L3AgentSchedulerApi.agentsAgentIdL3RoutersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdL3RoutersIdPut(agentId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdL3RoutersIdPut(agentId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['L3AgentSchedulerApi.agentsAgentIdL3RoutersIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {AgentsL3RoutersCreateRequest} [agentsL3RoutersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsAgentIdL3RoutersPost(agentId: string, agentsL3RoutersCreateRequest?: AgentsL3RoutersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsAgentIdL3RoutersPost(agentId, agentsL3RoutersCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['L3AgentSchedulerApi.agentsAgentIdL3RoutersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * L3AgentSchedulerApi - factory interface
 * @export
 */
export const L3AgentSchedulerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = L3AgentSchedulerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsAgentIdL3RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersGet(sortKey?: string, sortDir?: AgentsAgentIdL3RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AgentsL3RoutersIndexResponse> {
            return localVarFp.agentsAgentIdL3RoutersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdDelete(agentId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.agentsAgentIdL3RoutersIdDelete(agentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdGet(agentId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.agentsAgentIdL3RoutersIdGet(agentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersIdPut(agentId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.agentsAgentIdL3RoutersIdPut(agentId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
         * @param {AgentsL3RoutersCreateRequest} [agentsL3RoutersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsAgentIdL3RoutersPost(agentId: string, agentsL3RoutersCreateRequest?: AgentsL3RoutersCreateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.agentsAgentIdL3RoutersPost(agentId, agentsL3RoutersCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * L3AgentSchedulerApi - object-oriented interface
 * @export
 * @class L3AgentSchedulerApi
 * @extends {BaseAPI}
 */
export class L3AgentSchedulerApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AgentsAgentIdL3RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof L3AgentSchedulerApi
     */
    public agentsAgentIdL3RoutersGet(sortKey?: string, sortDir?: AgentsAgentIdL3RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return L3AgentSchedulerApiFp(this.configuration).agentsAgentIdL3RoutersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof L3AgentSchedulerApi
     */
    public agentsAgentIdL3RoutersIdDelete(agentId: string, id: string, options?: RawAxiosRequestConfig) {
        return L3AgentSchedulerApiFp(this.configuration).agentsAgentIdL3RoutersIdDelete(agentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof L3AgentSchedulerApi
     */
    public agentsAgentIdL3RoutersIdGet(agentId: string, id: string, options?: RawAxiosRequestConfig) {
        return L3AgentSchedulerApiFp(this.configuration).agentsAgentIdL3RoutersIdGet(agentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {string} id id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof L3AgentSchedulerApi
     */
    public agentsAgentIdL3RoutersIdPut(agentId: string, id: string, options?: RawAxiosRequestConfig) {
        return L3AgentSchedulerApiFp(this.configuration).agentsAgentIdL3RoutersIdPut(agentId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} agentId agent_id parameter for /v2.0/agents/{agent_id}/l3-routers/{id} API
     * @param {AgentsL3RoutersCreateRequest} [agentsL3RoutersCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof L3AgentSchedulerApi
     */
    public agentsAgentIdL3RoutersPost(agentId: string, agentsL3RoutersCreateRequest?: AgentsL3RoutersCreateRequest, options?: RawAxiosRequestConfig) {
        return L3AgentSchedulerApiFp(this.configuration).agentsAgentIdL3RoutersPost(agentId, agentsL3RoutersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AgentsAgentIdL3RoutersGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AgentsAgentIdL3RoutersGetSortDirEnum = typeof AgentsAgentIdL3RoutersGetSortDirEnum[keyof typeof AgentsAgentIdL3RoutersGetSortDirEnum];


/**
 * LocalIpsApi - axios parameter creator
 * @export
 */
export const LocalIpsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/local-ips API
         * @param {string} [name] name query parameter for /v2.0/local-ips API
         * @param {string} [description] description query parameter for /v2.0/local-ips API
         * @param {string} [projectId] project_id query parameter for /v2.0/local-ips API
         * @param {string} [localPortId] local_port_id query parameter for /v2.0/local-ips API
         * @param {string} [networkId] network_id query parameter for /v2.0/local-ips API
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local-ips API
         * @param {LocalIpsGetIpModeEnum} [ipMode] ip_mode query parameter for /v2.0/local-ips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/local-ips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsGet: async (id?: string, name?: string, description?: string, projectId?: string, localPortId?: string, networkId?: string, localIpAddress?: string, ipMode?: LocalIpsGetIpModeEnum, revisionNumber?: string, sortKey?: string, sortDir?: LocalIpsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/local-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (localPortId !== undefined) {
                localVarQueryParameter['local_port_id'] = localPortId;
            }

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = networkId;
            }

            if (localIpAddress !== undefined) {
                localVarQueryParameter['local_ip_address'] = localIpAddress;
            }

            if (ipMode !== undefined) {
                localVarQueryParameter['ip_mode'] = ipMode;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsIdDelete', 'id', id)
            const localVarPath = `/v2.0/local-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsIdGet', 'id', id)
            const localVarPath = `/v2.0/local-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {LocalIpUpdateRequest} [localIpUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdPut: async (id: string, localIpUpdateRequest?: LocalIpUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsIdPut', 'id', id)
            const localVarPath = `/v2.0/local-ips/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localIpUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedPortId] fixed_port_id query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedIp] fixed_ip query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [host] host query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsLocalIpIdPortAssociationsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsGet: async (localIpAddress?: string, fixedPortId?: string, fixedIp?: string, host?: string, sortKey?: string, sortDir?: LocalIpsLocalIpIdPortAssociationsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/local_ips/{local_ip_id}/port_associations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (localIpAddress !== undefined) {
                localVarQueryParameter['local_ip_address'] = localIpAddress;
            }

            if (fixedPortId !== undefined) {
                localVarQueryParameter['fixed_port_id'] = fixedPortId;
            }

            if (fixedIp !== undefined) {
                localVarQueryParameter['fixed_ip'] = fixedIp;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdDelete: async (localIpId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localIpId' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdDelete', 'localIpId', localIpId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdDelete', 'id', id)
            const localVarPath = `/v2.0/local_ips/{local_ip_id}/port_associations/{id}`
                .replace(`{${"local_ip_id"}}`, encodeURIComponent(String(localIpId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdGet: async (localIpId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localIpId' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdGet', 'localIpId', localIpId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdGet', 'id', id)
            const localVarPath = `/v2.0/local_ips/{local_ip_id}/port_associations/{id}`
                .replace(`{${"local_ip_id"}}`, encodeURIComponent(String(localIpId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationUpdateRequest} [localIpsPortAssociationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdPut: async (localIpId: string, id: string, localIpsPortAssociationUpdateRequest?: LocalIpsPortAssociationUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localIpId' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdPut', 'localIpId', localIpId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsIdPut', 'id', id)
            const localVarPath = `/v2.0/local_ips/{local_ip_id}/port_associations/{id}`
                .replace(`{${"local_ip_id"}}`, encodeURIComponent(String(localIpId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localIpsPortAssociationUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationsCreateRequest} [localIpsPortAssociationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsPost: async (localIpId: string, localIpsPortAssociationsCreateRequest?: LocalIpsPortAssociationsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'localIpId' is not null or undefined
            assertParamExists('localIpsLocalIpIdPortAssociationsPost', 'localIpId', localIpId)
            const localVarPath = `/v2.0/local_ips/{local_ip_id}/port_associations`
                .replace(`{${"local_ip_id"}}`, encodeURIComponent(String(localIpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localIpsPortAssociationsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LocalIpsCreateRequest} [localIpsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsPost: async (localIpsCreateRequest?: LocalIpsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/local-ips`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(localIpsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LocalIpsApi - functional programming interface
 * @export
 */
export const LocalIpsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LocalIpsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/local-ips API
         * @param {string} [name] name query parameter for /v2.0/local-ips API
         * @param {string} [description] description query parameter for /v2.0/local-ips API
         * @param {string} [projectId] project_id query parameter for /v2.0/local-ips API
         * @param {string} [localPortId] local_port_id query parameter for /v2.0/local-ips API
         * @param {string} [networkId] network_id query parameter for /v2.0/local-ips API
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local-ips API
         * @param {LocalIpsGetIpModeEnum} [ipMode] ip_mode query parameter for /v2.0/local-ips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/local-ips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsGet(id?: string, name?: string, description?: string, projectId?: string, localPortId?: string, networkId?: string, localIpAddress?: string, ipMode?: LocalIpsGetIpModeEnum, revisionNumber?: string, sortKey?: string, sortDir?: LocalIpsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsGet(id, name, description, projectId, localPortId, networkId, localIpAddress, ipMode, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {LocalIpUpdateRequest} [localIpUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsIdPut(id: string, localIpUpdateRequest?: LocalIpUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsIdPut(id, localIpUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedPortId] fixed_port_id query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedIp] fixed_ip query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [host] host query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsLocalIpIdPortAssociationsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsLocalIpIdPortAssociationsGet(localIpAddress?: string, fixedPortId?: string, fixedIp?: string, host?: string, sortKey?: string, sortDir?: LocalIpsLocalIpIdPortAssociationsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsPortAssociationsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsLocalIpIdPortAssociationsGet(localIpAddress, fixedPortId, fixedIp, host, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsLocalIpIdPortAssociationsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsLocalIpIdPortAssociationsIdDelete(localIpId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsLocalIpIdPortAssociationsIdDelete(localIpId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsLocalIpIdPortAssociationsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsLocalIpIdPortAssociationsIdGet(localIpId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsPortAssociationShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsLocalIpIdPortAssociationsIdGet(localIpId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsLocalIpIdPortAssociationsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationUpdateRequest} [localIpsPortAssociationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsLocalIpIdPortAssociationsIdPut(localIpId: string, id: string, localIpsPortAssociationUpdateRequest?: LocalIpsPortAssociationUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsPortAssociationUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsLocalIpIdPortAssociationsIdPut(localIpId, id, localIpsPortAssociationUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsLocalIpIdPortAssociationsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationsCreateRequest} [localIpsPortAssociationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsLocalIpIdPortAssociationsPost(localIpId: string, localIpsPortAssociationsCreateRequest?: LocalIpsPortAssociationsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsPortAssociationsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsLocalIpIdPortAssociationsPost(localIpId, localIpsPortAssociationsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsLocalIpIdPortAssociationsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {LocalIpsCreateRequest} [localIpsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async localIpsPost(localIpsCreateRequest?: LocalIpsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LocalIpsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.localIpsPost(localIpsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LocalIpsApi.localIpsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LocalIpsApi - factory interface
 * @export
 */
export const LocalIpsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LocalIpsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/local-ips API
         * @param {string} [name] name query parameter for /v2.0/local-ips API
         * @param {string} [description] description query parameter for /v2.0/local-ips API
         * @param {string} [projectId] project_id query parameter for /v2.0/local-ips API
         * @param {string} [localPortId] local_port_id query parameter for /v2.0/local-ips API
         * @param {string} [networkId] network_id query parameter for /v2.0/local-ips API
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local-ips API
         * @param {LocalIpsGetIpModeEnum} [ipMode] ip_mode query parameter for /v2.0/local-ips API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/local-ips API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsGet(id?: string, name?: string, description?: string, projectId?: string, localPortId?: string, networkId?: string, localIpAddress?: string, ipMode?: LocalIpsGetIpModeEnum, revisionNumber?: string, sortKey?: string, sortDir?: LocalIpsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<LocalIpsIndexResponse> {
            return localVarFp.localIpsGet(id, name, description, projectId, localPortId, networkId, localIpAddress, ipMode, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.localIpsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdGet(id: string, options?: any): AxiosPromise<LocalIpShowResponse> {
            return localVarFp.localIpsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/local-ips/{id} API
         * @param {LocalIpUpdateRequest} [localIpUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsIdPut(id: string, localIpUpdateRequest?: LocalIpUpdateRequest, options?: any): AxiosPromise<LocalIpUpdateResponse> {
            return localVarFp.localIpsIdPut(id, localIpUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedPortId] fixed_port_id query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [fixedIp] fixed_ip query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [host] host query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LocalIpsLocalIpIdPortAssociationsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsGet(localIpAddress?: string, fixedPortId?: string, fixedIp?: string, host?: string, sortKey?: string, sortDir?: LocalIpsLocalIpIdPortAssociationsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<LocalIpsPortAssociationsIndexResponse> {
            return localVarFp.localIpsLocalIpIdPortAssociationsGet(localIpAddress, fixedPortId, fixedIp, host, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdDelete(localIpId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.localIpsLocalIpIdPortAssociationsIdDelete(localIpId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdGet(localIpId: string, id: string, options?: any): AxiosPromise<LocalIpsPortAssociationShowResponse> {
            return localVarFp.localIpsLocalIpIdPortAssociationsIdGet(localIpId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationUpdateRequest} [localIpsPortAssociationUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsIdPut(localIpId: string, id: string, localIpsPortAssociationUpdateRequest?: LocalIpsPortAssociationUpdateRequest, options?: any): AxiosPromise<LocalIpsPortAssociationUpdateResponse> {
            return localVarFp.localIpsLocalIpIdPortAssociationsIdPut(localIpId, id, localIpsPortAssociationUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
         * @param {LocalIpsPortAssociationsCreateRequest} [localIpsPortAssociationsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsLocalIpIdPortAssociationsPost(localIpId: string, localIpsPortAssociationsCreateRequest?: LocalIpsPortAssociationsCreateRequest, options?: any): AxiosPromise<LocalIpsPortAssociationsCreateResponse> {
            return localVarFp.localIpsLocalIpIdPortAssociationsPost(localIpId, localIpsPortAssociationsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LocalIpsCreateRequest} [localIpsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        localIpsPost(localIpsCreateRequest?: LocalIpsCreateRequest, options?: any): AxiosPromise<LocalIpsCreateResponse> {
            return localVarFp.localIpsPost(localIpsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LocalIpsApi - object-oriented interface
 * @export
 * @class LocalIpsApi
 * @extends {BaseAPI}
 */
export class LocalIpsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/local-ips API
     * @param {string} [name] name query parameter for /v2.0/local-ips API
     * @param {string} [description] description query parameter for /v2.0/local-ips API
     * @param {string} [projectId] project_id query parameter for /v2.0/local-ips API
     * @param {string} [localPortId] local_port_id query parameter for /v2.0/local-ips API
     * @param {string} [networkId] network_id query parameter for /v2.0/local-ips API
     * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local-ips API
     * @param {LocalIpsGetIpModeEnum} [ipMode] ip_mode query parameter for /v2.0/local-ips API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/local-ips API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {LocalIpsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsGet(id?: string, name?: string, description?: string, projectId?: string, localPortId?: string, networkId?: string, localIpAddress?: string, ipMode?: LocalIpsGetIpModeEnum, revisionNumber?: string, sortKey?: string, sortDir?: LocalIpsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsGet(id, name, description, projectId, localPortId, networkId, localIpAddress, ipMode, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/local-ips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/local-ips/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/local-ips/{id} API
     * @param {LocalIpUpdateRequest} [localIpUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsIdPut(id: string, localIpUpdateRequest?: LocalIpUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsIdPut(id, localIpUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [localIpAddress] local_ip_address query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
     * @param {string} [fixedPortId] fixed_port_id query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
     * @param {string} [fixedIp] fixed_ip query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
     * @param {string} [host] host query parameter for /v2.0/local_ips/{local_ip_id}/port_associations API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {LocalIpsLocalIpIdPortAssociationsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsLocalIpIdPortAssociationsGet(localIpAddress?: string, fixedPortId?: string, fixedIp?: string, host?: string, sortKey?: string, sortDir?: LocalIpsLocalIpIdPortAssociationsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsLocalIpIdPortAssociationsGet(localIpAddress, fixedPortId, fixedIp, host, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsLocalIpIdPortAssociationsIdDelete(localIpId: string, id: string, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsLocalIpIdPortAssociationsIdDelete(localIpId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsLocalIpIdPortAssociationsIdGet(localIpId: string, id: string, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsLocalIpIdPortAssociationsIdGet(localIpId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {string} id id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {LocalIpsPortAssociationUpdateRequest} [localIpsPortAssociationUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsLocalIpIdPortAssociationsIdPut(localIpId: string, id: string, localIpsPortAssociationUpdateRequest?: LocalIpsPortAssociationUpdateRequest, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsLocalIpIdPortAssociationsIdPut(localIpId, id, localIpsPortAssociationUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} localIpId local_ip_id parameter for /v2.0/local_ips/{local_ip_id}/port_associations/{id} API
     * @param {LocalIpsPortAssociationsCreateRequest} [localIpsPortAssociationsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsLocalIpIdPortAssociationsPost(localIpId: string, localIpsPortAssociationsCreateRequest?: LocalIpsPortAssociationsCreateRequest, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsLocalIpIdPortAssociationsPost(localIpId, localIpsPortAssociationsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LocalIpsCreateRequest} [localIpsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LocalIpsApi
     */
    public localIpsPost(localIpsCreateRequest?: LocalIpsCreateRequest, options?: RawAxiosRequestConfig) {
        return LocalIpsApiFp(this.configuration).localIpsPost(localIpsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LocalIpsGetIpModeEnum = {
    Translate: 'translate',
    Passthrough: 'passthrough'
} as const;
export type LocalIpsGetIpModeEnum = typeof LocalIpsGetIpModeEnum[keyof typeof LocalIpsGetIpModeEnum];
/**
 * @export
 */
export const LocalIpsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LocalIpsGetSortDirEnum = typeof LocalIpsGetSortDirEnum[keyof typeof LocalIpsGetSortDirEnum];
/**
 * @export
 */
export const LocalIpsLocalIpIdPortAssociationsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LocalIpsLocalIpIdPortAssociationsGetSortDirEnum = typeof LocalIpsLocalIpIdPortAssociationsGetSortDirEnum[keyof typeof LocalIpsLocalIpIdPortAssociationsGetSortDirEnum];


/**
 * LogApi - axios parameter creator
 * @export
 */
export const LogApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLoggableResourcesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesGet: async (sortKey?: string, sortDir?: LogLoggableResourcesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/log/loggable-resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLoggableResourcesIdDelete', 'id', id)
            const localVarPath = `/v2.0/log/loggable-resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLoggableResourcesIdGet', 'id', id)
            const localVarPath = `/v2.0/log/loggable-resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {LogLoggableResourceUpdateRequest} [logLoggableResourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdPut: async (id: string, logLoggableResourceUpdateRequest?: LogLoggableResourceUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLoggableResourcesIdPut', 'id', id)
            const localVarPath = `/v2.0/log/loggable-resources/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logLoggableResourceUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogLoggableResourcesCreateRequest} [logLoggableResourcesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesPost: async (logLoggableResourcesCreateRequest?: LogLoggableResourcesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/log/loggable-resources`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logLoggableResourcesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/log/logs API
         * @param {string} [projectId] project_id query parameter for /v2.0/log/logs API
         * @param {string} [name] name query parameter for /v2.0/log/logs API
         * @param {string} [resourceType] resource_type query parameter for /v2.0/log/logs API
         * @param {string | null} [resourceId] resource_id query parameter for /v2.0/log/logs API
         * @param {LogLogsGetEventEnum} [event] event query parameter for /v2.0/log/logs API
         * @param {string | null} [targetId] target_id query parameter for /v2.0/log/logs API
         * @param {string | boolean} [enabled] enabled query parameter for /v2.0/log/logs API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/log/logs API
         * @param {string} [description] description query parameter for /v2.0/log/logs API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLogsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsGet: async (id?: string, projectId?: string, name?: string, resourceType?: string, resourceId?: string | null, event?: LogLogsGetEventEnum, targetId?: string | null, enabled?: string | boolean, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: LogLogsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/log/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (resourceType !== undefined) {
                localVarQueryParameter['resource_type'] = resourceType;
            }

            if (resourceId !== undefined) {
                localVarQueryParameter['resource_id'] = resourceId;
            }

            if (event !== undefined) {
                localVarQueryParameter['event'] = event;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target_id'] = targetId;
            }

            if (enabled !== undefined) {
                for (const [key, value] of Object.entries(enabled)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLogsIdDelete', 'id', id)
            const localVarPath = `/v2.0/log/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLogsIdGet', 'id', id)
            const localVarPath = `/v2.0/log/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {LogLogUpdateRequest} [logLogUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdPut: async (id: string, logLogUpdateRequest?: LogLogUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('logLogsIdPut', 'id', id)
            const localVarPath = `/v2.0/log/logs/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logLogUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {LogLogsCreateRequest} [logLogsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsPost: async (logLogsCreateRequest?: LogLogsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/log/logs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(logLogsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LogApi - functional programming interface
 * @export
 */
export const LogApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LogApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLoggableResourcesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLoggableResourcesGet(sortKey?: string, sortDir?: LogLoggableResourcesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLoggableResourcesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLoggableResourcesGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLoggableResourcesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLoggableResourcesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLoggableResourcesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLoggableResourcesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLoggableResourcesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLoggableResourceShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLoggableResourcesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLoggableResourcesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {LogLoggableResourceUpdateRequest} [logLoggableResourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLoggableResourcesIdPut(id: string, logLoggableResourceUpdateRequest?: LogLoggableResourceUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLoggableResourceUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLoggableResourcesIdPut(id, logLoggableResourceUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLoggableResourcesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {LogLoggableResourcesCreateRequest} [logLoggableResourcesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLoggableResourcesPost(logLoggableResourcesCreateRequest?: LogLoggableResourcesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLoggableResourcesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLoggableResourcesPost(logLoggableResourcesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLoggableResourcesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/log/logs API
         * @param {string} [projectId] project_id query parameter for /v2.0/log/logs API
         * @param {string} [name] name query parameter for /v2.0/log/logs API
         * @param {string} [resourceType] resource_type query parameter for /v2.0/log/logs API
         * @param {string | null} [resourceId] resource_id query parameter for /v2.0/log/logs API
         * @param {LogLogsGetEventEnum} [event] event query parameter for /v2.0/log/logs API
         * @param {string | null} [targetId] target_id query parameter for /v2.0/log/logs API
         * @param {string | boolean} [enabled] enabled query parameter for /v2.0/log/logs API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/log/logs API
         * @param {string} [description] description query parameter for /v2.0/log/logs API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLogsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLogsGet(id?: string, projectId?: string, name?: string, resourceType?: string, resourceId?: string | null, event?: LogLogsGetEventEnum, targetId?: string | null, enabled?: string | boolean, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: LogLogsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLogsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLogsGet(id, projectId, name, resourceType, resourceId, event, targetId, enabled, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLogsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLogsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLogsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLogsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLogsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLogShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLogsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLogsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {LogLogUpdateRequest} [logLogUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLogsIdPut(id: string, logLogUpdateRequest?: LogLogUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLogUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLogsIdPut(id, logLogUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLogsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {LogLogsCreateRequest} [logLogsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async logLogsPost(logLogsCreateRequest?: LogLogsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LogLogsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.logLogsPost(logLogsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LogApi.logLogsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LogApi - factory interface
 * @export
 */
export const LogApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LogApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLoggableResourcesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesGet(sortKey?: string, sortDir?: LogLoggableResourcesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<LogLoggableResourcesIndexResponse> {
            return localVarFp.logLoggableResourcesGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.logLoggableResourcesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdGet(id: string, options?: any): AxiosPromise<LogLoggableResourceShowResponse> {
            return localVarFp.logLoggableResourcesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
         * @param {LogLoggableResourceUpdateRequest} [logLoggableResourceUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesIdPut(id: string, logLoggableResourceUpdateRequest?: LogLoggableResourceUpdateRequest, options?: any): AxiosPromise<LogLoggableResourceUpdateResponse> {
            return localVarFp.logLoggableResourcesIdPut(id, logLoggableResourceUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LogLoggableResourcesCreateRequest} [logLoggableResourcesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLoggableResourcesPost(logLoggableResourcesCreateRequest?: LogLoggableResourcesCreateRequest, options?: any): AxiosPromise<LogLoggableResourcesCreateResponse> {
            return localVarFp.logLoggableResourcesPost(logLoggableResourcesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/log/logs API
         * @param {string} [projectId] project_id query parameter for /v2.0/log/logs API
         * @param {string} [name] name query parameter for /v2.0/log/logs API
         * @param {string} [resourceType] resource_type query parameter for /v2.0/log/logs API
         * @param {string | null} [resourceId] resource_id query parameter for /v2.0/log/logs API
         * @param {LogLogsGetEventEnum} [event] event query parameter for /v2.0/log/logs API
         * @param {string | null} [targetId] target_id query parameter for /v2.0/log/logs API
         * @param {string | boolean} [enabled] enabled query parameter for /v2.0/log/logs API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/log/logs API
         * @param {string} [description] description query parameter for /v2.0/log/logs API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {LogLogsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsGet(id?: string, projectId?: string, name?: string, resourceType?: string, resourceId?: string | null, event?: LogLogsGetEventEnum, targetId?: string | null, enabled?: string | boolean, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: LogLogsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<LogLogsIndexResponse> {
            return localVarFp.logLogsGet(id, projectId, name, resourceType, resourceId, event, targetId, enabled, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.logLogsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdGet(id: string, options?: any): AxiosPromise<LogLogShowResponse> {
            return localVarFp.logLogsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/log/logs/{id} API
         * @param {LogLogUpdateRequest} [logLogUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsIdPut(id: string, logLogUpdateRequest?: LogLogUpdateRequest, options?: any): AxiosPromise<LogLogUpdateResponse> {
            return localVarFp.logLogsIdPut(id, logLogUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {LogLogsCreateRequest} [logLogsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        logLogsPost(logLogsCreateRequest?: LogLogsCreateRequest, options?: any): AxiosPromise<LogLogsCreateResponse> {
            return localVarFp.logLogsPost(logLogsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LogApi - object-oriented interface
 * @export
 * @class LogApi
 * @extends {BaseAPI}
 */
export class LogApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {LogLoggableResourcesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLoggableResourcesGet(sortKey?: string, sortDir?: LogLoggableResourcesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLoggableResourcesGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLoggableResourcesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLoggableResourcesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLoggableResourcesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLoggableResourcesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/loggable-resources/{id} API
     * @param {LogLoggableResourceUpdateRequest} [logLoggableResourceUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLoggableResourcesIdPut(id: string, logLoggableResourceUpdateRequest?: LogLoggableResourceUpdateRequest, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLoggableResourcesIdPut(id, logLoggableResourceUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LogLoggableResourcesCreateRequest} [logLoggableResourcesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLoggableResourcesPost(logLoggableResourcesCreateRequest?: LogLoggableResourcesCreateRequest, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLoggableResourcesPost(logLoggableResourcesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/log/logs API
     * @param {string} [projectId] project_id query parameter for /v2.0/log/logs API
     * @param {string} [name] name query parameter for /v2.0/log/logs API
     * @param {string} [resourceType] resource_type query parameter for /v2.0/log/logs API
     * @param {string | null} [resourceId] resource_id query parameter for /v2.0/log/logs API
     * @param {LogLogsGetEventEnum} [event] event query parameter for /v2.0/log/logs API
     * @param {string | null} [targetId] target_id query parameter for /v2.0/log/logs API
     * @param {string | boolean} [enabled] enabled query parameter for /v2.0/log/logs API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/log/logs API
     * @param {string} [description] description query parameter for /v2.0/log/logs API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {LogLogsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLogsGet(id?: string, projectId?: string, name?: string, resourceType?: string, resourceId?: string | null, event?: LogLogsGetEventEnum, targetId?: string | null, enabled?: string | boolean, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: LogLogsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLogsGet(id, projectId, name, resourceType, resourceId, event, targetId, enabled, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/logs/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLogsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLogsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/logs/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLogsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLogsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/log/logs/{id} API
     * @param {LogLogUpdateRequest} [logLogUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLogsIdPut(id: string, logLogUpdateRequest?: LogLogUpdateRequest, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLogsIdPut(id, logLogUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {LogLogsCreateRequest} [logLogsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LogApi
     */
    public logLogsPost(logLogsCreateRequest?: LogLogsCreateRequest, options?: RawAxiosRequestConfig) {
        return LogApiFp(this.configuration).logLogsPost(logLogsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const LogLoggableResourcesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LogLoggableResourcesGetSortDirEnum = typeof LogLoggableResourcesGetSortDirEnum[keyof typeof LogLoggableResourcesGetSortDirEnum];
/**
 * @export
 */
export const LogLogsGetEventEnum = {
    Accept: 'ACCEPT',
    Drop: 'DROP',
    All: 'ALL'
} as const;
export type LogLogsGetEventEnum = typeof LogLogsGetEventEnum[keyof typeof LogLogsGetEventEnum];
/**
 * @export
 */
export const LogLogsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type LogLogsGetSortDirEnum = typeof LogLogsGetSortDirEnum[keyof typeof LogLogsGetSortDirEnum];


/**
 * MeteringApi - axios parameter creator
 * @export
 */
export const MeteringApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [meteringLabelId] metering_label_id query parameter for /v2.0/metering/metering-label-rules API
         * @param {MeteringMeteringLabelRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/metering/metering-label-rules API
         * @param {string | boolean} [excluded] excluded query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sourceIpPrefix] source_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [destinationIpPrefix] destination_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesGet: async (id?: string, meteringLabelId?: string, direction?: MeteringMeteringLabelRulesGetDirectionEnum, excluded?: string | boolean, remoteIpPrefix?: string, sourceIpPrefix?: string, destinationIpPrefix?: string, sortKey?: string, sortDir?: MeteringMeteringLabelRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/metering/metering-label-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (meteringLabelId !== undefined) {
                localVarQueryParameter['metering_label_id'] = meteringLabelId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (excluded !== undefined) {
                for (const [key, value] of Object.entries(excluded)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (remoteIpPrefix !== undefined) {
                localVarQueryParameter['remote_ip_prefix'] = remoteIpPrefix;
            }

            if (sourceIpPrefix !== undefined) {
                localVarQueryParameter['source_ip_prefix'] = sourceIpPrefix;
            }

            if (destinationIpPrefix !== undefined) {
                localVarQueryParameter['destination_ip_prefix'] = destinationIpPrefix;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/metering/metering-label-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/metering/metering-label-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {MeteringMeteringLabelRuleUpdateRequest} [meteringMeteringLabelRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdPut: async (id: string, meteringMeteringLabelRuleUpdateRequest?: MeteringMeteringLabelRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/metering/metering-label-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meteringMeteringLabelRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MeteringMeteringLabelRulesCreateRequest} [meteringMeteringLabelRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesPost: async (meteringMeteringLabelRulesCreateRequest?: MeteringMeteringLabelRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/metering/metering-label-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meteringMeteringLabelRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-labels API
         * @param {string} [name] name query parameter for /v2.0/metering/metering-labels API
         * @param {string} [description] description query parameter for /v2.0/metering/metering-labels API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/metering/metering-labels API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/metering/metering-labels API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsGet: async (id?: string, name?: string, description?: string, tenantId?: string, shared?: string | boolean, sortKey?: string, sortDir?: MeteringMeteringLabelsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/metering/metering-labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelsIdDelete', 'id', id)
            const localVarPath = `/v2.0/metering/metering-labels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelsIdGet', 'id', id)
            const localVarPath = `/v2.0/metering/metering-labels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {MeteringMeteringLabelUpdateRequest} [meteringMeteringLabelUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdPut: async (id: string, meteringMeteringLabelUpdateRequest?: MeteringMeteringLabelUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('meteringMeteringLabelsIdPut', 'id', id)
            const localVarPath = `/v2.0/metering/metering-labels/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meteringMeteringLabelUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {MeteringMeteringLabelsCreateRequest} [meteringMeteringLabelsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsPost: async (meteringMeteringLabelsCreateRequest?: MeteringMeteringLabelsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/metering/metering-labels`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(meteringMeteringLabelsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MeteringApi - functional programming interface
 * @export
 */
export const MeteringApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MeteringApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [meteringLabelId] metering_label_id query parameter for /v2.0/metering/metering-label-rules API
         * @param {MeteringMeteringLabelRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/metering/metering-label-rules API
         * @param {string | boolean} [excluded] excluded query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sourceIpPrefix] source_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [destinationIpPrefix] destination_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelRulesGet(id?: string, meteringLabelId?: string, direction?: MeteringMeteringLabelRulesGetDirectionEnum, excluded?: string | boolean, remoteIpPrefix?: string, sourceIpPrefix?: string, destinationIpPrefix?: string, sortKey?: string, sortDir?: MeteringMeteringLabelRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelRulesGet(id, meteringLabelId, direction, excluded, remoteIpPrefix, sourceIpPrefix, destinationIpPrefix, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {MeteringMeteringLabelRuleUpdateRequest} [meteringMeteringLabelRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelRulesIdPut(id: string, meteringMeteringLabelRuleUpdateRequest?: MeteringMeteringLabelRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelRulesIdPut(id, meteringMeteringLabelRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {MeteringMeteringLabelRulesCreateRequest} [meteringMeteringLabelRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest?: MeteringMeteringLabelRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-labels API
         * @param {string} [name] name query parameter for /v2.0/metering/metering-labels API
         * @param {string} [description] description query parameter for /v2.0/metering/metering-labels API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/metering/metering-labels API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/metering/metering-labels API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelsGet(id?: string, name?: string, description?: string, tenantId?: string, shared?: string | boolean, sortKey?: string, sortDir?: MeteringMeteringLabelsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelsGet(id, name, description, tenantId, shared, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {MeteringMeteringLabelUpdateRequest} [meteringMeteringLabelUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelsIdPut(id: string, meteringMeteringLabelUpdateRequest?: MeteringMeteringLabelUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelsIdPut(id, meteringMeteringLabelUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {MeteringMeteringLabelsCreateRequest} [meteringMeteringLabelsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest?: MeteringMeteringLabelsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<MeteringMeteringLabelsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['MeteringApi.meteringMeteringLabelsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * MeteringApi - factory interface
 * @export
 */
export const MeteringApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MeteringApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [meteringLabelId] metering_label_id query parameter for /v2.0/metering/metering-label-rules API
         * @param {MeteringMeteringLabelRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/metering/metering-label-rules API
         * @param {string | boolean} [excluded] excluded query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sourceIpPrefix] source_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [destinationIpPrefix] destination_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesGet(id?: string, meteringLabelId?: string, direction?: MeteringMeteringLabelRulesGetDirectionEnum, excluded?: string | boolean, remoteIpPrefix?: string, sourceIpPrefix?: string, destinationIpPrefix?: string, sortKey?: string, sortDir?: MeteringMeteringLabelRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<MeteringMeteringLabelRulesIndexResponse> {
            return localVarFp.meteringMeteringLabelRulesGet(id, meteringLabelId, direction, excluded, remoteIpPrefix, sourceIpPrefix, destinationIpPrefix, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.meteringMeteringLabelRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdGet(id: string, options?: any): AxiosPromise<MeteringMeteringLabelRuleShowResponse> {
            return localVarFp.meteringMeteringLabelRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
         * @param {MeteringMeteringLabelRuleUpdateRequest} [meteringMeteringLabelRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesIdPut(id: string, meteringMeteringLabelRuleUpdateRequest?: MeteringMeteringLabelRuleUpdateRequest, options?: any): AxiosPromise<MeteringMeteringLabelRuleUpdateResponse> {
            return localVarFp.meteringMeteringLabelRulesIdPut(id, meteringMeteringLabelRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MeteringMeteringLabelRulesCreateRequest} [meteringMeteringLabelRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest?: MeteringMeteringLabelRulesCreateRequest, options?: any): AxiosPromise<MeteringMeteringLabelRulesCreateResponse> {
            return localVarFp.meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/metering/metering-labels API
         * @param {string} [name] name query parameter for /v2.0/metering/metering-labels API
         * @param {string} [description] description query parameter for /v2.0/metering/metering-labels API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/metering/metering-labels API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/metering/metering-labels API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {MeteringMeteringLabelsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsGet(id?: string, name?: string, description?: string, tenantId?: string, shared?: string | boolean, sortKey?: string, sortDir?: MeteringMeteringLabelsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<MeteringMeteringLabelsIndexResponse> {
            return localVarFp.meteringMeteringLabelsGet(id, name, description, tenantId, shared, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.meteringMeteringLabelsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdGet(id: string, options?: any): AxiosPromise<MeteringMeteringLabelShowResponse> {
            return localVarFp.meteringMeteringLabelsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
         * @param {MeteringMeteringLabelUpdateRequest} [meteringMeteringLabelUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsIdPut(id: string, meteringMeteringLabelUpdateRequest?: MeteringMeteringLabelUpdateRequest, options?: any): AxiosPromise<MeteringMeteringLabelUpdateResponse> {
            return localVarFp.meteringMeteringLabelsIdPut(id, meteringMeteringLabelUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {MeteringMeteringLabelsCreateRequest} [meteringMeteringLabelsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest?: MeteringMeteringLabelsCreateRequest, options?: any): AxiosPromise<MeteringMeteringLabelsCreateResponse> {
            return localVarFp.meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MeteringApi - object-oriented interface
 * @export
 * @class MeteringApi
 * @extends {BaseAPI}
 */
export class MeteringApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/metering/metering-label-rules API
     * @param {string} [meteringLabelId] metering_label_id query parameter for /v2.0/metering/metering-label-rules API
     * @param {MeteringMeteringLabelRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/metering/metering-label-rules API
     * @param {string | boolean} [excluded] excluded query parameter for /v2.0/metering/metering-label-rules API
     * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
     * @param {string} [sourceIpPrefix] source_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
     * @param {string} [destinationIpPrefix] destination_ip_prefix query parameter for /v2.0/metering/metering-label-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {MeteringMeteringLabelRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelRulesGet(id?: string, meteringLabelId?: string, direction?: MeteringMeteringLabelRulesGetDirectionEnum, excluded?: string | boolean, remoteIpPrefix?: string, sourceIpPrefix?: string, destinationIpPrefix?: string, sortKey?: string, sortDir?: MeteringMeteringLabelRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelRulesGet(id, meteringLabelId, direction, excluded, remoteIpPrefix, sourceIpPrefix, destinationIpPrefix, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-label-rules/{id} API
     * @param {MeteringMeteringLabelRuleUpdateRequest} [meteringMeteringLabelRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelRulesIdPut(id: string, meteringMeteringLabelRuleUpdateRequest?: MeteringMeteringLabelRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelRulesIdPut(id, meteringMeteringLabelRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MeteringMeteringLabelRulesCreateRequest} [meteringMeteringLabelRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest?: MeteringMeteringLabelRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelRulesPost(meteringMeteringLabelRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/metering/metering-labels API
     * @param {string} [name] name query parameter for /v2.0/metering/metering-labels API
     * @param {string} [description] description query parameter for /v2.0/metering/metering-labels API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/metering/metering-labels API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/metering/metering-labels API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {MeteringMeteringLabelsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelsGet(id?: string, name?: string, description?: string, tenantId?: string, shared?: string | boolean, sortKey?: string, sortDir?: MeteringMeteringLabelsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelsGet(id, name, description, tenantId, shared, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/metering/metering-labels/{id} API
     * @param {MeteringMeteringLabelUpdateRequest} [meteringMeteringLabelUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelsIdPut(id: string, meteringMeteringLabelUpdateRequest?: MeteringMeteringLabelUpdateRequest, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelsIdPut(id, meteringMeteringLabelUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {MeteringMeteringLabelsCreateRequest} [meteringMeteringLabelsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MeteringApi
     */
    public meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest?: MeteringMeteringLabelsCreateRequest, options?: RawAxiosRequestConfig) {
        return MeteringApiFp(this.configuration).meteringMeteringLabelsPost(meteringMeteringLabelsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const MeteringMeteringLabelRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type MeteringMeteringLabelRulesGetDirectionEnum = typeof MeteringMeteringLabelRulesGetDirectionEnum[keyof typeof MeteringMeteringLabelRulesGetDirectionEnum];
/**
 * @export
 */
export const MeteringMeteringLabelRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MeteringMeteringLabelRulesGetSortDirEnum = typeof MeteringMeteringLabelRulesGetSortDirEnum[keyof typeof MeteringMeteringLabelRulesGetSortDirEnum];
/**
 * @export
 */
export const MeteringMeteringLabelsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type MeteringMeteringLabelsGetSortDirEnum = typeof MeteringMeteringLabelsGetSortDirEnum[keyof typeof MeteringMeteringLabelsGetSortDirEnum];


/**
 * NdpProxiesApi - axios parameter creator
 * @export
 */
export const NdpProxiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/ndp-proxies API
         * @param {string} [description] description query parameter for /v2.0/ndp-proxies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ndp-proxies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NdpProxiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesGet: async (name?: string, description?: string, revisionNumber?: string, sortKey?: string, sortDir?: NdpProxiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ndp-proxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ndpProxiesIdDelete', 'id', id)
            const localVarPath = `/v2.0/ndp-proxies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ndpProxiesIdGet', 'id', id)
            const localVarPath = `/v2.0/ndp-proxies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {NdpProxyUpdateRequest} [ndpProxyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdPut: async (id: string, ndpProxyUpdateRequest?: NdpProxyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('ndpProxiesIdPut', 'id', id)
            const localVarPath = `/v2.0/ndp-proxies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ndpProxyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NdpProxiesCreateRequest} [ndpProxiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesPost: async (ndpProxiesCreateRequest?: NdpProxiesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ndp-proxies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(ndpProxiesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NdpProxiesApi - functional programming interface
 * @export
 */
export const NdpProxiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NdpProxiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/ndp-proxies API
         * @param {string} [description] description query parameter for /v2.0/ndp-proxies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ndp-proxies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NdpProxiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ndpProxiesGet(name?: string, description?: string, revisionNumber?: string, sortKey?: string, sortDir?: NdpProxiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NdpProxiesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ndpProxiesGet(name, description, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NdpProxiesApi.ndpProxiesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ndpProxiesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ndpProxiesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NdpProxiesApi.ndpProxiesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ndpProxiesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NdpProxyShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ndpProxiesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NdpProxiesApi.ndpProxiesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {NdpProxyUpdateRequest} [ndpProxyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ndpProxiesIdPut(id: string, ndpProxyUpdateRequest?: NdpProxyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NdpProxyUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ndpProxiesIdPut(id, ndpProxyUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NdpProxiesApi.ndpProxiesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {NdpProxiesCreateRequest} [ndpProxiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ndpProxiesPost(ndpProxiesCreateRequest?: NdpProxiesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NdpProxiesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ndpProxiesPost(ndpProxiesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NdpProxiesApi.ndpProxiesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NdpProxiesApi - factory interface
 * @export
 */
export const NdpProxiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NdpProxiesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [name] name query parameter for /v2.0/ndp-proxies API
         * @param {string} [description] description query parameter for /v2.0/ndp-proxies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ndp-proxies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NdpProxiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesGet(name?: string, description?: string, revisionNumber?: string, sortKey?: string, sortDir?: NdpProxiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NdpProxiesIndexResponse> {
            return localVarFp.ndpProxiesGet(name, description, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.ndpProxiesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdGet(id: string, options?: any): AxiosPromise<NdpProxyShowResponse> {
            return localVarFp.ndpProxiesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
         * @param {NdpProxyUpdateRequest} [ndpProxyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesIdPut(id: string, ndpProxyUpdateRequest?: NdpProxyUpdateRequest, options?: any): AxiosPromise<NdpProxyUpdateResponse> {
            return localVarFp.ndpProxiesIdPut(id, ndpProxyUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NdpProxiesCreateRequest} [ndpProxiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ndpProxiesPost(ndpProxiesCreateRequest?: NdpProxiesCreateRequest, options?: any): AxiosPromise<NdpProxiesCreateResponse> {
            return localVarFp.ndpProxiesPost(ndpProxiesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NdpProxiesApi - object-oriented interface
 * @export
 * @class NdpProxiesApi
 * @extends {BaseAPI}
 */
export class NdpProxiesApi extends BaseAPI {
    /**
     * 
     * @param {string} [name] name query parameter for /v2.0/ndp-proxies API
     * @param {string} [description] description query parameter for /v2.0/ndp-proxies API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ndp-proxies API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NdpProxiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NdpProxiesApi
     */
    public ndpProxiesGet(name?: string, description?: string, revisionNumber?: string, sortKey?: string, sortDir?: NdpProxiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NdpProxiesApiFp(this.configuration).ndpProxiesGet(name, description, revisionNumber, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NdpProxiesApi
     */
    public ndpProxiesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return NdpProxiesApiFp(this.configuration).ndpProxiesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NdpProxiesApi
     */
    public ndpProxiesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return NdpProxiesApiFp(this.configuration).ndpProxiesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/ndp-proxies/{id} API
     * @param {NdpProxyUpdateRequest} [ndpProxyUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NdpProxiesApi
     */
    public ndpProxiesIdPut(id: string, ndpProxyUpdateRequest?: NdpProxyUpdateRequest, options?: RawAxiosRequestConfig) {
        return NdpProxiesApiFp(this.configuration).ndpProxiesIdPut(id, ndpProxyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NdpProxiesCreateRequest} [ndpProxiesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NdpProxiesApi
     */
    public ndpProxiesPost(ndpProxiesCreateRequest?: NdpProxiesCreateRequest, options?: RawAxiosRequestConfig) {
        return NdpProxiesApiFp(this.configuration).ndpProxiesPost(ndpProxiesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NdpProxiesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NdpProxiesGetSortDirEnum = typeof NdpProxiesGetSortDirEnum[keyof typeof NdpProxiesGetSortDirEnum];


/**
 * NetworkIpAvailabilitiesApi - axios parameter creator
 * @export
 */
export const NetworkIpAvailabilitiesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [networkId] network_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [networkName] network_name query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkIpAvailabilitiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesGet: async (networkId?: string, networkName?: string, tenantId?: string, ipVersion?: string, sortKey?: string, sortDir?: NetworkIpAvailabilitiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/network-ip-availabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = networkId;
            }

            if (networkName !== undefined) {
                localVarQueryParameter['network_name'] = networkName;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (ipVersion !== undefined) {
                localVarQueryParameter['ip_version'] = ipVersion;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkIpAvailabilitiesIdDelete', 'id', id)
            const localVarPath = `/v2.0/network-ip-availabilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkIpAvailabilitiesIdGet', 'id', id)
            const localVarPath = `/v2.0/network-ip-availabilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {NetworkIpAvailabilityUpdateRequest} [networkIpAvailabilityUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdPut: async (id: string, networkIpAvailabilityUpdateRequest?: NetworkIpAvailabilityUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkIpAvailabilitiesIdPut', 'id', id)
            const localVarPath = `/v2.0/network-ip-availabilities/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkIpAvailabilityUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NetworkIpAvailabilitiesCreateRequest} [networkIpAvailabilitiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesPost: async (networkIpAvailabilitiesCreateRequest?: NetworkIpAvailabilitiesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/network-ip-availabilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkIpAvailabilitiesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkIpAvailabilitiesApi - functional programming interface
 * @export
 */
export const NetworkIpAvailabilitiesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkIpAvailabilitiesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [networkId] network_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [networkName] network_name query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkIpAvailabilitiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkIpAvailabilitiesGet(networkId?: string, networkName?: string, tenantId?: string, ipVersion?: string, sortKey?: string, sortDir?: NetworkIpAvailabilitiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIpAvailabilitiesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkIpAvailabilitiesGet(networkId, networkName, tenantId, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkIpAvailabilitiesApi.networkIpAvailabilitiesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkIpAvailabilitiesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkIpAvailabilitiesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkIpAvailabilitiesApi.networkIpAvailabilitiesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkIpAvailabilitiesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIpAvailabilityShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkIpAvailabilitiesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkIpAvailabilitiesApi.networkIpAvailabilitiesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {NetworkIpAvailabilityUpdateRequest} [networkIpAvailabilityUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkIpAvailabilitiesIdPut(id: string, networkIpAvailabilityUpdateRequest?: NetworkIpAvailabilityUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIpAvailabilityUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkIpAvailabilitiesIdPut(id, networkIpAvailabilityUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkIpAvailabilitiesApi.networkIpAvailabilitiesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {NetworkIpAvailabilitiesCreateRequest} [networkIpAvailabilitiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest?: NetworkIpAvailabilitiesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkIpAvailabilitiesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkIpAvailabilitiesApi.networkIpAvailabilitiesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NetworkIpAvailabilitiesApi - factory interface
 * @export
 */
export const NetworkIpAvailabilitiesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkIpAvailabilitiesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [networkId] network_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [networkName] network_name query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/network-ip-availabilities API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkIpAvailabilitiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesGet(networkId?: string, networkName?: string, tenantId?: string, ipVersion?: string, sortKey?: string, sortDir?: NetworkIpAvailabilitiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NetworkIpAvailabilitiesIndexResponse> {
            return localVarFp.networkIpAvailabilitiesGet(networkId, networkName, tenantId, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkIpAvailabilitiesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdGet(id: string, options?: any): AxiosPromise<NetworkIpAvailabilityShowResponse> {
            return localVarFp.networkIpAvailabilitiesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
         * @param {NetworkIpAvailabilityUpdateRequest} [networkIpAvailabilityUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesIdPut(id: string, networkIpAvailabilityUpdateRequest?: NetworkIpAvailabilityUpdateRequest, options?: any): AxiosPromise<NetworkIpAvailabilityUpdateResponse> {
            return localVarFp.networkIpAvailabilitiesIdPut(id, networkIpAvailabilityUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NetworkIpAvailabilitiesCreateRequest} [networkIpAvailabilitiesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest?: NetworkIpAvailabilitiesCreateRequest, options?: any): AxiosPromise<NetworkIpAvailabilitiesCreateResponse> {
            return localVarFp.networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkIpAvailabilitiesApi - object-oriented interface
 * @export
 * @class NetworkIpAvailabilitiesApi
 * @extends {BaseAPI}
 */
export class NetworkIpAvailabilitiesApi extends BaseAPI {
    /**
     * 
     * @param {string} [networkId] network_id query parameter for /v2.0/network-ip-availabilities API
     * @param {string} [networkName] network_name query parameter for /v2.0/network-ip-availabilities API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/network-ip-availabilities API
     * @param {string} [ipVersion] ip_version query parameter for /v2.0/network-ip-availabilities API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworkIpAvailabilitiesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkIpAvailabilitiesApi
     */
    public networkIpAvailabilitiesGet(networkId?: string, networkName?: string, tenantId?: string, ipVersion?: string, sortKey?: string, sortDir?: NetworkIpAvailabilitiesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworkIpAvailabilitiesApiFp(this.configuration).networkIpAvailabilitiesGet(networkId, networkName, tenantId, ipVersion, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkIpAvailabilitiesApi
     */
    public networkIpAvailabilitiesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return NetworkIpAvailabilitiesApiFp(this.configuration).networkIpAvailabilitiesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkIpAvailabilitiesApi
     */
    public networkIpAvailabilitiesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return NetworkIpAvailabilitiesApiFp(this.configuration).networkIpAvailabilitiesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-ip-availabilities/{id} API
     * @param {NetworkIpAvailabilityUpdateRequest} [networkIpAvailabilityUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkIpAvailabilitiesApi
     */
    public networkIpAvailabilitiesIdPut(id: string, networkIpAvailabilityUpdateRequest?: NetworkIpAvailabilityUpdateRequest, options?: RawAxiosRequestConfig) {
        return NetworkIpAvailabilitiesApiFp(this.configuration).networkIpAvailabilitiesIdPut(id, networkIpAvailabilityUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NetworkIpAvailabilitiesCreateRequest} [networkIpAvailabilitiesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkIpAvailabilitiesApi
     */
    public networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest?: NetworkIpAvailabilitiesCreateRequest, options?: RawAxiosRequestConfig) {
        return NetworkIpAvailabilitiesApiFp(this.configuration).networkIpAvailabilitiesPost(networkIpAvailabilitiesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NetworkIpAvailabilitiesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworkIpAvailabilitiesGetSortDirEnum = typeof NetworkIpAvailabilitiesGetSortDirEnum[keyof typeof NetworkIpAvailabilitiesGetSortDirEnum];


/**
 * NetworkSegmentRangesApi - axios parameter creator
 * @export
 */
export const NetworkSegmentRangesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/network-segment-ranges API
         * @param {string} [name] name query parameter for /v2.0/network-segment-ranges API
         * @param {string} [projectId] project_id query parameter for /v2.0/network-segment-ranges API
         * @param {NetworkSegmentRangesGetNetworkTypeEnum} [networkType] network_type query parameter for /v2.0/network-segment-ranges API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/network-segment-ranges API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {string} [description] description query parameter for /v2.0/network-segment-ranges API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesGet: async (id?: string, name?: string, projectId?: string, networkType?: NetworkSegmentRangesGetNetworkTypeEnum, physicalNetwork?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: NetworkSegmentRangesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/network-segment-ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (projectId !== undefined) {
                localVarQueryParameter['project_id'] = projectId;
            }

            if (networkType !== undefined) {
                localVarQueryParameter['network_type'] = networkType;
            }

            if (physicalNetwork !== undefined) {
                localVarQueryParameter['physical_network'] = physicalNetwork;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesIdDelete', 'id', id)
            const localVarPath = `/v2.0/network-segment-ranges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesIdGet', 'id', id)
            const localVarPath = `/v2.0/network-segment-ranges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {NetworkSegmentRangeUpdateRequest} [networkSegmentRangeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdPut: async (id: string, networkSegmentRangeUpdateRequest?: NetworkSegmentRangeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesIdPut', 'id', id)
            const localVarPath = `/v2.0/network-segment-ranges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSegmentRangeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsDelete: async (networkSegmentRangeId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSegmentRangeId' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsDelete', 'networkSegmentRangeId', networkSegmentRangeId)
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags`
                .replace(`{${"network_segment_range_id"}}`, encodeURIComponent(String(networkSegmentRangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsGet: async (sortKey?: string, sortDir?: NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete: async (networkSegmentRangeId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSegmentRangeId' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete', 'networkSegmentRangeId', networkSegmentRangeId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id}`
                .replace(`{${"network_segment_range_id"}}`, encodeURIComponent(String(networkSegmentRangeId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdGet: async (networkSegmentRangeId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSegmentRangeId' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdGet', 'networkSegmentRangeId', networkSegmentRangeId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id}`
                .replace(`{${"network_segment_range_id"}}`, encodeURIComponent(String(networkSegmentRangeId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdPut: async (networkSegmentRangeId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSegmentRangeId' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdPut', 'networkSegmentRangeId', networkSegmentRangeId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id}`
                .replace(`{${"network_segment_range_id"}}`, encodeURIComponent(String(networkSegmentRangeId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {NetworkSegmentRangesTagsUpdateAllRequest} [networkSegmentRangesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsPut: async (networkSegmentRangeId: string, networkSegmentRangesTagsUpdateAllRequest?: NetworkSegmentRangesTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkSegmentRangeId' is not null or undefined
            assertParamExists('networkSegmentRangesNetworkSegmentRangeIdTagsPut', 'networkSegmentRangeId', networkSegmentRangeId)
            const localVarPath = `/v2.0/network_segment_ranges/{network_segment_range_id}/tags`
                .replace(`{${"network_segment_range_id"}}`, encodeURIComponent(String(networkSegmentRangeId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSegmentRangesTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NetworkSegmentRangesCreateRequest} [networkSegmentRangesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesPost: async (networkSegmentRangesCreateRequest?: NetworkSegmentRangesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/network-segment-ranges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkSegmentRangesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkSegmentRangesApi - functional programming interface
 * @export
 */
export const NetworkSegmentRangesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkSegmentRangesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/network-segment-ranges API
         * @param {string} [name] name query parameter for /v2.0/network-segment-ranges API
         * @param {string} [projectId] project_id query parameter for /v2.0/network-segment-ranges API
         * @param {NetworkSegmentRangesGetNetworkTypeEnum} [networkType] network_type query parameter for /v2.0/network-segment-ranges API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/network-segment-ranges API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {string} [description] description query parameter for /v2.0/network-segment-ranges API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesGet(id?: string, name?: string, projectId?: string, networkType?: NetworkSegmentRangesGetNetworkTypeEnum, physicalNetwork?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: NetworkSegmentRangesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesGet(id, name, projectId, networkType, physicalNetwork, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangeShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {NetworkSegmentRangeUpdateRequest} [networkSegmentRangeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesIdPut(id: string, networkSegmentRangeUpdateRequest?: NetworkSegmentRangeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangeUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesIdPut(id, networkSegmentRangeUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey?: string, sortDir?: NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangesTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {NetworkSegmentRangesTagsUpdateAllRequest} [networkSegmentRangesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId: string, networkSegmentRangesTagsUpdateAllRequest?: NetworkSegmentRangesTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangesTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId, networkSegmentRangesTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesNetworkSegmentRangeIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {NetworkSegmentRangesCreateRequest} [networkSegmentRangesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networkSegmentRangesPost(networkSegmentRangesCreateRequest?: NetworkSegmentRangesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkSegmentRangesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networkSegmentRangesPost(networkSegmentRangesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkSegmentRangesApi.networkSegmentRangesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NetworkSegmentRangesApi - factory interface
 * @export
 */
export const NetworkSegmentRangesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkSegmentRangesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/network-segment-ranges API
         * @param {string} [name] name query parameter for /v2.0/network-segment-ranges API
         * @param {string} [projectId] project_id query parameter for /v2.0/network-segment-ranges API
         * @param {NetworkSegmentRangesGetNetworkTypeEnum} [networkType] network_type query parameter for /v2.0/network-segment-ranges API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/network-segment-ranges API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/network-segment-ranges API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/network-segment-ranges API
         * @param {string} [description] description query parameter for /v2.0/network-segment-ranges API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesGet(id?: string, name?: string, projectId?: string, networkType?: NetworkSegmentRangesGetNetworkTypeEnum, physicalNetwork?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: NetworkSegmentRangesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NetworkSegmentRangesIndexResponse> {
            return localVarFp.networkSegmentRangesGet(id, name, projectId, networkType, physicalNetwork, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkSegmentRangesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdGet(id: string, options?: any): AxiosPromise<NetworkSegmentRangeShowResponse> {
            return localVarFp.networkSegmentRangesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
         * @param {NetworkSegmentRangeUpdateRequest} [networkSegmentRangeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesIdPut(id: string, networkSegmentRangeUpdateRequest?: NetworkSegmentRangeUpdateRequest, options?: any): AxiosPromise<NetworkSegmentRangeUpdateResponse> {
            return localVarFp.networkSegmentRangesIdPut(id, networkSegmentRangeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey?: string, sortDir?: NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NetworkSegmentRangesTagsIndexResponse> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
         * @param {NetworkSegmentRangesTagsUpdateAllRequest} [networkSegmentRangesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId: string, networkSegmentRangesTagsUpdateAllRequest?: NetworkSegmentRangesTagsUpdateAllRequest, options?: any): AxiosPromise<NetworkSegmentRangesTagsUpdateAllResponse> {
            return localVarFp.networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId, networkSegmentRangesTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NetworkSegmentRangesCreateRequest} [networkSegmentRangesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networkSegmentRangesPost(networkSegmentRangesCreateRequest?: NetworkSegmentRangesCreateRequest, options?: any): AxiosPromise<NetworkSegmentRangesCreateResponse> {
            return localVarFp.networkSegmentRangesPost(networkSegmentRangesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkSegmentRangesApi - object-oriented interface
 * @export
 * @class NetworkSegmentRangesApi
 * @extends {BaseAPI}
 */
export class NetworkSegmentRangesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/network-segment-ranges API
     * @param {string} [name] name query parameter for /v2.0/network-segment-ranges API
     * @param {string} [projectId] project_id query parameter for /v2.0/network-segment-ranges API
     * @param {NetworkSegmentRangesGetNetworkTypeEnum} [networkType] network_type query parameter for /v2.0/network-segment-ranges API
     * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/network-segment-ranges API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/network-segment-ranges API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/network-segment-ranges API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/network-segment-ranges API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/network-segment-ranges API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/network-segment-ranges API
     * @param {string} [description] description query parameter for /v2.0/network-segment-ranges API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworkSegmentRangesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesGet(id?: string, name?: string, projectId?: string, networkType?: NetworkSegmentRangesGetNetworkTypeEnum, physicalNetwork?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: NetworkSegmentRangesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesGet(id, name, projectId, networkType, physicalNetwork, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/network-segment-ranges/{id} API
     * @param {NetworkSegmentRangeUpdateRequest} [networkSegmentRangeUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesIdPut(id: string, networkSegmentRangeUpdateRequest?: NetworkSegmentRangeUpdateRequest, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesIdPut(id, networkSegmentRangeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsDelete(networkSegmentRangeId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey?: string, sortDir?: NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsIdDelete(networkSegmentRangeId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsIdGet(networkSegmentRangeId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsIdPut(networkSegmentRangeId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkSegmentRangeId network_segment_range_id parameter for /v2.0/network_segment_ranges/{network_segment_range_id}/tags/{id} API
     * @param {NetworkSegmentRangesTagsUpdateAllRequest} [networkSegmentRangesTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId: string, networkSegmentRangesTagsUpdateAllRequest?: NetworkSegmentRangesTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesNetworkSegmentRangeIdTagsPut(networkSegmentRangeId, networkSegmentRangesTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NetworkSegmentRangesCreateRequest} [networkSegmentRangesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkSegmentRangesApi
     */
    public networkSegmentRangesPost(networkSegmentRangesCreateRequest?: NetworkSegmentRangesCreateRequest, options?: RawAxiosRequestConfig) {
        return NetworkSegmentRangesApiFp(this.configuration).networkSegmentRangesPost(networkSegmentRangesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NetworkSegmentRangesGetNetworkTypeEnum = {
    Vlan: 'vlan',
    Vxlan: 'vxlan',
    Gre: 'gre',
    Geneve: 'geneve'
} as const;
export type NetworkSegmentRangesGetNetworkTypeEnum = typeof NetworkSegmentRangesGetNetworkTypeEnum[keyof typeof NetworkSegmentRangesGetNetworkTypeEnum];
/**
 * @export
 */
export const NetworkSegmentRangesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworkSegmentRangesGetSortDirEnum = typeof NetworkSegmentRangesGetSortDirEnum[keyof typeof NetworkSegmentRangesGetSortDirEnum];
/**
 * @export
 */
export const NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum = typeof NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum[keyof typeof NetworkSegmentRangesNetworkSegmentRangeIdTagsGetSortDirEnum];


/**
 * NetworkingAgentsApi - axios parameter creator
 * @export
 */
export const NetworkingAgentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/agents API
         * @param {string} [agentType] agent_type query parameter for /v2.0/agents API
         * @param {string} [binary] binary query parameter for /v2.0/agents API
         * @param {string} [topic] topic query parameter for /v2.0/agents API
         * @param {string} [host] host query parameter for /v2.0/agents API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/agents API
         * @param {string} [alive] alive query parameter for /v2.0/agents API
         * @param {string | null} [description] description query parameter for /v2.0/agents API
         * @param {string} [availabilityZone] availability_zone query parameter for /v2.0/agents API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet: async (id?: string, agentType?: string, binary?: string, topic?: string, host?: string, adminStateUp?: string | boolean, alive?: string, description?: string | null, availabilityZone?: string, sortKey?: string, sortDir?: AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (agentType !== undefined) {
                localVarQueryParameter['agent_type'] = agentType;
            }

            if (binary !== undefined) {
                localVarQueryParameter['binary'] = binary;
            }

            if (topic !== undefined) {
                localVarQueryParameter['topic'] = topic;
            }

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (adminStateUp !== undefined) {
                for (const [key, value] of Object.entries(adminStateUp)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (alive !== undefined) {
                localVarQueryParameter['alive'] = alive;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (availabilityZone !== undefined) {
                localVarQueryParameter['availability_zone'] = availabilityZone;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdDelete', 'id', id)
            const localVarPath = `/v2.0/agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdGet', 'id', id)
            const localVarPath = `/v2.0/agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {AgentUpdateRequest} [agentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdPut: async (id: string, agentUpdateRequest?: AgentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('agentsIdPut', 'id', id)
            const localVarPath = `/v2.0/agents/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AgentsCreateRequest} [agentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsPost: async (agentsCreateRequest?: AgentsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(agentsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworkingAgentsApi - functional programming interface
 * @export
 */
export const NetworkingAgentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworkingAgentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/agents API
         * @param {string} [agentType] agent_type query parameter for /v2.0/agents API
         * @param {string} [binary] binary query parameter for /v2.0/agents API
         * @param {string} [topic] topic query parameter for /v2.0/agents API
         * @param {string} [host] host query parameter for /v2.0/agents API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/agents API
         * @param {string} [alive] alive query parameter for /v2.0/agents API
         * @param {string | null} [description] description query parameter for /v2.0/agents API
         * @param {string} [availabilityZone] availability_zone query parameter for /v2.0/agents API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsGet(id?: string, agentType?: string, binary?: string, topic?: string, host?: string, adminStateUp?: string | boolean, alive?: string, description?: string | null, availabilityZone?: string, sortKey?: string, sortDir?: AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsGet(id, agentType, binary, topic, host, adminStateUp, alive, description, availabilityZone, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkingAgentsApi.agentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkingAgentsApi.agentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkingAgentsApi.agentsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {AgentUpdateRequest} [agentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsIdPut(id: string, agentUpdateRequest?: AgentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsIdPut(id, agentUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkingAgentsApi.agentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {AgentsCreateRequest} [agentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async agentsPost(agentsCreateRequest?: AgentsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AgentsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.agentsPost(agentsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworkingAgentsApi.agentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NetworkingAgentsApi - factory interface
 * @export
 */
export const NetworkingAgentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworkingAgentsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/agents API
         * @param {string} [agentType] agent_type query parameter for /v2.0/agents API
         * @param {string} [binary] binary query parameter for /v2.0/agents API
         * @param {string} [topic] topic query parameter for /v2.0/agents API
         * @param {string} [host] host query parameter for /v2.0/agents API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/agents API
         * @param {string} [alive] alive query parameter for /v2.0/agents API
         * @param {string | null} [description] description query parameter for /v2.0/agents API
         * @param {string} [availabilityZone] availability_zone query parameter for /v2.0/agents API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsGet(id?: string, agentType?: string, binary?: string, topic?: string, host?: string, adminStateUp?: string | boolean, alive?: string, description?: string | null, availabilityZone?: string, sortKey?: string, sortDir?: AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<AgentsIndexResponse> {
            return localVarFp.agentsGet(id, agentType, binary, topic, host, adminStateUp, alive, description, availabilityZone, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.agentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdGet(id: string, options?: any): AxiosPromise<AgentShowResponse> {
            return localVarFp.agentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/agents/{id} API
         * @param {AgentUpdateRequest} [agentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsIdPut(id: string, agentUpdateRequest?: AgentUpdateRequest, options?: any): AxiosPromise<AgentUpdateResponse> {
            return localVarFp.agentsIdPut(id, agentUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AgentsCreateRequest} [agentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        agentsPost(agentsCreateRequest?: AgentsCreateRequest, options?: any): AxiosPromise<AgentsCreateResponse> {
            return localVarFp.agentsPost(agentsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworkingAgentsApi - object-oriented interface
 * @export
 * @class NetworkingAgentsApi
 * @extends {BaseAPI}
 */
export class NetworkingAgentsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/agents API
     * @param {string} [agentType] agent_type query parameter for /v2.0/agents API
     * @param {string} [binary] binary query parameter for /v2.0/agents API
     * @param {string} [topic] topic query parameter for /v2.0/agents API
     * @param {string} [host] host query parameter for /v2.0/agents API
     * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/agents API
     * @param {string} [alive] alive query parameter for /v2.0/agents API
     * @param {string | null} [description] description query parameter for /v2.0/agents API
     * @param {string} [availabilityZone] availability_zone query parameter for /v2.0/agents API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingAgentsApi
     */
    public agentsGet(id?: string, agentType?: string, binary?: string, topic?: string, host?: string, adminStateUp?: string | boolean, alive?: string, description?: string | null, availabilityZone?: string, sortKey?: string, sortDir?: AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworkingAgentsApiFp(this.configuration).agentsGet(id, agentType, binary, topic, host, adminStateUp, alive, description, availabilityZone, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingAgentsApi
     */
    public agentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return NetworkingAgentsApiFp(this.configuration).agentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingAgentsApi
     */
    public agentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return NetworkingAgentsApiFp(this.configuration).agentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/agents/{id} API
     * @param {AgentUpdateRequest} [agentUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingAgentsApi
     */
    public agentsIdPut(id: string, agentUpdateRequest?: AgentUpdateRequest, options?: RawAxiosRequestConfig) {
        return NetworkingAgentsApiFp(this.configuration).agentsIdPut(id, agentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AgentsCreateRequest} [agentsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworkingAgentsApi
     */
    public agentsPost(agentsCreateRequest?: AgentsCreateRequest, options?: RawAxiosRequestConfig) {
        return NetworkingAgentsApiFp(this.configuration).agentsPost(agentsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const AgentsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type AgentsGetSortDirEnum = typeof AgentsGetSortDirEnum[keyof typeof AgentsGetSortDirEnum];


/**
 * NetworksApi - axios parameter creator
 * @export
 */
export const NetworksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/networks API
         * @param {string} [name] name query parameter for /v2.0/networks API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/networks API
         * @param {string} [status] status query parameter for /v2.0/networks API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/networks API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/networks API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/networks API
         * @param {string | number} [mtu] mtu query parameter for /v2.0/networks API
         * @param {string} [providernetworkType] provider:network_type query parameter for /v2.0/networks API
         * @param {string} [providerphysicalNetwork] provider:physical_network query parameter for /v2.0/networks API
         * @param {string | number} [providersegmentationId] provider:segmentation_id query parameter for /v2.0/networks API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/networks API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/networks API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/networks API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/networks API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/networks API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/networks API
         * @param {string} [description] description query parameter for /v2.0/networks API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksGet: async (id?: string, name?: string, adminStateUp?: string | boolean, status?: string, tenantId?: string, shared?: string | boolean, routerexternal?: string | boolean, mtu?: string | number, providernetworkType?: string, providerphysicalNetwork?: string, providersegmentationId?: string | number, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, isDefault?: string | boolean, description?: string, sortKey?: string, sortDir?: NetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (adminStateUp !== undefined) {
                for (const [key, value] of Object.entries(adminStateUp)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (routerexternal !== undefined) {
                for (const [key, value] of Object.entries(routerexternal)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (mtu !== undefined) {
                for (const [key, value] of Object.entries(mtu)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (providernetworkType !== undefined) {
                localVarQueryParameter['provider:network_type'] = providernetworkType;
            }

            if (providerphysicalNetwork !== undefined) {
                localVarQueryParameter['provider:physical_network'] = providerphysicalNetwork;
            }

            if (providersegmentationId !== undefined) {
                for (const [key, value] of Object.entries(providersegmentationId)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (isDefault !== undefined) {
                for (const [key, value] of Object.entries(isDefault)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDelete: async (networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDelete', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdDhcpAgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsGet: async (sortKey?: string, sortDir?: NetworksNetworkIdDhcpAgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/networks/{network_id}/dhcp-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdDelete: async (networkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdDelete', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdDelete', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/dhcp-agents/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdGet: async (networkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdGet', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdGet', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/dhcp-agents/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdPut: async (networkId: string, id: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdPut', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsIdPut', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/dhcp-agents/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsPost: async (networkId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdDhcpAgentsPost', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}/dhcp-agents`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGet: async (networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdGet', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {NetworkUpdateRequest} [networkUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPut: async (networkId: string, networkUpdateRequest?: NetworkUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdPut', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networkUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsDelete: async (networkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTagsDelete', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}/tags`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsGet: async (sortKey?: string, sortDir?: NetworksNetworkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/networks/{network_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdDelete: async (networkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdDelete', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/tags/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdGet: async (networkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdGet', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/tags/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdPut: async (networkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdPut', 'networkId', networkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('networksNetworkIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/networks/{network_id}/tags/{id}`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {NetworksTagsUpdateAllRequest} [networksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsPut: async (networkId: string, networksTagsUpdateAllRequest?: NetworksTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'networkId' is not null or undefined
            assertParamExists('networksNetworkIdTagsPut', 'networkId', networkId)
            const localVarPath = `/v2.0/networks/{network_id}/tags`
                .replace(`{${"network_id"}}`, encodeURIComponent(String(networkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networksTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {NetworksCreateRequest} [networksCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksPost: async (networksCreateRequest?: NetworksCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/networks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(networksCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NetworksApi - functional programming interface
 * @export
 */
export const NetworksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NetworksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/networks API
         * @param {string} [name] name query parameter for /v2.0/networks API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/networks API
         * @param {string} [status] status query parameter for /v2.0/networks API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/networks API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/networks API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/networks API
         * @param {string | number} [mtu] mtu query parameter for /v2.0/networks API
         * @param {string} [providernetworkType] provider:network_type query parameter for /v2.0/networks API
         * @param {string} [providerphysicalNetwork] provider:physical_network query parameter for /v2.0/networks API
         * @param {string | number} [providersegmentationId] provider:segmentation_id query parameter for /v2.0/networks API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/networks API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/networks API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/networks API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/networks API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/networks API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/networks API
         * @param {string} [description] description query parameter for /v2.0/networks API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksGet(id?: string, name?: string, adminStateUp?: string | boolean, status?: string, tenantId?: string, shared?: string | boolean, routerexternal?: string | boolean, mtu?: string | number, providernetworkType?: string, providerphysicalNetwork?: string, providersegmentationId?: string | number, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, isDefault?: string | boolean, description?: string, sortKey?: string, sortDir?: NetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksGet(id, name, adminStateUp, status, tenantId, shared, routerexternal, mtu, providernetworkType, providerphysicalNetwork, providersegmentationId, revisionNumber, tags, tagsAny, notTags, notTagsAny, isDefault, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDelete(networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDelete(networkId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdDhcpAgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDhcpAgentsGet(sortKey?: string, sortDir?: NetworksNetworkIdDhcpAgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDhcpAgentsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDhcpAgentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDhcpAgentsIdDelete(networkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDhcpAgentsIdDelete(networkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDhcpAgentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDhcpAgentsIdGet(networkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDhcpAgentsIdGet(networkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDhcpAgentsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDhcpAgentsIdPut(networkId: string, id: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDhcpAgentsIdPut(networkId, id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDhcpAgentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdDhcpAgentsPost(networkId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdDhcpAgentsPost(networkId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdDhcpAgentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdGet(networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdGet(networkId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {NetworkUpdateRequest} [networkUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdPut(networkId: string, networkUpdateRequest?: NetworkUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworkUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdPut(networkId, networkUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsDelete(networkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsDelete(networkId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsGet(sortKey?: string, sortDir?: NetworksNetworkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsIdDelete(networkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsIdDelete(networkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsIdGet(networkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsIdGet(networkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsIdPut(networkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsIdPut(networkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {NetworksTagsUpdateAllRequest} [networksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksNetworkIdTagsPut(networkId: string, networksTagsUpdateAllRequest?: NetworksTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksNetworkIdTagsPut(networkId, networksTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksNetworkIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {NetworksCreateRequest} [networksCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async networksPost(networksCreateRequest?: NetworksCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NetworksCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.networksPost(networksCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['NetworksApi.networksPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * NetworksApi - factory interface
 * @export
 */
export const NetworksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NetworksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/networks API
         * @param {string} [name] name query parameter for /v2.0/networks API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/networks API
         * @param {string} [status] status query parameter for /v2.0/networks API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/networks API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/networks API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/networks API
         * @param {string | number} [mtu] mtu query parameter for /v2.0/networks API
         * @param {string} [providernetworkType] provider:network_type query parameter for /v2.0/networks API
         * @param {string} [providerphysicalNetwork] provider:physical_network query parameter for /v2.0/networks API
         * @param {string | number} [providersegmentationId] provider:segmentation_id query parameter for /v2.0/networks API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/networks API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/networks API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/networks API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/networks API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/networks API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/networks API
         * @param {string} [description] description query parameter for /v2.0/networks API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksGet(id?: string, name?: string, adminStateUp?: string | boolean, status?: string, tenantId?: string, shared?: string | boolean, routerexternal?: string | boolean, mtu?: string | number, providernetworkType?: string, providerphysicalNetwork?: string, providersegmentationId?: string | number, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, isDefault?: string | boolean, description?: string, sortKey?: string, sortDir?: NetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NetworksIndexResponse> {
            return localVarFp.networksGet(id, name, adminStateUp, status, tenantId, shared, routerexternal, mtu, providernetworkType, providerphysicalNetwork, providersegmentationId, revisionNumber, tags, tagsAny, notTags, notTagsAny, isDefault, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdDhcpAgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsGet(sortKey?: string, sortDir?: NetworksNetworkIdDhcpAgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<object> {
            return localVarFp.networksNetworkIdDhcpAgentsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdDelete(networkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdDhcpAgentsIdDelete(networkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdGet(networkId: string, id: string, options?: any): AxiosPromise<object> {
            return localVarFp.networksNetworkIdDhcpAgentsIdGet(networkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsIdPut(networkId: string, id: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.networksNetworkIdDhcpAgentsIdPut(networkId, id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdDhcpAgentsPost(networkId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.networksNetworkIdDhcpAgentsPost(networkId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdGet(networkId: string, options?: any): AxiosPromise<NetworkShowResponse> {
            return localVarFp.networksNetworkIdGet(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
         * @param {NetworkUpdateRequest} [networkUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdPut(networkId: string, networkUpdateRequest?: NetworkUpdateRequest, options?: any): AxiosPromise<NetworkUpdateResponse> {
            return localVarFp.networksNetworkIdPut(networkId, networkUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsDelete(networkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTagsDelete(networkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {NetworksNetworkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsGet(sortKey?: string, sortDir?: NetworksNetworkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<NetworksTagsIndexResponse> {
            return localVarFp.networksNetworkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdDelete(networkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTagsIdDelete(networkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdGet(networkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTagsIdGet(networkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsIdPut(networkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.networksNetworkIdTagsIdPut(networkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
         * @param {NetworksTagsUpdateAllRequest} [networksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksNetworkIdTagsPut(networkId: string, networksTagsUpdateAllRequest?: NetworksTagsUpdateAllRequest, options?: any): AxiosPromise<NetworksTagsUpdateAllResponse> {
            return localVarFp.networksNetworkIdTagsPut(networkId, networksTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {NetworksCreateRequest} [networksCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        networksPost(networksCreateRequest?: NetworksCreateRequest, options?: any): AxiosPromise<NetworksCreateResponse> {
            return localVarFp.networksPost(networksCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * NetworksApi - object-oriented interface
 * @export
 * @class NetworksApi
 * @extends {BaseAPI}
 */
export class NetworksApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/networks API
     * @param {string} [name] name query parameter for /v2.0/networks API
     * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/networks API
     * @param {string} [status] status query parameter for /v2.0/networks API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/networks API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/networks API
     * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/networks API
     * @param {string | number} [mtu] mtu query parameter for /v2.0/networks API
     * @param {string} [providernetworkType] provider:network_type query parameter for /v2.0/networks API
     * @param {string} [providerphysicalNetwork] provider:physical_network query parameter for /v2.0/networks API
     * @param {string | number} [providersegmentationId] provider:segmentation_id query parameter for /v2.0/networks API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/networks API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/networks API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/networks API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/networks API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/networks API
     * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/networks API
     * @param {string} [description] description query parameter for /v2.0/networks API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworksGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksGet(id?: string, name?: string, adminStateUp?: string | boolean, status?: string, tenantId?: string, shared?: string | boolean, routerexternal?: string | boolean, mtu?: string | number, providernetworkType?: string, providerphysicalNetwork?: string, providersegmentationId?: string | number, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, isDefault?: string | boolean, description?: string, sortKey?: string, sortDir?: NetworksGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksGet(id, name, adminStateUp, status, tenantId, shared, routerexternal, mtu, providernetworkType, providerphysicalNetwork, providersegmentationId, revisionNumber, tags, tagsAny, notTags, notTagsAny, isDefault, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDelete(networkId: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDelete(networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworksNetworkIdDhcpAgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDhcpAgentsGet(sortKey?: string, sortDir?: NetworksNetworkIdDhcpAgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDhcpAgentsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDhcpAgentsIdDelete(networkId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDhcpAgentsIdDelete(networkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDhcpAgentsIdGet(networkId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDhcpAgentsIdGet(networkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDhcpAgentsIdPut(networkId: string, id: string, body?: object, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDhcpAgentsIdPut(networkId, id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/dhcp-agents/{id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdDhcpAgentsPost(networkId: string, body?: object, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdDhcpAgentsPost(networkId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdGet(networkId: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdGet(networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id} API
     * @param {NetworkUpdateRequest} [networkUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdPut(networkId: string, networkUpdateRequest?: NetworkUpdateRequest, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdPut(networkId, networkUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsDelete(networkId: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsDelete(networkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {NetworksNetworkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsGet(sortKey?: string, sortDir?: NetworksNetworkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsIdDelete(networkId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsIdDelete(networkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsIdGet(networkId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsIdGet(networkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsIdPut(networkId: string, id: string, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsIdPut(networkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} networkId network_id parameter for /v2.0/networks/{network_id}/tags/{id} API
     * @param {NetworksTagsUpdateAllRequest} [networksTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksNetworkIdTagsPut(networkId: string, networksTagsUpdateAllRequest?: NetworksTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksNetworkIdTagsPut(networkId, networksTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {NetworksCreateRequest} [networksCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NetworksApi
     */
    public networksPost(networksCreateRequest?: NetworksCreateRequest, options?: RawAxiosRequestConfig) {
        return NetworksApiFp(this.configuration).networksPost(networksCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const NetworksGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworksGetSortDirEnum = typeof NetworksGetSortDirEnum[keyof typeof NetworksGetSortDirEnum];
/**
 * @export
 */
export const NetworksNetworkIdDhcpAgentsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworksNetworkIdDhcpAgentsGetSortDirEnum = typeof NetworksNetworkIdDhcpAgentsGetSortDirEnum[keyof typeof NetworksNetworkIdDhcpAgentsGetSortDirEnum];
/**
 * @export
 */
export const NetworksNetworkIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type NetworksNetworkIdTagsGetSortDirEnum = typeof NetworksNetworkIdTagsGetSortDirEnum[keyof typeof NetworksNetworkIdTagsGetSortDirEnum];


/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxKpps] max_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxBurstKpps] max_burst_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesGet: async (id?: string, maxKpps?: string | number, maxBurstKpps?: string | number, direction?: PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum, sortKey?: string, sortDir?: PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/policies/{policy_id}/packet_rate_limit_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (maxKpps !== undefined) {
                for (const [key, value] of Object.entries(maxKpps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (maxBurstKpps !== undefined) {
                for (const [key, value] of Object.entries(maxBurstKpps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/packet_rate_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/packet_rate_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRuleUpdateRequest} [policiesPacketRateLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdPut: async (policyId: string, id: string, policiesPacketRateLimitRuleUpdateRequest?: PoliciesPacketRateLimitRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/packet_rate_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policiesPacketRateLimitRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRulesCreateRequest} [policiesPacketRateLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesPost: async (policyId: string, policiesPacketRateLimitRulesCreateRequest?: PoliciesPacketRateLimitRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdPacketRateLimitRulesPost', 'policyId', policyId)
            const localVarPath = `/v2.0/policies/{policy_id}/packet_rate_limit_rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policiesPacketRateLimitRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsDelete: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdTagsDelete', 'policyId', policyId)
            const localVarPath = `/v2.0/policies/{policy_id}/tags`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsGet: async (sortKey?: string, sortDir?: PoliciesPolicyIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/policies/{policy_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/tags/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/tags/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdPut: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('policiesPolicyIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/policies/{policy_id}/tags/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {PoliciesTagsUpdateAllRequest} [policiesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsPut: async (policyId: string, policiesTagsUpdateAllRequest?: PoliciesTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdTagsPut', 'policyId', policyId)
            const localVarPath = `/v2.0/policies/{policy_id}/tags`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(policiesTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxKpps] max_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxBurstKpps] max_burst_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPacketRateLimitRulesGet(id?: string, maxKpps?: string | number, maxBurstKpps?: string | number, direction?: PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum, sortKey?: string, sortDir?: PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesPacketRateLimitRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPacketRateLimitRulesGet(id, maxKpps, maxBurstKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPacketRateLimitRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPacketRateLimitRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPacketRateLimitRulesIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPacketRateLimitRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPacketRateLimitRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesPacketRateLimitRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPacketRateLimitRulesIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPacketRateLimitRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRuleUpdateRequest} [policiesPacketRateLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPacketRateLimitRulesIdPut(policyId: string, id: string, policiesPacketRateLimitRuleUpdateRequest?: PoliciesPacketRateLimitRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesPacketRateLimitRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPacketRateLimitRulesIdPut(policyId, id, policiesPacketRateLimitRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPacketRateLimitRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRulesCreateRequest} [policiesPacketRateLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPacketRateLimitRulesPost(policyId: string, policiesPacketRateLimitRulesCreateRequest?: PoliciesPacketRateLimitRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesPacketRateLimitRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPacketRateLimitRulesPost(policyId, policiesPacketRateLimitRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPacketRateLimitRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsDelete(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsDelete(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsGet(sortKey?: string, sortDir?: PoliciesPolicyIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsIdPut(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsIdPut(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {PoliciesTagsUpdateAllRequest} [policiesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdTagsPut(policyId: string, policiesTagsUpdateAllRequest?: PoliciesTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PoliciesTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdTagsPut(policyId, policiesTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxKpps] max_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string | number} [maxBurstKpps] max_burst_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesGet(id?: string, maxKpps?: string | number, maxBurstKpps?: string | number, direction?: PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum, sortKey?: string, sortDir?: PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<PoliciesPacketRateLimitRulesIndexResponse> {
            return localVarFp.policiesPolicyIdPacketRateLimitRulesGet(id, maxKpps, maxBurstKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdPacketRateLimitRulesIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdGet(policyId: string, id: string, options?: any): AxiosPromise<PoliciesPacketRateLimitRuleShowResponse> {
            return localVarFp.policiesPolicyIdPacketRateLimitRulesIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRuleUpdateRequest} [policiesPacketRateLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesIdPut(policyId: string, id: string, policiesPacketRateLimitRuleUpdateRequest?: PoliciesPacketRateLimitRuleUpdateRequest, options?: any): AxiosPromise<PoliciesPacketRateLimitRuleUpdateResponse> {
            return localVarFp.policiesPolicyIdPacketRateLimitRulesIdPut(policyId, id, policiesPacketRateLimitRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
         * @param {PoliciesPacketRateLimitRulesCreateRequest} [policiesPacketRateLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPacketRateLimitRulesPost(policyId: string, policiesPacketRateLimitRulesCreateRequest?: PoliciesPacketRateLimitRulesCreateRequest, options?: any): AxiosPromise<PoliciesPacketRateLimitRulesCreateResponse> {
            return localVarFp.policiesPolicyIdPacketRateLimitRulesPost(policyId, policiesPacketRateLimitRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsDelete(policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdTagsDelete(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PoliciesPolicyIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsGet(sortKey?: string, sortDir?: PoliciesPolicyIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<PoliciesTagsIndexResponse> {
            return localVarFp.policiesPolicyIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdTagsIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdGet(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdTagsIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsIdPut(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdTagsIdPut(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
         * @param {PoliciesTagsUpdateAllRequest} [policiesTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdTagsPut(policyId: string, policiesTagsUpdateAllRequest?: PoliciesTagsUpdateAllRequest, options?: any): AxiosPromise<PoliciesTagsUpdateAllResponse> {
            return localVarFp.policiesPolicyIdTagsPut(policyId, policiesTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
     * @param {string | number} [maxKpps] max_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
     * @param {string | number} [maxBurstKpps] max_burst_kpps query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
     * @param {PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPacketRateLimitRulesGet(id?: string, maxKpps?: string | number, maxBurstKpps?: string | number, direction?: PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum, sortKey?: string, sortDir?: PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPacketRateLimitRulesGet(id, maxKpps, maxBurstKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPacketRateLimitRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPacketRateLimitRulesIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPacketRateLimitRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPacketRateLimitRulesIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {PoliciesPacketRateLimitRuleUpdateRequest} [policiesPacketRateLimitRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPacketRateLimitRulesIdPut(policyId: string, id: string, policiesPacketRateLimitRuleUpdateRequest?: PoliciesPacketRateLimitRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPacketRateLimitRulesIdPut(policyId, id, policiesPacketRateLimitRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/packet_rate_limit_rules/{id} API
     * @param {PoliciesPacketRateLimitRulesCreateRequest} [policiesPacketRateLimitRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPacketRateLimitRulesPost(policyId: string, policiesPacketRateLimitRulesCreateRequest?: PoliciesPacketRateLimitRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPacketRateLimitRulesPost(policyId, policiesPacketRateLimitRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsDelete(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsDelete(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {PoliciesPolicyIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsGet(sortKey?: string, sortDir?: PoliciesPolicyIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsIdPut(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsIdPut(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/policies/{policy_id}/tags/{id} API
     * @param {PoliciesTagsUpdateAllRequest} [policiesTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdTagsPut(policyId: string, policiesTagsUpdateAllRequest?: PoliciesTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdTagsPut(policyId, policiesTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum = typeof PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum[keyof typeof PoliciesPolicyIdPacketRateLimitRulesGetDirectionEnum];
/**
 * @export
 */
export const PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum = typeof PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum[keyof typeof PoliciesPolicyIdPacketRateLimitRulesGetSortDirEnum];
/**
 * @export
 */
export const PoliciesPolicyIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PoliciesPolicyIdTagsGetSortDirEnum = typeof PoliciesPolicyIdTagsGetSortDirEnum[keyof typeof PoliciesPolicyIdTagsGetSortDirEnum];


/**
 * PortBindingsApi - axios parameter creator
 * @export
 */
export const PortBindingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [host] host query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [vifType] vif_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {PortsPortIdBindingsGetVnicTypeEnum} [vnicType] vnic_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [status] status query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdBindingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsGet: async (host?: string, vifType?: string, vnicType?: PortsPortIdBindingsGetVnicTypeEnum, status?: string, sortKey?: string, sortDir?: PortsPortIdBindingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ports/{port_id}/bindings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (host !== undefined) {
                localVarQueryParameter['host'] = host;
            }

            if (vifType !== undefined) {
                localVarQueryParameter['vif_type'] = vifType;
            }

            if (vnicType !== undefined) {
                localVarQueryParameter['vnic_type'] = vnicType;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsActivateActivateRequest} [portsBindingsActivateActivateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdActivatePut: async (portId: string, id: string, portsBindingsActivateActivateRequest?: PortsBindingsActivateActivateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdBindingsIdActivatePut', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdBindingsIdActivatePut', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/bindings/{id}/activate`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portsBindingsActivateActivateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdDelete: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdBindingsIdDelete', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdBindingsIdDelete', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/bindings/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdGet: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdBindingsIdGet', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdBindingsIdGet', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/bindings/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingUpdateRequest} [portsBindingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdPut: async (portId: string, id: string, portsBindingUpdateRequest?: PortsBindingUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdBindingsIdPut', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdBindingsIdPut', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/bindings/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portsBindingUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsCreateRequest} [portsBindingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsPost: async (portId: string, portsBindingsCreateRequest?: PortsBindingsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdBindingsPost', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}/bindings`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portsBindingsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortBindingsApi - functional programming interface
 * @export
 */
export const PortBindingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortBindingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [host] host query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [vifType] vif_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {PortsPortIdBindingsGetVnicTypeEnum} [vnicType] vnic_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [status] status query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdBindingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsGet(host?: string, vifType?: string, vnicType?: PortsPortIdBindingsGetVnicTypeEnum, status?: string, sortKey?: string, sortDir?: PortsPortIdBindingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsBindingsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsGet(host, vifType, vnicType, status, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsActivateActivateRequest} [portsBindingsActivateActivateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsIdActivatePut(portId: string, id: string, portsBindingsActivateActivateRequest?: PortsBindingsActivateActivateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsBindingShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsIdActivatePut(portId, id, portsBindingsActivateActivateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsIdActivatePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsIdDelete(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsIdDelete(portId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsIdGet(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsBindingShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsIdGet(portId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingUpdateRequest} [portsBindingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsIdPut(portId: string, id: string, portsBindingUpdateRequest?: PortsBindingUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsBindingUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsIdPut(portId, id, portsBindingUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsCreateRequest} [portsBindingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdBindingsPost(portId: string, portsBindingsCreateRequest?: PortsBindingsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsBindingsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdBindingsPost(portId, portsBindingsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortBindingsApi.portsPortIdBindingsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PortBindingsApi - factory interface
 * @export
 */
export const PortBindingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortBindingsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [host] host query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [vifType] vif_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {PortsPortIdBindingsGetVnicTypeEnum} [vnicType] vnic_type query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [status] status query parameter for /v2.0/ports/{port_id}/bindings API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdBindingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsGet(host?: string, vifType?: string, vnicType?: PortsPortIdBindingsGetVnicTypeEnum, status?: string, sortKey?: string, sortDir?: PortsPortIdBindingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<PortsBindingsIndexResponse> {
            return localVarFp.portsPortIdBindingsGet(host, vifType, vnicType, status, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsActivateActivateRequest} [portsBindingsActivateActivateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdActivatePut(portId: string, id: string, portsBindingsActivateActivateRequest?: PortsBindingsActivateActivateRequest, options?: any): AxiosPromise<PortsBindingShowResponse> {
            return localVarFp.portsPortIdBindingsIdActivatePut(portId, id, portsBindingsActivateActivateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdDelete(portId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdBindingsIdDelete(portId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdGet(portId: string, id: string, options?: any): AxiosPromise<PortsBindingShowResponse> {
            return localVarFp.portsPortIdBindingsIdGet(portId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingUpdateRequest} [portsBindingUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsIdPut(portId: string, id: string, portsBindingUpdateRequest?: PortsBindingUpdateRequest, options?: any): AxiosPromise<PortsBindingUpdateResponse> {
            return localVarFp.portsPortIdBindingsIdPut(portId, id, portsBindingUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
         * @param {PortsBindingsCreateRequest} [portsBindingsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdBindingsPost(portId: string, portsBindingsCreateRequest?: PortsBindingsCreateRequest, options?: any): AxiosPromise<PortsBindingsCreateResponse> {
            return localVarFp.portsPortIdBindingsPost(portId, portsBindingsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortBindingsApi - object-oriented interface
 * @export
 * @class PortBindingsApi
 * @extends {BaseAPI}
 */
export class PortBindingsApi extends BaseAPI {
    /**
     * 
     * @param {string} [host] host query parameter for /v2.0/ports/{port_id}/bindings API
     * @param {string} [vifType] vif_type query parameter for /v2.0/ports/{port_id}/bindings API
     * @param {PortsPortIdBindingsGetVnicTypeEnum} [vnicType] vnic_type query parameter for /v2.0/ports/{port_id}/bindings API
     * @param {string} [status] status query parameter for /v2.0/ports/{port_id}/bindings API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {PortsPortIdBindingsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsGet(host?: string, vifType?: string, vnicType?: PortsPortIdBindingsGetVnicTypeEnum, status?: string, sortKey?: string, sortDir?: PortsPortIdBindingsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsGet(host, vifType, vnicType, status, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {PortsBindingsActivateActivateRequest} [portsBindingsActivateActivateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsIdActivatePut(portId: string, id: string, portsBindingsActivateActivateRequest?: PortsBindingsActivateActivateRequest, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsIdActivatePut(portId, id, portsBindingsActivateActivateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsIdDelete(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsIdDelete(portId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsIdGet(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsIdGet(portId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {PortsBindingUpdateRequest} [portsBindingUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsIdPut(portId: string, id: string, portsBindingUpdateRequest?: PortsBindingUpdateRequest, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsIdPut(portId, id, portsBindingUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/bindings/{id} API
     * @param {PortsBindingsCreateRequest} [portsBindingsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortBindingsApi
     */
    public portsPortIdBindingsPost(portId: string, portsBindingsCreateRequest?: PortsBindingsCreateRequest, options?: RawAxiosRequestConfig) {
        return PortBindingsApiFp(this.configuration).portsPortIdBindingsPost(portId, portsBindingsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PortsPortIdBindingsGetVnicTypeEnum = {
    Normal: 'normal',
    Direct: 'direct',
    Macvtap: 'macvtap',
    Baremetal: 'baremetal',
    DirectPhysical: 'direct-physical',
    VirtioForwarder: 'virtio-forwarder',
    SmartNic: 'smart-nic',
    Vdpa: 'vdpa',
    AcceleratorDirect: 'accelerator-direct',
    AcceleratorDirectPhysical: 'accelerator-direct-physical',
    RemoteManaged: 'remote-managed'
} as const;
export type PortsPortIdBindingsGetVnicTypeEnum = typeof PortsPortIdBindingsGetVnicTypeEnum[keyof typeof PortsPortIdBindingsGetVnicTypeEnum];
/**
 * @export
 */
export const PortsPortIdBindingsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PortsPortIdBindingsGetSortDirEnum = typeof PortsPortIdBindingsGetSortDirEnum[keyof typeof PortsPortIdBindingsGetSortDirEnum];


/**
 * PortsApi - axios parameter creator
 * @export
 */
export const PortsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/ports API
         * @param {string} [name] name query parameter for /v2.0/ports API
         * @param {string} [networkId] network_id query parameter for /v2.0/ports API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/ports API
         * @param {string} [macAddress] mac_address query parameter for /v2.0/ports API
         * @param {Array<string>} [fixedIps] fixed_ips query parameter for /v2.0/ports API
         * @param {string} [deviceId] device_id query parameter for /v2.0/ports API
         * @param {string} [deviceOwner] device_owner query parameter for /v2.0/ports API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/ports API
         * @param {string} [status] status query parameter for /v2.0/ports API
         * @param {string} [ipAllocation] ip_allocation query parameter for /v2.0/ports API
         * @param {string} [bindinghostId] binding:host_id query parameter for /v2.0/ports API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ports API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/ports API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/ports API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/ports API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/ports API
         * @param {string} [description] description query parameter for /v2.0/ports API
         * @param {Array<string>} [securityGroups] security_groups query parameter for /v2.0/ports API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsGet: async (id?: string, name?: string, networkId?: string, adminStateUp?: string | boolean, macAddress?: string, fixedIps?: Array<string>, deviceId?: string, deviceOwner?: string, tenantId?: string, status?: string, ipAllocation?: string, bindinghostId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, securityGroups?: Array<string>, sortKey?: string, sortDir?: PortsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = networkId;
            }

            if (adminStateUp !== undefined) {
                for (const [key, value] of Object.entries(adminStateUp)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (macAddress !== undefined) {
                localVarQueryParameter['mac_address'] = macAddress;
            }

            if (fixedIps) {
                localVarQueryParameter['fixed_ips'] = fixedIps.join(COLLECTION_FORMATS.csv);
            }

            if (deviceId !== undefined) {
                localVarQueryParameter['device_id'] = deviceId;
            }

            if (deviceOwner !== undefined) {
                localVarQueryParameter['device_owner'] = deviceOwner;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (ipAllocation !== undefined) {
                localVarQueryParameter['ip_allocation'] = ipAllocation;
            }

            if (bindinghostId !== undefined) {
                localVarQueryParameter['binding:host_id'] = bindinghostId;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (securityGroups) {
                localVarQueryParameter['security_groups'] = securityGroups;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdAddAllowedAddressPairsPut: async (portId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdAddAllowedAddressPairsPut', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}/add_allowed_address_pairs`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdDelete: async (portId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdDelete', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdGet: async (portId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdGet', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {PortUpdateRequest} [portUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdPut: async (portId: string, portUpdateRequest?: PortUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdPut', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsDelete: async (portId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdTagsDelete', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}/tags`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsGet: async (sortKey?: string, sortDir?: PortsPortIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ports/{port_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdDelete: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdTagsIdDelete', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/tags/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdGet: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdTagsIdGet', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/tags/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdPut: async (portId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdTagsIdPut', 'portId', portId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('portsPortIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/ports/{port_id}/tags/{id}`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {PortsTagsUpdateAllRequest} [portsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsPut: async (portId: string, portsTagsUpdateAllRequest?: PortsTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'portId' is not null or undefined
            assertParamExists('portsPortIdTagsPut', 'portId', portId)
            const localVarPath = `/v2.0/ports/{port_id}/tags`
                .replace(`{${"port_id"}}`, encodeURIComponent(String(portId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portsTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {PortsCreateRequest} [portsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPost: async (portsCreateRequest?: PortsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/ports`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(portsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PortsApi - functional programming interface
 * @export
 */
export const PortsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PortsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/ports API
         * @param {string} [name] name query parameter for /v2.0/ports API
         * @param {string} [networkId] network_id query parameter for /v2.0/ports API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/ports API
         * @param {string} [macAddress] mac_address query parameter for /v2.0/ports API
         * @param {Array<string>} [fixedIps] fixed_ips query parameter for /v2.0/ports API
         * @param {string} [deviceId] device_id query parameter for /v2.0/ports API
         * @param {string} [deviceOwner] device_owner query parameter for /v2.0/ports API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/ports API
         * @param {string} [status] status query parameter for /v2.0/ports API
         * @param {string} [ipAllocation] ip_allocation query parameter for /v2.0/ports API
         * @param {string} [bindinghostId] binding:host_id query parameter for /v2.0/ports API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ports API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/ports API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/ports API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/ports API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/ports API
         * @param {string} [description] description query parameter for /v2.0/ports API
         * @param {Array<string>} [securityGroups] security_groups query parameter for /v2.0/ports API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsGet(id?: string, name?: string, networkId?: string, adminStateUp?: string | boolean, macAddress?: string, fixedIps?: Array<string>, deviceId?: string, deviceOwner?: string, tenantId?: string, status?: string, ipAllocation?: string, bindinghostId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, securityGroups?: Array<string>, sortKey?: string, sortDir?: PortsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsGet(id, name, networkId, adminStateUp, macAddress, fixedIps, deviceId, deviceOwner, tenantId, status, ipAllocation, bindinghostId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, securityGroups, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdAddAllowedAddressPairsPut(portId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdAddAllowedAddressPairsPut(portId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdAddAllowedAddressPairsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdDelete(portId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdDelete(portId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdGet(portId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdGet(portId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {PortUpdateRequest} [portUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdPut(portId: string, portUpdateRequest?: PortUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdPut(portId, portUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsDelete(portId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsDelete(portId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsGet(sortKey?: string, sortDir?: PortsPortIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsIdDelete(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsIdDelete(portId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsIdGet(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsIdGet(portId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsIdPut(portId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsIdPut(portId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {PortsTagsUpdateAllRequest} [portsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPortIdTagsPut(portId: string, portsTagsUpdateAllRequest?: PortsTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPortIdTagsPut(portId, portsTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPortIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {PortsCreateRequest} [portsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async portsPost(portsCreateRequest?: PortsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PortsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.portsPost(portsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PortsApi.portsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PortsApi - factory interface
 * @export
 */
export const PortsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PortsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/ports API
         * @param {string} [name] name query parameter for /v2.0/ports API
         * @param {string} [networkId] network_id query parameter for /v2.0/ports API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/ports API
         * @param {string} [macAddress] mac_address query parameter for /v2.0/ports API
         * @param {Array<string>} [fixedIps] fixed_ips query parameter for /v2.0/ports API
         * @param {string} [deviceId] device_id query parameter for /v2.0/ports API
         * @param {string} [deviceOwner] device_owner query parameter for /v2.0/ports API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/ports API
         * @param {string} [status] status query parameter for /v2.0/ports API
         * @param {string} [ipAllocation] ip_allocation query parameter for /v2.0/ports API
         * @param {string} [bindinghostId] binding:host_id query parameter for /v2.0/ports API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ports API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/ports API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/ports API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/ports API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/ports API
         * @param {string} [description] description query parameter for /v2.0/ports API
         * @param {Array<string>} [securityGroups] security_groups query parameter for /v2.0/ports API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsGet(id?: string, name?: string, networkId?: string, adminStateUp?: string | boolean, macAddress?: string, fixedIps?: Array<string>, deviceId?: string, deviceOwner?: string, tenantId?: string, status?: string, ipAllocation?: string, bindinghostId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, securityGroups?: Array<string>, sortKey?: string, sortDir?: PortsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<PortsIndexResponse> {
            return localVarFp.portsGet(id, name, networkId, adminStateUp, macAddress, fixedIps, deviceId, deviceOwner, tenantId, status, ipAllocation, bindinghostId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, securityGroups, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdAddAllowedAddressPairsPut(portId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.portsPortIdAddAllowedAddressPairsPut(portId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdDelete(portId: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdDelete(portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdGet(portId: string, options?: any): AxiosPromise<PortShowResponse> {
            return localVarFp.portsPortIdGet(portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
         * @param {PortUpdateRequest} [portUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdPut(portId: string, portUpdateRequest?: PortUpdateRequest, options?: any): AxiosPromise<PortUpdateResponse> {
            return localVarFp.portsPortIdPut(portId, portUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsDelete(portId: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdTagsDelete(portId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {PortsPortIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsGet(sortKey?: string, sortDir?: PortsPortIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<PortsTagsIndexResponse> {
            return localVarFp.portsPortIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdDelete(portId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdTagsIdDelete(portId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdGet(portId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdTagsIdGet(portId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsIdPut(portId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.portsPortIdTagsIdPut(portId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
         * @param {PortsTagsUpdateAllRequest} [portsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPortIdTagsPut(portId: string, portsTagsUpdateAllRequest?: PortsTagsUpdateAllRequest, options?: any): AxiosPromise<PortsTagsUpdateAllResponse> {
            return localVarFp.portsPortIdTagsPut(portId, portsTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {PortsCreateRequest} [portsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        portsPost(portsCreateRequest?: PortsCreateRequest, options?: any): AxiosPromise<PortsCreateResponse> {
            return localVarFp.portsPost(portsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PortsApi - object-oriented interface
 * @export
 * @class PortsApi
 * @extends {BaseAPI}
 */
export class PortsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/ports API
     * @param {string} [name] name query parameter for /v2.0/ports API
     * @param {string} [networkId] network_id query parameter for /v2.0/ports API
     * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/ports API
     * @param {string} [macAddress] mac_address query parameter for /v2.0/ports API
     * @param {Array<string>} [fixedIps] fixed_ips query parameter for /v2.0/ports API
     * @param {string} [deviceId] device_id query parameter for /v2.0/ports API
     * @param {string} [deviceOwner] device_owner query parameter for /v2.0/ports API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/ports API
     * @param {string} [status] status query parameter for /v2.0/ports API
     * @param {string} [ipAllocation] ip_allocation query parameter for /v2.0/ports API
     * @param {string} [bindinghostId] binding:host_id query parameter for /v2.0/ports API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/ports API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/ports API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/ports API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/ports API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/ports API
     * @param {string} [description] description query parameter for /v2.0/ports API
     * @param {Array<string>} [securityGroups] security_groups query parameter for /v2.0/ports API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {PortsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsGet(id?: string, name?: string, networkId?: string, adminStateUp?: string | boolean, macAddress?: string, fixedIps?: Array<string>, deviceId?: string, deviceOwner?: string, tenantId?: string, status?: string, ipAllocation?: string, bindinghostId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, securityGroups?: Array<string>, sortKey?: string, sortDir?: PortsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsGet(id, name, networkId, adminStateUp, macAddress, fixedIps, deviceId, deviceOwner, tenantId, status, ipAllocation, bindinghostId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, securityGroups, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdAddAllowedAddressPairsPut(portId: string, body?: any, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdAddAllowedAddressPairsPut(portId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdDelete(portId: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdDelete(portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdGet(portId: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdGet(portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/add_allowed_address_pairs API
     * @param {PortUpdateRequest} [portUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdPut(portId: string, portUpdateRequest?: PortUpdateRequest, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdPut(portId, portUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsDelete(portId: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsDelete(portId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {PortsPortIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsGet(sortKey?: string, sortDir?: PortsPortIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsIdDelete(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsIdDelete(portId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsIdGet(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsIdGet(portId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsIdPut(portId: string, id: string, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsIdPut(portId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} portId port_id parameter for /v2.0/ports/{port_id}/tags/{id} API
     * @param {PortsTagsUpdateAllRequest} [portsTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPortIdTagsPut(portId: string, portsTagsUpdateAllRequest?: PortsTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPortIdTagsPut(portId, portsTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {PortsCreateRequest} [portsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PortsApi
     */
    public portsPost(portsCreateRequest?: PortsCreateRequest, options?: RawAxiosRequestConfig) {
        return PortsApiFp(this.configuration).portsPost(portsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const PortsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PortsGetSortDirEnum = typeof PortsGetSortDirEnum[keyof typeof PortsGetSortDirEnum];
/**
 * @export
 */
export const PortsPortIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type PortsPortIdTagsGetSortDirEnum = typeof PortsPortIdTagsGetSortDirEnum[keyof typeof PortsPortIdTagsGetSortDirEnum];


/**
 * QosApi - axios parameter creator
 * @export
 */
export const QosApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {QosAliasBandwidthLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesGet: async (id?: string, maxKbps?: string | number, direction?: QosAliasBandwidthLimitRulesGetDirectionEnum, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosAliasBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-bandwidth-limit-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (maxKbps !== undefined) {
                for (const [key, value] of Object.entries(maxKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (maxBurstKbps !== undefined) {
                for (const [key, value] of Object.entries(maxBurstKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasBandwidthLimitRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/alias-bandwidth-limit-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasBandwidthLimitRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/alias-bandwidth-limit-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {QosAliasBandwidthLimitRuleUpdateRequest} [qosAliasBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdPut: async (id: string, qosAliasBandwidthLimitRuleUpdateRequest?: QosAliasBandwidthLimitRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasBandwidthLimitRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/alias-bandwidth-limit-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasBandwidthLimitRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosAliasBandwidthLimitRulesCreateRequest} [qosAliasBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesPost: async (qosAliasBandwidthLimitRulesCreateRequest?: QosAliasBandwidthLimitRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-bandwidth-limit-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasBandwidthLimitRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {QosAliasDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesGet: async (id?: string, dscpMark?: QosAliasDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosAliasDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-dscp-marking-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dscpMark !== undefined) {
                localVarQueryParameter['dscp_mark'] = dscpMark;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasDscpMarkingRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/alias-dscp-marking-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasDscpMarkingRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/alias-dscp-marking-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {QosAliasDscpMarkingRuleUpdateRequest} [qosAliasDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdPut: async (id: string, qosAliasDscpMarkingRuleUpdateRequest?: QosAliasDscpMarkingRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasDscpMarkingRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/alias-dscp-marking-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasDscpMarkingRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosAliasDscpMarkingRulesCreateRequest} [qosAliasDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesPost: async (qosAliasDscpMarkingRulesCreateRequest?: QosAliasDscpMarkingRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-dscp-marking-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasDscpMarkingRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {QosAliasMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesGet: async (id?: string, minKbps?: string | number, direction?: QosAliasMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-minimum-bandwidth-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (minKbps !== undefined) {
                for (const [key, value] of Object.entries(minKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumBandwidthRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-bandwidth-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumBandwidthRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-bandwidth-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {QosAliasMinimumBandwidthRuleUpdateRequest} [qosAliasMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdPut: async (id: string, qosAliasMinimumBandwidthRuleUpdateRequest?: QosAliasMinimumBandwidthRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumBandwidthRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-bandwidth-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasMinimumBandwidthRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosAliasMinimumBandwidthRulesCreateRequest} [qosAliasMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesPost: async (qosAliasMinimumBandwidthRulesCreateRequest?: QosAliasMinimumBandwidthRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-minimum-bandwidth-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasMinimumBandwidthRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {QosAliasMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesGet: async (id?: string, minKpps?: string | number, direction?: QosAliasMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-minimum-packet-rate-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (minKpps !== undefined) {
                for (const [key, value] of Object.entries(minKpps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumPacketRateRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-packet-rate-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumPacketRateRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-packet-rate-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {QosAliasMinimumPacketRateRuleUpdateRequest} [qosAliasMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdPut: async (id: string, qosAliasMinimumPacketRateRuleUpdateRequest?: QosAliasMinimumPacketRateRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosAliasMinimumPacketRateRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/alias-minimum-packet-rate-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasMinimumPacketRateRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosAliasMinimumPacketRateRulesCreateRequest} [qosAliasMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesPost: async (qosAliasMinimumPacketRateRulesCreateRequest?: QosAliasMinimumPacketRateRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/alias-minimum-packet-rate-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosAliasMinimumPacketRateRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies API
         * @param {string} [name] name query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/qos/policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/qos/policies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/qos/policies API
         * @param {string} [description] description query parameter for /v2.0/qos/policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesGet: async (id?: string, name?: string, shared?: string | boolean, tenantId?: string, isDefault?: string | boolean, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: QosPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (isDefault !== undefined) {
                for (const [key, value] of Object.entries(isDefault)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {QosPolicyUpdateRequest} [qosPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdPut: async (id: string, qosPolicyUpdateRequest?: QosPolicyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPolicyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesGet: async (id?: string, maxKbps?: string | number, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies/{policy_id}/bandwidth_limit_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (maxKbps !== undefined) {
                for (const [key, value] of Object.entries(maxKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (maxBurstKbps !== undefined) {
                for (const [key, value] of Object.entries(maxBurstKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRuleUpdateRequest} [qosPoliciesBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdPut: async (policyId: string, id: string, qosPoliciesBandwidthLimitRuleUpdateRequest?: QosPoliciesBandwidthLimitRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesBandwidthLimitRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRulesCreateRequest} [qosPoliciesBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesPost: async (policyId: string, qosPoliciesBandwidthLimitRulesCreateRequest?: QosPoliciesBandwidthLimitRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdBandwidthLimitRulesPost', 'policyId', policyId)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/bandwidth_limit_rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesBandwidthLimitRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesGet: async (id?: string, dscpMark?: QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies/{policy_id}/dscp_marking_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (dscpMark !== undefined) {
                localVarQueryParameter['dscp_mark'] = dscpMark;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRuleUpdateRequest} [qosPoliciesDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdPut: async (policyId: string, id: string, qosPoliciesDscpMarkingRuleUpdateRequest?: QosPoliciesDscpMarkingRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesDscpMarkingRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRulesCreateRequest} [qosPoliciesDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesPost: async (policyId: string, qosPoliciesDscpMarkingRulesCreateRequest?: QosPoliciesDscpMarkingRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdDscpMarkingRulesPost', 'policyId', policyId)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/dscp_marking_rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesDscpMarkingRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesGet: async (id?: string, minKbps?: string | number, direction?: QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (minKbps !== undefined) {
                for (const [key, value] of Object.entries(minKbps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRuleUpdateRequest} [qosPoliciesMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdPut: async (policyId: string, id: string, qosPoliciesMinimumBandwidthRuleUpdateRequest?: QosPoliciesMinimumBandwidthRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesMinimumBandwidthRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRulesCreateRequest} [qosPoliciesMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesPost: async (policyId: string, qosPoliciesMinimumBandwidthRulesCreateRequest?: QosPoliciesMinimumBandwidthRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumBandwidthRulesPost', 'policyId', policyId)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesMinimumBandwidthRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesGet: async (id?: string, minKpps?: string | number, direction?: QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (minKpps !== undefined) {
                for (const [key, value] of Object.entries(minKpps)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdGet: async (policyId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdGet', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRuleUpdateRequest} [qosPoliciesMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdPut: async (policyId: string, id: string, qosPoliciesMinimumPacketRateRuleUpdateRequest?: QosPoliciesMinimumPacketRateRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdPut', 'policyId', policyId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesMinimumPacketRateRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRulesCreateRequest} [qosPoliciesMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesPost: async (policyId: string, qosPoliciesMinimumPacketRateRulesCreateRequest?: QosPoliciesMinimumPacketRateRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('qosPoliciesPolicyIdMinimumPacketRateRulesPost', 'policyId', policyId)
            const localVarPath = `/v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesMinimumPacketRateRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosPoliciesCreateRequest} [qosPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPost: async (qosPoliciesCreateRequest?: QosPoliciesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosPoliciesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string | boolean | null} [allRules] all_rules query parameter for /v2.0/qos/rule-types API
         * @param {string | boolean | null} [allSupported] all_supported query parameter for /v2.0/qos/rule-types API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosRuleTypesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesGet: async (allRules?: string | boolean | null, allSupported?: string | boolean | null, sortKey?: string, sortDir?: QosRuleTypesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/rule-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (allRules !== undefined) {
                for (const [key, value] of Object.entries(allRules)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (allSupported !== undefined) {
                for (const [key, value] of Object.entries(allSupported)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosRuleTypesIdDelete', 'id', id)
            const localVarPath = `/v2.0/qos/rule-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosRuleTypesIdGet', 'id', id)
            const localVarPath = `/v2.0/qos/rule-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {QosRuleTypeUpdateRequest} [qosRuleTypeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdPut: async (id: string, qosRuleTypeUpdateRequest?: QosRuleTypeUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('qosRuleTypesIdPut', 'id', id)
            const localVarPath = `/v2.0/qos/rule-types/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosRuleTypeUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {QosRuleTypesCreateRequest} [qosRuleTypesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesPost: async (qosRuleTypesCreateRequest?: QosRuleTypesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/qos/rule-types`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(qosRuleTypesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QosApi - functional programming interface
 * @export
 */
export const QosApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QosApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {QosAliasBandwidthLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, direction?: QosAliasBandwidthLimitRulesGetDirectionEnum, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosAliasBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasBandwidthLimitRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasBandwidthLimitRulesGet(id, maxKbps, direction, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasBandwidthLimitRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasBandwidthLimitRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasBandwidthLimitRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasBandwidthLimitRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasBandwidthLimitRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasBandwidthLimitRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasBandwidthLimitRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasBandwidthLimitRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {QosAliasBandwidthLimitRuleUpdateRequest} [qosAliasBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasBandwidthLimitRulesIdPut(id: string, qosAliasBandwidthLimitRuleUpdateRequest?: QosAliasBandwidthLimitRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasBandwidthLimitRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasBandwidthLimitRulesIdPut(id, qosAliasBandwidthLimitRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasBandwidthLimitRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosAliasBandwidthLimitRulesCreateRequest} [qosAliasBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest?: QosAliasBandwidthLimitRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasBandwidthLimitRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasBandwidthLimitRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {QosAliasDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasDscpMarkingRulesGet(id?: string, dscpMark?: QosAliasDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosAliasDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasDscpMarkingRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasDscpMarkingRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasDscpMarkingRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasDscpMarkingRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasDscpMarkingRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasDscpMarkingRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasDscpMarkingRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasDscpMarkingRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasDscpMarkingRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {QosAliasDscpMarkingRuleUpdateRequest} [qosAliasDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasDscpMarkingRulesIdPut(id: string, qosAliasDscpMarkingRuleUpdateRequest?: QosAliasDscpMarkingRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasDscpMarkingRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasDscpMarkingRulesIdPut(id, qosAliasDscpMarkingRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasDscpMarkingRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosAliasDscpMarkingRulesCreateRequest} [qosAliasDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest?: QosAliasDscpMarkingRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasDscpMarkingRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasDscpMarkingRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {QosAliasMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosAliasMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumBandwidthRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumBandwidthRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumBandwidthRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumBandwidthRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumBandwidthRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumBandwidthRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumBandwidthRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumBandwidthRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumBandwidthRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {QosAliasMinimumBandwidthRuleUpdateRequest} [qosAliasMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumBandwidthRulesIdPut(id: string, qosAliasMinimumBandwidthRuleUpdateRequest?: QosAliasMinimumBandwidthRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumBandwidthRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumBandwidthRulesIdPut(id, qosAliasMinimumBandwidthRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumBandwidthRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosAliasMinimumBandwidthRulesCreateRequest} [qosAliasMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest?: QosAliasMinimumBandwidthRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumBandwidthRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumBandwidthRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {QosAliasMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosAliasMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumPacketRateRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumPacketRateRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumPacketRateRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumPacketRateRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumPacketRateRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumPacketRateRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumPacketRateRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumPacketRateRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumPacketRateRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {QosAliasMinimumPacketRateRuleUpdateRequest} [qosAliasMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumPacketRateRulesIdPut(id: string, qosAliasMinimumPacketRateRuleUpdateRequest?: QosAliasMinimumPacketRateRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumPacketRateRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumPacketRateRulesIdPut(id, qosAliasMinimumPacketRateRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumPacketRateRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosAliasMinimumPacketRateRulesCreateRequest} [qosAliasMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest?: QosAliasMinimumPacketRateRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosAliasMinimumPacketRateRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosAliasMinimumPacketRateRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies API
         * @param {string} [name] name query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/qos/policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/qos/policies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/qos/policies API
         * @param {string} [description] description query parameter for /v2.0/qos/policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesGet(id?: string, name?: string, shared?: string | boolean, tenantId?: string, isDefault?: string | boolean, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: QosPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesGet(id, name, shared, tenantId, isDefault, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPolicyShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {QosPolicyUpdateRequest} [qosPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesIdPut(id: string, qosPolicyUpdateRequest?: QosPolicyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPolicyUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesIdPut(id, qosPolicyUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesBandwidthLimitRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdBandwidthLimitRulesGet(id, maxKbps, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdBandwidthLimitRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdBandwidthLimitRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesBandwidthLimitRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdBandwidthLimitRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRuleUpdateRequest} [qosPoliciesBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId: string, id: string, qosPoliciesBandwidthLimitRuleUpdateRequest?: QosPoliciesBandwidthLimitRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesBandwidthLimitRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId, id, qosPoliciesBandwidthLimitRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdBandwidthLimitRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRulesCreateRequest} [qosPoliciesBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId: string, qosPoliciesBandwidthLimitRulesCreateRequest?: QosPoliciesBandwidthLimitRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesBandwidthLimitRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId, qosPoliciesBandwidthLimitRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdBandwidthLimitRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdDscpMarkingRulesGet(id?: string, dscpMark?: QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesDscpMarkingRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdDscpMarkingRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdDscpMarkingRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesDscpMarkingRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdDscpMarkingRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRuleUpdateRequest} [qosPoliciesDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId: string, id: string, qosPoliciesDscpMarkingRuleUpdateRequest?: QosPoliciesDscpMarkingRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesDscpMarkingRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId, id, qosPoliciesDscpMarkingRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdDscpMarkingRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRulesCreateRequest} [qosPoliciesDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdDscpMarkingRulesPost(policyId: string, qosPoliciesDscpMarkingRulesCreateRequest?: QosPoliciesDscpMarkingRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesDscpMarkingRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdDscpMarkingRulesPost(policyId, qosPoliciesDscpMarkingRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdDscpMarkingRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumBandwidthRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumBandwidthRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumBandwidthRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumBandwidthRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRuleUpdateRequest} [qosPoliciesMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId: string, id: string, qosPoliciesMinimumBandwidthRuleUpdateRequest?: QosPoliciesMinimumBandwidthRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumBandwidthRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId, id, qosPoliciesMinimumBandwidthRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumBandwidthRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRulesCreateRequest} [qosPoliciesMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId: string, qosPoliciesMinimumBandwidthRulesCreateRequest?: QosPoliciesMinimumBandwidthRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumBandwidthRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId, qosPoliciesMinimumBandwidthRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumBandwidthRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumPacketRateRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumPacketRateRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumPacketRateRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumPacketRateRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRuleUpdateRequest} [qosPoliciesMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId: string, id: string, qosPoliciesMinimumPacketRateRuleUpdateRequest?: QosPoliciesMinimumPacketRateRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumPacketRateRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId, id, qosPoliciesMinimumPacketRateRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumPacketRateRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRulesCreateRequest} [qosPoliciesMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId: string, qosPoliciesMinimumPacketRateRulesCreateRequest?: QosPoliciesMinimumPacketRateRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesMinimumPacketRateRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId, qosPoliciesMinimumPacketRateRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPolicyIdMinimumPacketRateRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosPoliciesCreateRequest} [qosPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosPoliciesPost(qosPoliciesCreateRequest?: QosPoliciesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosPoliciesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosPoliciesPost(qosPoliciesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosPoliciesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string | boolean | null} [allRules] all_rules query parameter for /v2.0/qos/rule-types API
         * @param {string | boolean | null} [allSupported] all_supported query parameter for /v2.0/qos/rule-types API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosRuleTypesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosRuleTypesGet(allRules?: string | boolean | null, allSupported?: string | boolean | null, sortKey?: string, sortDir?: QosRuleTypesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosRuleTypesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosRuleTypesGet(allRules, allSupported, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosRuleTypesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosRuleTypesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosRuleTypesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosRuleTypesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosRuleTypesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosRuleTypeShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosRuleTypesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosRuleTypesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {QosRuleTypeUpdateRequest} [qosRuleTypeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosRuleTypesIdPut(id: string, qosRuleTypeUpdateRequest?: QosRuleTypeUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosRuleTypeUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosRuleTypesIdPut(id, qosRuleTypeUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosRuleTypesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {QosRuleTypesCreateRequest} [qosRuleTypesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async qosRuleTypesPost(qosRuleTypesCreateRequest?: QosRuleTypesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QosRuleTypesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.qosRuleTypesPost(qosRuleTypesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QosApi.qosRuleTypesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * QosApi - factory interface
 * @export
 */
export const QosApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QosApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {QosAliasBandwidthLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, direction?: QosAliasBandwidthLimitRulesGetDirectionEnum, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosAliasBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosAliasBandwidthLimitRulesIndexResponse> {
            return localVarFp.qosAliasBandwidthLimitRulesGet(id, maxKbps, direction, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosAliasBandwidthLimitRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdGet(id: string, options?: any): AxiosPromise<QosAliasBandwidthLimitRuleShowResponse> {
            return localVarFp.qosAliasBandwidthLimitRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
         * @param {QosAliasBandwidthLimitRuleUpdateRequest} [qosAliasBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesIdPut(id: string, qosAliasBandwidthLimitRuleUpdateRequest?: QosAliasBandwidthLimitRuleUpdateRequest, options?: any): AxiosPromise<QosAliasBandwidthLimitRuleUpdateResponse> {
            return localVarFp.qosAliasBandwidthLimitRulesIdPut(id, qosAliasBandwidthLimitRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosAliasBandwidthLimitRulesCreateRequest} [qosAliasBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest?: QosAliasBandwidthLimitRulesCreateRequest, options?: any): AxiosPromise<QosAliasBandwidthLimitRulesCreateResponse> {
            return localVarFp.qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {QosAliasDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/alias-dscp-marking-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesGet(id?: string, dscpMark?: QosAliasDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosAliasDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosAliasDscpMarkingRulesIndexResponse> {
            return localVarFp.qosAliasDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosAliasDscpMarkingRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdGet(id: string, options?: any): AxiosPromise<QosAliasDscpMarkingRuleShowResponse> {
            return localVarFp.qosAliasDscpMarkingRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
         * @param {QosAliasDscpMarkingRuleUpdateRequest} [qosAliasDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesIdPut(id: string, qosAliasDscpMarkingRuleUpdateRequest?: QosAliasDscpMarkingRuleUpdateRequest, options?: any): AxiosPromise<QosAliasDscpMarkingRuleUpdateResponse> {
            return localVarFp.qosAliasDscpMarkingRulesIdPut(id, qosAliasDscpMarkingRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosAliasDscpMarkingRulesCreateRequest} [qosAliasDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest?: QosAliasDscpMarkingRulesCreateRequest, options?: any): AxiosPromise<QosAliasDscpMarkingRulesCreateResponse> {
            return localVarFp.qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {QosAliasMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosAliasMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosAliasMinimumBandwidthRulesIndexResponse> {
            return localVarFp.qosAliasMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosAliasMinimumBandwidthRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdGet(id: string, options?: any): AxiosPromise<QosAliasMinimumBandwidthRuleShowResponse> {
            return localVarFp.qosAliasMinimumBandwidthRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
         * @param {QosAliasMinimumBandwidthRuleUpdateRequest} [qosAliasMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesIdPut(id: string, qosAliasMinimumBandwidthRuleUpdateRequest?: QosAliasMinimumBandwidthRuleUpdateRequest, options?: any): AxiosPromise<QosAliasMinimumBandwidthRuleUpdateResponse> {
            return localVarFp.qosAliasMinimumBandwidthRulesIdPut(id, qosAliasMinimumBandwidthRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosAliasMinimumBandwidthRulesCreateRequest} [qosAliasMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest?: QosAliasMinimumBandwidthRulesCreateRequest, options?: any): AxiosPromise<QosAliasMinimumBandwidthRulesCreateResponse> {
            return localVarFp.qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {QosAliasMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosAliasMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosAliasMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosAliasMinimumPacketRateRulesIndexResponse> {
            return localVarFp.qosAliasMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosAliasMinimumPacketRateRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdGet(id: string, options?: any): AxiosPromise<QosAliasMinimumPacketRateRuleShowResponse> {
            return localVarFp.qosAliasMinimumPacketRateRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
         * @param {QosAliasMinimumPacketRateRuleUpdateRequest} [qosAliasMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesIdPut(id: string, qosAliasMinimumPacketRateRuleUpdateRequest?: QosAliasMinimumPacketRateRuleUpdateRequest, options?: any): AxiosPromise<QosAliasMinimumPacketRateRuleUpdateResponse> {
            return localVarFp.qosAliasMinimumPacketRateRulesIdPut(id, qosAliasMinimumPacketRateRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosAliasMinimumPacketRateRulesCreateRequest} [qosAliasMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest?: QosAliasMinimumPacketRateRulesCreateRequest, options?: any): AxiosPromise<QosAliasMinimumPacketRateRulesCreateResponse> {
            return localVarFp.qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies API
         * @param {string} [name] name query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/qos/policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/qos/policies API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/qos/policies API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/qos/policies API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/qos/policies API
         * @param {string} [description] description query parameter for /v2.0/qos/policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesGet(id?: string, name?: string, shared?: string | boolean, tenantId?: string, isDefault?: string | boolean, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: QosPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosPoliciesIndexResponse> {
            return localVarFp.qosPoliciesGet(id, name, shared, tenantId, isDefault, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosPoliciesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdGet(id: string, options?: any): AxiosPromise<QosPolicyShowResponse> {
            return localVarFp.qosPoliciesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/policies/{id} API
         * @param {QosPolicyUpdateRequest} [qosPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesIdPut(id: string, qosPolicyUpdateRequest?: QosPolicyUpdateRequest, options?: any): AxiosPromise<QosPolicyUpdateResponse> {
            return localVarFp.qosPoliciesIdPut(id, qosPolicyUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosPoliciesBandwidthLimitRulesIndexResponse> {
            return localVarFp.qosPoliciesPolicyIdBandwidthLimitRulesGet(id, maxKbps, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId: string, id: string, options?: any): AxiosPromise<QosPoliciesBandwidthLimitRuleShowResponse> {
            return localVarFp.qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRuleUpdateRequest} [qosPoliciesBandwidthLimitRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId: string, id: string, qosPoliciesBandwidthLimitRuleUpdateRequest?: QosPoliciesBandwidthLimitRuleUpdateRequest, options?: any): AxiosPromise<QosPoliciesBandwidthLimitRuleUpdateResponse> {
            return localVarFp.qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId, id, qosPoliciesBandwidthLimitRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
         * @param {QosPoliciesBandwidthLimitRulesCreateRequest} [qosPoliciesBandwidthLimitRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId: string, qosPoliciesBandwidthLimitRulesCreateRequest?: QosPoliciesBandwidthLimitRulesCreateRequest, options?: any): AxiosPromise<QosPoliciesBandwidthLimitRulesCreateResponse> {
            return localVarFp.qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId, qosPoliciesBandwidthLimitRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesGet(id?: string, dscpMark?: QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosPoliciesDscpMarkingRulesIndexResponse> {
            return localVarFp.qosPoliciesPolicyIdDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId: string, id: string, options?: any): AxiosPromise<QosPoliciesDscpMarkingRuleShowResponse> {
            return localVarFp.qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRuleUpdateRequest} [qosPoliciesDscpMarkingRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId: string, id: string, qosPoliciesDscpMarkingRuleUpdateRequest?: QosPoliciesDscpMarkingRuleUpdateRequest, options?: any): AxiosPromise<QosPoliciesDscpMarkingRuleUpdateResponse> {
            return localVarFp.qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId, id, qosPoliciesDscpMarkingRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
         * @param {QosPoliciesDscpMarkingRulesCreateRequest} [qosPoliciesDscpMarkingRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdDscpMarkingRulesPost(policyId: string, qosPoliciesDscpMarkingRulesCreateRequest?: QosPoliciesDscpMarkingRulesCreateRequest, options?: any): AxiosPromise<QosPoliciesDscpMarkingRulesCreateResponse> {
            return localVarFp.qosPoliciesPolicyIdDscpMarkingRulesPost(policyId, qosPoliciesDscpMarkingRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosPoliciesMinimumBandwidthRulesIndexResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId: string, id: string, options?: any): AxiosPromise<QosPoliciesMinimumBandwidthRuleShowResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRuleUpdateRequest} [qosPoliciesMinimumBandwidthRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId: string, id: string, qosPoliciesMinimumBandwidthRuleUpdateRequest?: QosPoliciesMinimumBandwidthRuleUpdateRequest, options?: any): AxiosPromise<QosPoliciesMinimumBandwidthRuleUpdateResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId, id, qosPoliciesMinimumBandwidthRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
         * @param {QosPoliciesMinimumBandwidthRulesCreateRequest} [qosPoliciesMinimumBandwidthRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId: string, qosPoliciesMinimumBandwidthRulesCreateRequest?: QosPoliciesMinimumBandwidthRulesCreateRequest, options?: any): AxiosPromise<QosPoliciesMinimumBandwidthRulesCreateResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId, qosPoliciesMinimumBandwidthRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosPoliciesMinimumPacketRateRulesIndexResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId: string, id: string, options?: any): AxiosPromise<QosPoliciesMinimumPacketRateRuleShowResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRuleUpdateRequest} [qosPoliciesMinimumPacketRateRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId: string, id: string, qosPoliciesMinimumPacketRateRuleUpdateRequest?: QosPoliciesMinimumPacketRateRuleUpdateRequest, options?: any): AxiosPromise<QosPoliciesMinimumPacketRateRuleUpdateResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId, id, qosPoliciesMinimumPacketRateRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
         * @param {QosPoliciesMinimumPacketRateRulesCreateRequest} [qosPoliciesMinimumPacketRateRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId: string, qosPoliciesMinimumPacketRateRulesCreateRequest?: QosPoliciesMinimumPacketRateRulesCreateRequest, options?: any): AxiosPromise<QosPoliciesMinimumPacketRateRulesCreateResponse> {
            return localVarFp.qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId, qosPoliciesMinimumPacketRateRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosPoliciesCreateRequest} [qosPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosPoliciesPost(qosPoliciesCreateRequest?: QosPoliciesCreateRequest, options?: any): AxiosPromise<QosPoliciesCreateResponse> {
            return localVarFp.qosPoliciesPost(qosPoliciesCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string | boolean | null} [allRules] all_rules query parameter for /v2.0/qos/rule-types API
         * @param {string | boolean | null} [allSupported] all_supported query parameter for /v2.0/qos/rule-types API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QosRuleTypesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesGet(allRules?: string | boolean | null, allSupported?: string | boolean | null, sortKey?: string, sortDir?: QosRuleTypesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QosRuleTypesIndexResponse> {
            return localVarFp.qosRuleTypesGet(allRules, allSupported, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.qosRuleTypesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdGet(id: string, options?: any): AxiosPromise<QosRuleTypeShowResponse> {
            return localVarFp.qosRuleTypesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
         * @param {QosRuleTypeUpdateRequest} [qosRuleTypeUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesIdPut(id: string, qosRuleTypeUpdateRequest?: QosRuleTypeUpdateRequest, options?: any): AxiosPromise<QosRuleTypeUpdateResponse> {
            return localVarFp.qosRuleTypesIdPut(id, qosRuleTypeUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {QosRuleTypesCreateRequest} [qosRuleTypesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        qosRuleTypesPost(qosRuleTypesCreateRequest?: QosRuleTypesCreateRequest, options?: any): AxiosPromise<QosRuleTypesCreateResponse> {
            return localVarFp.qosRuleTypesPost(qosRuleTypesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QosApi - object-oriented interface
 * @export
 * @class QosApi
 * @extends {BaseAPI}
 */
export class QosApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
     * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
     * @param {QosAliasBandwidthLimitRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
     * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/alias-bandwidth-limit-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosAliasBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, direction?: QosAliasBandwidthLimitRulesGetDirectionEnum, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosAliasBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasBandwidthLimitRulesGet(id, maxKbps, direction, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasBandwidthLimitRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasBandwidthLimitRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasBandwidthLimitRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasBandwidthLimitRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-bandwidth-limit-rules/{id} API
     * @param {QosAliasBandwidthLimitRuleUpdateRequest} [qosAliasBandwidthLimitRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasBandwidthLimitRulesIdPut(id: string, qosAliasBandwidthLimitRuleUpdateRequest?: QosAliasBandwidthLimitRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasBandwidthLimitRulesIdPut(id, qosAliasBandwidthLimitRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosAliasBandwidthLimitRulesCreateRequest} [qosAliasBandwidthLimitRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest?: QosAliasBandwidthLimitRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasBandwidthLimitRulesPost(qosAliasBandwidthLimitRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/alias-dscp-marking-rules API
     * @param {QosAliasDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/alias-dscp-marking-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosAliasDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasDscpMarkingRulesGet(id?: string, dscpMark?: QosAliasDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosAliasDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasDscpMarkingRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasDscpMarkingRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasDscpMarkingRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasDscpMarkingRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-dscp-marking-rules/{id} API
     * @param {QosAliasDscpMarkingRuleUpdateRequest} [qosAliasDscpMarkingRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasDscpMarkingRulesIdPut(id: string, qosAliasDscpMarkingRuleUpdateRequest?: QosAliasDscpMarkingRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasDscpMarkingRulesIdPut(id, qosAliasDscpMarkingRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosAliasDscpMarkingRulesCreateRequest} [qosAliasDscpMarkingRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest?: QosAliasDscpMarkingRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasDscpMarkingRulesPost(qosAliasDscpMarkingRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
     * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
     * @param {QosAliasMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-bandwidth-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosAliasMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosAliasMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumBandwidthRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumBandwidthRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumBandwidthRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumBandwidthRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-bandwidth-rules/{id} API
     * @param {QosAliasMinimumBandwidthRuleUpdateRequest} [qosAliasMinimumBandwidthRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumBandwidthRulesIdPut(id: string, qosAliasMinimumBandwidthRuleUpdateRequest?: QosAliasMinimumBandwidthRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumBandwidthRulesIdPut(id, qosAliasMinimumBandwidthRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosAliasMinimumBandwidthRulesCreateRequest} [qosAliasMinimumBandwidthRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest?: QosAliasMinimumBandwidthRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumBandwidthRulesPost(qosAliasMinimumBandwidthRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
     * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
     * @param {QosAliasMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/alias-minimum-packet-rate-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosAliasMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosAliasMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosAliasMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumPacketRateRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumPacketRateRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumPacketRateRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumPacketRateRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/alias-minimum-packet-rate-rules/{id} API
     * @param {QosAliasMinimumPacketRateRuleUpdateRequest} [qosAliasMinimumPacketRateRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumPacketRateRulesIdPut(id: string, qosAliasMinimumPacketRateRuleUpdateRequest?: QosAliasMinimumPacketRateRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumPacketRateRulesIdPut(id, qosAliasMinimumPacketRateRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosAliasMinimumPacketRateRulesCreateRequest} [qosAliasMinimumPacketRateRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest?: QosAliasMinimumPacketRateRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosAliasMinimumPacketRateRulesPost(qosAliasMinimumPacketRateRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/policies API
     * @param {string} [name] name query parameter for /v2.0/qos/policies API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/qos/policies API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/qos/policies API
     * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/qos/policies API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/qos/policies API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/qos/policies API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/qos/policies API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/qos/policies API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/qos/policies API
     * @param {string} [description] description query parameter for /v2.0/qos/policies API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesGet(id?: string, name?: string, shared?: string | boolean, tenantId?: string, isDefault?: string | boolean, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: QosPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesGet(id, name, shared, tenantId, isDefault, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/policies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/policies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/policies/{id} API
     * @param {QosPolicyUpdateRequest} [qosPolicyUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesIdPut(id: string, qosPolicyUpdateRequest?: QosPolicyUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesIdPut(id, qosPolicyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
     * @param {string | number} [maxKbps] max_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
     * @param {string | number} [maxBurstKbps] max_burst_kbps query parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdBandwidthLimitRulesGet(id?: string, maxKbps?: string | number, maxBurstKbps?: string | number, sortKey?: string, sortDir?: QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdBandwidthLimitRulesGet(id, maxKbps, maxBurstKbps, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdBandwidthLimitRulesIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdBandwidthLimitRulesIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {QosPoliciesBandwidthLimitRuleUpdateRequest} [qosPoliciesBandwidthLimitRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId: string, id: string, qosPoliciesBandwidthLimitRuleUpdateRequest?: QosPoliciesBandwidthLimitRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdBandwidthLimitRulesIdPut(policyId, id, qosPoliciesBandwidthLimitRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/bandwidth_limit_rules/{id} API
     * @param {QosPoliciesBandwidthLimitRulesCreateRequest} [qosPoliciesBandwidthLimitRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId: string, qosPoliciesBandwidthLimitRulesCreateRequest?: QosPoliciesBandwidthLimitRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdBandwidthLimitRulesPost(policyId, qosPoliciesBandwidthLimitRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
     * @param {QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum} [dscpMark] dscp_mark query parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdDscpMarkingRulesGet(id?: string, dscpMark?: QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdDscpMarkingRulesGet(id, dscpMark, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdDscpMarkingRulesIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdDscpMarkingRulesIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {QosPoliciesDscpMarkingRuleUpdateRequest} [qosPoliciesDscpMarkingRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId: string, id: string, qosPoliciesDscpMarkingRuleUpdateRequest?: QosPoliciesDscpMarkingRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdDscpMarkingRulesIdPut(policyId, id, qosPoliciesDscpMarkingRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/dscp_marking_rules/{id} API
     * @param {QosPoliciesDscpMarkingRulesCreateRequest} [qosPoliciesDscpMarkingRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdDscpMarkingRulesPost(policyId: string, qosPoliciesDscpMarkingRulesCreateRequest?: QosPoliciesDscpMarkingRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdDscpMarkingRulesPost(policyId, qosPoliciesDscpMarkingRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
     * @param {string | number} [minKbps] min_kbps query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
     * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumBandwidthRulesGet(id?: string, minKbps?: string | number, direction?: QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumBandwidthRulesGet(id, minKbps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumBandwidthRulesIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumBandwidthRulesIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {QosPoliciesMinimumBandwidthRuleUpdateRequest} [qosPoliciesMinimumBandwidthRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId: string, id: string, qosPoliciesMinimumBandwidthRuleUpdateRequest?: QosPoliciesMinimumBandwidthRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumBandwidthRulesIdPut(policyId, id, qosPoliciesMinimumBandwidthRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum_bandwidth_rules/{id} API
     * @param {QosPoliciesMinimumBandwidthRulesCreateRequest} [qosPoliciesMinimumBandwidthRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId: string, qosPoliciesMinimumBandwidthRulesCreateRequest?: QosPoliciesMinimumBandwidthRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumBandwidthRulesPost(policyId, qosPoliciesMinimumBandwidthRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
     * @param {string | number} [minKpps] min_kpps query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
     * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumPacketRateRulesGet(id?: string, minKpps?: string | number, direction?: QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum, sortKey?: string, sortDir?: QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumPacketRateRulesGet(id, minKpps, direction, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumPacketRateRulesIdDelete(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId: string, id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumPacketRateRulesIdGet(policyId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {string} id id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {QosPoliciesMinimumPacketRateRuleUpdateRequest} [qosPoliciesMinimumPacketRateRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId: string, id: string, qosPoliciesMinimumPacketRateRuleUpdateRequest?: QosPoliciesMinimumPacketRateRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumPacketRateRulesIdPut(policyId, id, qosPoliciesMinimumPacketRateRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} policyId policy_id parameter for /v2.0/qos/policies/{policy_id}/minimum-packet-rate-rules/{id} API
     * @param {QosPoliciesMinimumPacketRateRulesCreateRequest} [qosPoliciesMinimumPacketRateRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId: string, qosPoliciesMinimumPacketRateRulesCreateRequest?: QosPoliciesMinimumPacketRateRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPolicyIdMinimumPacketRateRulesPost(policyId, qosPoliciesMinimumPacketRateRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosPoliciesCreateRequest} [qosPoliciesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosPoliciesPost(qosPoliciesCreateRequest?: QosPoliciesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosPoliciesPost(qosPoliciesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string | boolean | null} [allRules] all_rules query parameter for /v2.0/qos/rule-types API
     * @param {string | boolean | null} [allSupported] all_supported query parameter for /v2.0/qos/rule-types API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QosRuleTypesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosRuleTypesGet(allRules?: string | boolean | null, allSupported?: string | boolean | null, sortKey?: string, sortDir?: QosRuleTypesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosRuleTypesGet(allRules, allSupported, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosRuleTypesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosRuleTypesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosRuleTypesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosRuleTypesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/qos/rule-types/{id} API
     * @param {QosRuleTypeUpdateRequest} [qosRuleTypeUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosRuleTypesIdPut(id: string, qosRuleTypeUpdateRequest?: QosRuleTypeUpdateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosRuleTypesIdPut(id, qosRuleTypeUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {QosRuleTypesCreateRequest} [qosRuleTypesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QosApi
     */
    public qosRuleTypesPost(qosRuleTypesCreateRequest?: QosRuleTypesCreateRequest, options?: RawAxiosRequestConfig) {
        return QosApiFp(this.configuration).qosRuleTypesPost(qosRuleTypesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const QosAliasBandwidthLimitRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type QosAliasBandwidthLimitRulesGetDirectionEnum = typeof QosAliasBandwidthLimitRulesGetDirectionEnum[keyof typeof QosAliasBandwidthLimitRulesGetDirectionEnum];
/**
 * @export
 */
export const QosAliasBandwidthLimitRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosAliasBandwidthLimitRulesGetSortDirEnum = typeof QosAliasBandwidthLimitRulesGetSortDirEnum[keyof typeof QosAliasBandwidthLimitRulesGetSortDirEnum];
/**
 * @export
 */
export const QosAliasDscpMarkingRulesGetDscpMarkEnum = {
    _0: '0',
    _8: '8',
    _10: '10',
    _12: '12',
    _14: '14',
    _16: '16',
    _18: '18',
    _20: '20',
    _22: '22',
    _24: '24',
    _26: '26',
    _28: '28',
    _30: '30',
    _32: '32',
    _34: '34',
    _36: '36',
    _38: '38',
    _40: '40',
    _44: '44',
    _46: '46',
    _48: '48',
    _56: '56'
} as const;
export type QosAliasDscpMarkingRulesGetDscpMarkEnum = typeof QosAliasDscpMarkingRulesGetDscpMarkEnum[keyof typeof QosAliasDscpMarkingRulesGetDscpMarkEnum];
/**
 * @export
 */
export const QosAliasDscpMarkingRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosAliasDscpMarkingRulesGetSortDirEnum = typeof QosAliasDscpMarkingRulesGetSortDirEnum[keyof typeof QosAliasDscpMarkingRulesGetSortDirEnum];
/**
 * @export
 */
export const QosAliasMinimumBandwidthRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type QosAliasMinimumBandwidthRulesGetDirectionEnum = typeof QosAliasMinimumBandwidthRulesGetDirectionEnum[keyof typeof QosAliasMinimumBandwidthRulesGetDirectionEnum];
/**
 * @export
 */
export const QosAliasMinimumBandwidthRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosAliasMinimumBandwidthRulesGetSortDirEnum = typeof QosAliasMinimumBandwidthRulesGetSortDirEnum[keyof typeof QosAliasMinimumBandwidthRulesGetSortDirEnum];
/**
 * @export
 */
export const QosAliasMinimumPacketRateRulesGetDirectionEnum = {
    Any: 'any',
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type QosAliasMinimumPacketRateRulesGetDirectionEnum = typeof QosAliasMinimumPacketRateRulesGetDirectionEnum[keyof typeof QosAliasMinimumPacketRateRulesGetDirectionEnum];
/**
 * @export
 */
export const QosAliasMinimumPacketRateRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosAliasMinimumPacketRateRulesGetSortDirEnum = typeof QosAliasMinimumPacketRateRulesGetSortDirEnum[keyof typeof QosAliasMinimumPacketRateRulesGetSortDirEnum];
/**
 * @export
 */
export const QosPoliciesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosPoliciesGetSortDirEnum = typeof QosPoliciesGetSortDirEnum[keyof typeof QosPoliciesGetSortDirEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum = typeof QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum[keyof typeof QosPoliciesPolicyIdBandwidthLimitRulesGetSortDirEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum = {
    _0: '0',
    _8: '8',
    _10: '10',
    _12: '12',
    _14: '14',
    _16: '16',
    _18: '18',
    _20: '20',
    _22: '22',
    _24: '24',
    _26: '26',
    _28: '28',
    _30: '30',
    _32: '32',
    _34: '34',
    _36: '36',
    _38: '38',
    _40: '40',
    _44: '44',
    _46: '46',
    _48: '48',
    _56: '56'
} as const;
export type QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum = typeof QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum[keyof typeof QosPoliciesPolicyIdDscpMarkingRulesGetDscpMarkEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum = typeof QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum[keyof typeof QosPoliciesPolicyIdDscpMarkingRulesGetSortDirEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum = typeof QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum[keyof typeof QosPoliciesPolicyIdMinimumBandwidthRulesGetDirectionEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum = typeof QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum[keyof typeof QosPoliciesPolicyIdMinimumBandwidthRulesGetSortDirEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum = {
    Any: 'any',
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum = typeof QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum[keyof typeof QosPoliciesPolicyIdMinimumPacketRateRulesGetDirectionEnum];
/**
 * @export
 */
export const QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum = typeof QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum[keyof typeof QosPoliciesPolicyIdMinimumPacketRateRulesGetSortDirEnum];
/**
 * @export
 */
export const QosRuleTypesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QosRuleTypesGetSortDirEnum = typeof QosRuleTypesGetSortDirEnum[keyof typeof QosRuleTypesGetSortDirEnum];


/**
 * QuotasApi - axios parameter creator
 * @export
 */
export const QuotasApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QuotasGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasGet: async (sortKey?: string, sortDir?: QuotasGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/quotas`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDefaultGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotasIdDefaultGet', 'id', id)
            const localVarPath = `/v2.0/quotas/{id}/default`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotasIdDelete', 'id', id)
            const localVarPath = `/v2.0/quotas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/details API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDetailsGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotasIdDetailsGet', 'id', id)
            const localVarPath = `/v2.0/quotas/{id}/details`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotasIdGet', 'id', id)
            const localVarPath = `/v2.0/quotas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {QuotaUpdateRequest} [quotaUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdPut: async (id: string, quotaUpdateRequest?: QuotaUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('quotasIdPut', 'id', id)
            const localVarPath = `/v2.0/quotas/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(quotaUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * QuotasApi - functional programming interface
 * @export
 */
export const QuotasApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = QuotasApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QuotasGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasGet(sortKey?: string, sortDir?: QuotasGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotasIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasIdDefaultGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotasDefaultDefaultResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasIdDefaultGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasIdDefaultGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/details API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasIdDetailsGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotasDetailsDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasIdDetailsGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasIdDetailsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotaShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {QuotaUpdateRequest} [quotaUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async quotasIdPut(id: string, quotaUpdateRequest?: QuotaUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<QuotaUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.quotasIdPut(id, quotaUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['QuotasApi.quotasIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * QuotasApi - factory interface
 * @export
 */
export const QuotasApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = QuotasApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {QuotasGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasGet(sortKey?: string, sortDir?: QuotasGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<QuotasIndexResponse> {
            return localVarFp.quotasGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDefaultGet(id: string, options?: any): AxiosPromise<QuotasDefaultDefaultResponse> {
            return localVarFp.quotasIdDefaultGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.quotasIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id}/details API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdDetailsGet(id: string, options?: any): AxiosPromise<QuotasDetailsDetailsResponse> {
            return localVarFp.quotasIdDetailsGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdGet(id: string, options?: any): AxiosPromise<QuotaShowResponse> {
            return localVarFp.quotasIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/quotas/{id} API
         * @param {QuotaUpdateRequest} [quotaUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        quotasIdPut(id: string, quotaUpdateRequest?: QuotaUpdateRequest, options?: any): AxiosPromise<QuotaUpdateResponse> {
            return localVarFp.quotasIdPut(id, quotaUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * QuotasApi - object-oriented interface
 * @export
 * @class QuotasApi
 * @extends {BaseAPI}
 */
export class QuotasApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {QuotasGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasGet(sortKey?: string, sortDir?: QuotasGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/quotas/{id}/default API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasIdDefaultGet(id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasIdDefaultGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/quotas/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/quotas/{id}/details API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasIdDetailsGet(id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasIdDetailsGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/quotas/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasIdGet(id: string, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/quotas/{id} API
     * @param {QuotaUpdateRequest} [quotaUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof QuotasApi
     */
    public quotasIdPut(id: string, quotaUpdateRequest?: QuotaUpdateRequest, options?: RawAxiosRequestConfig) {
        return QuotasApiFp(this.configuration).quotasIdPut(id, quotaUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const QuotasGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type QuotasGetSortDirEnum = typeof QuotasGetSortDirEnum[keyof typeof QuotasGetSortDirEnum];


/**
 * RbacPoliciesApi - axios parameter creator
 * @export
 */
export const RbacPoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/rbac-policies API
         * @param {string} [objectType] object_type query parameter for /v2.0/rbac-policies API
         * @param {string} [objectId] object_id query parameter for /v2.0/rbac-policies API
         * @param {string} [targetTenant] target_tenant query parameter for /v2.0/rbac-policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/rbac-policies API
         * @param {string} [action] action query parameter for /v2.0/rbac-policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RbacPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesGet: async (id?: string, objectType?: string, objectId?: string, targetTenant?: string, tenantId?: string, action?: string, sortKey?: string, sortDir?: RbacPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/rbac-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (objectType !== undefined) {
                localVarQueryParameter['object_type'] = objectType;
            }

            if (objectId !== undefined) {
                localVarQueryParameter['object_id'] = objectId;
            }

            if (targetTenant !== undefined) {
                localVarQueryParameter['target_tenant'] = targetTenant;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (action !== undefined) {
                localVarQueryParameter['action'] = action;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rbacPoliciesIdDelete', 'id', id)
            const localVarPath = `/v2.0/rbac-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rbacPoliciesIdGet', 'id', id)
            const localVarPath = `/v2.0/rbac-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {RbacPolicyUpdateRequest} [rbacPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdPut: async (id: string, rbacPolicyUpdateRequest?: RbacPolicyUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('rbacPoliciesIdPut', 'id', id)
            const localVarPath = `/v2.0/rbac-policies/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rbacPolicyUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RbacPoliciesCreateRequest} [rbacPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesPost: async (rbacPoliciesCreateRequest?: RbacPoliciesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/rbac-policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rbacPoliciesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RbacPoliciesApi - functional programming interface
 * @export
 */
export const RbacPoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RbacPoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/rbac-policies API
         * @param {string} [objectType] object_type query parameter for /v2.0/rbac-policies API
         * @param {string} [objectId] object_id query parameter for /v2.0/rbac-policies API
         * @param {string} [targetTenant] target_tenant query parameter for /v2.0/rbac-policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/rbac-policies API
         * @param {string} [action] action query parameter for /v2.0/rbac-policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RbacPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacPoliciesGet(id?: string, objectType?: string, objectId?: string, targetTenant?: string, tenantId?: string, action?: string, sortKey?: string, sortDir?: RbacPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacPoliciesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacPoliciesGet(id, objectType, objectId, targetTenant, tenantId, action, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacPoliciesApi.rbacPoliciesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacPoliciesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacPoliciesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacPoliciesApi.rbacPoliciesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacPoliciesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacPolicyShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacPoliciesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacPoliciesApi.rbacPoliciesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {RbacPolicyUpdateRequest} [rbacPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacPoliciesIdPut(id: string, rbacPolicyUpdateRequest?: RbacPolicyUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacPolicyUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacPoliciesIdPut(id, rbacPolicyUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacPoliciesApi.rbacPoliciesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {RbacPoliciesCreateRequest} [rbacPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rbacPoliciesPost(rbacPoliciesCreateRequest?: RbacPoliciesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RbacPoliciesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rbacPoliciesPost(rbacPoliciesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RbacPoliciesApi.rbacPoliciesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RbacPoliciesApi - factory interface
 * @export
 */
export const RbacPoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RbacPoliciesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/rbac-policies API
         * @param {string} [objectType] object_type query parameter for /v2.0/rbac-policies API
         * @param {string} [objectId] object_id query parameter for /v2.0/rbac-policies API
         * @param {string} [targetTenant] target_tenant query parameter for /v2.0/rbac-policies API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/rbac-policies API
         * @param {string} [action] action query parameter for /v2.0/rbac-policies API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RbacPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesGet(id?: string, objectType?: string, objectId?: string, targetTenant?: string, tenantId?: string, action?: string, sortKey?: string, sortDir?: RbacPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<RbacPoliciesIndexResponse> {
            return localVarFp.rbacPoliciesGet(id, objectType, objectId, targetTenant, tenantId, action, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.rbacPoliciesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdGet(id: string, options?: any): AxiosPromise<RbacPolicyShowResponse> {
            return localVarFp.rbacPoliciesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
         * @param {RbacPolicyUpdateRequest} [rbacPolicyUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesIdPut(id: string, rbacPolicyUpdateRequest?: RbacPolicyUpdateRequest, options?: any): AxiosPromise<RbacPolicyUpdateResponse> {
            return localVarFp.rbacPoliciesIdPut(id, rbacPolicyUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RbacPoliciesCreateRequest} [rbacPoliciesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rbacPoliciesPost(rbacPoliciesCreateRequest?: RbacPoliciesCreateRequest, options?: any): AxiosPromise<RbacPoliciesCreateResponse> {
            return localVarFp.rbacPoliciesPost(rbacPoliciesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RbacPoliciesApi - object-oriented interface
 * @export
 * @class RbacPoliciesApi
 * @extends {BaseAPI}
 */
export class RbacPoliciesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/rbac-policies API
     * @param {string} [objectType] object_type query parameter for /v2.0/rbac-policies API
     * @param {string} [objectId] object_id query parameter for /v2.0/rbac-policies API
     * @param {string} [targetTenant] target_tenant query parameter for /v2.0/rbac-policies API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/rbac-policies API
     * @param {string} [action] action query parameter for /v2.0/rbac-policies API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {RbacPoliciesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacPoliciesApi
     */
    public rbacPoliciesGet(id?: string, objectType?: string, objectId?: string, targetTenant?: string, tenantId?: string, action?: string, sortKey?: string, sortDir?: RbacPoliciesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return RbacPoliciesApiFp(this.configuration).rbacPoliciesGet(id, objectType, objectId, targetTenant, tenantId, action, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacPoliciesApi
     */
    public rbacPoliciesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return RbacPoliciesApiFp(this.configuration).rbacPoliciesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacPoliciesApi
     */
    public rbacPoliciesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RbacPoliciesApiFp(this.configuration).rbacPoliciesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/rbac-policies/{id} API
     * @param {RbacPolicyUpdateRequest} [rbacPolicyUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacPoliciesApi
     */
    public rbacPoliciesIdPut(id: string, rbacPolicyUpdateRequest?: RbacPolicyUpdateRequest, options?: RawAxiosRequestConfig) {
        return RbacPoliciesApiFp(this.configuration).rbacPoliciesIdPut(id, rbacPolicyUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RbacPoliciesCreateRequest} [rbacPoliciesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RbacPoliciesApi
     */
    public rbacPoliciesPost(rbacPoliciesCreateRequest?: RbacPoliciesCreateRequest, options?: RawAxiosRequestConfig) {
        return RbacPoliciesApiFp(this.configuration).rbacPoliciesPost(rbacPoliciesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RbacPoliciesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RbacPoliciesGetSortDirEnum = typeof RbacPoliciesGetSortDirEnum[keyof typeof RbacPoliciesGetSortDirEnum];


/**
 * RoutersApi - axios parameter creator
 * @export
 */
export const RoutersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers API
         * @param {string} [name] name query parameter for /v2.0/routers API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/routers API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/routers API
         * @param {string | boolean | null} [enableNdpProxy] enable_ndp_proxy query parameter for /v2.0/routers API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/routers API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/routers API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/routers API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/routers API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/routers API
         * @param {string} [description] description query parameter for /v2.0/routers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersGet: async (id?: string, name?: string, adminStateUp?: string | boolean, tenantId?: string, enableNdpProxy?: string | boolean | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (adminStateUp !== undefined) {
                for (const [key, value] of Object.entries(adminStateUp)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (enableNdpProxy !== undefined) {
                for (const [key, value] of Object.entries(enableNdpProxy)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExternalGatewaysAddExternalGatewaysRequest} [routersAddExternalGatewaysAddExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddExternalGatewaysPut: async (id: string, routersAddExternalGatewaysAddExternalGatewaysRequest?: RoutersAddExternalGatewaysAddExternalGatewaysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdAddExternalGatewaysPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/add_external_gateways`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersAddExternalGatewaysAddExternalGatewaysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExtraroutesAddExtraroutesRequest} [routersAddExtraroutesAddExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddExtraroutesPut: async (id: string, routersAddExtraroutesAddExtraroutesRequest?: RoutersAddExtraroutesAddExtraroutesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdAddExtraroutesPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/add_extraroutes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersAddExtraroutesAddExtraroutesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddRouterInterfaceAddRouterInterfaceRequest} [routersAddRouterInterfaceAddRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddRouterInterfacePut: async (id: string, routersAddRouterInterfaceAddRouterInterfaceRequest?: RoutersAddRouterInterfaceAddRouterInterfaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdAddRouterInterfacePut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/add_router_interface`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersAddRouterInterfaceAddRouterInterfaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdDelete', 'id', id)
            const localVarPath = `/v2.0/routers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdGet', 'id', id)
            const localVarPath = `/v2.0/routers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RouterUpdateRequest} [routerUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdPut: async (id: string, routerUpdateRequest?: RouterUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routerUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest} [routersRemoveExternalGatewaysRemoveExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveExternalGatewaysPut: async (id: string, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest?: RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdRemoveExternalGatewaysPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/remove_external_gateways`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersRemoveExternalGatewaysRemoveExternalGatewaysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExtraroutesRemoveExtraroutesRequest} [routersRemoveExtraroutesRemoveExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveExtraroutesPut: async (id: string, routersRemoveExtraroutesRemoveExtraroutesRequest?: RoutersRemoveExtraroutesRemoveExtraroutesRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdRemoveExtraroutesPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/remove_extraroutes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersRemoveExtraroutesRemoveExtraroutesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest} [routersRemoveRouterInterfaceRemoveRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveRouterInterfacePut: async (id: string, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest?: RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdRemoveRouterInterfacePut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/remove_router_interface`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersRemoveRouterInterfaceRemoveRouterInterfaceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest} [routersUpdateExternalGatewaysUpdateExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdUpdateExternalGatewaysPut: async (id: string, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest?: RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersIdUpdateExternalGatewaysPut', 'id', id)
            const localVarPath = `/v2.0/routers/{id}/update_external_gateways`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersUpdateExternalGatewaysUpdateExternalGatewaysRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RoutersCreateRequest} [routersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersPost: async (routersCreateRequest?: RoutersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/routers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdL3AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsGet: async (sortKey?: string, sortDir?: RoutersRouterIdL3AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/routers/{router_id}/l3-agents`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdDelete: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdDelete', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdDelete', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/l3-agents/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdGet: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdGet', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdGet', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/l3-agents/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdPut: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdPut', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsIdPut', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/l3-agents/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsPost: async (routerId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdL3AgentsPost', 'routerId', routerId)
            const localVarPath = `/v2.0/routers/{router_id}/l3-agents`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsDelete: async (routerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdTagsDelete', 'routerId', routerId)
            const localVarPath = `/v2.0/routers/{router_id}/tags`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsGet: async (sortKey?: string, sortDir?: RoutersRouterIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/routers/{router_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdDelete: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdTagsIdDelete', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/tags/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdGet: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdTagsIdGet', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/tags/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdPut: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdTagsIdPut', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/tags/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {RoutersTagsUpdateAllRequest} [routersTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsPut: async (routerId: string, routersTagsUpdateAllRequest?: RoutersTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdTagsPut', 'routerId', routerId)
            const localVarPath = `/v2.0/routers/{router_id}/tags`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutersApi - functional programming interface
 * @export
 */
export const RoutersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers API
         * @param {string} [name] name query parameter for /v2.0/routers API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/routers API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/routers API
         * @param {string | boolean | null} [enableNdpProxy] enable_ndp_proxy query parameter for /v2.0/routers API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/routers API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/routers API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/routers API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/routers API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/routers API
         * @param {string} [description] description query parameter for /v2.0/routers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersGet(id?: string, name?: string, adminStateUp?: string | boolean, tenantId?: string, enableNdpProxy?: string | boolean | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersGet(id, name, adminStateUp, tenantId, enableNdpProxy, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExternalGatewaysAddExternalGatewaysRequest} [routersAddExternalGatewaysAddExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdAddExternalGatewaysPut(id: string, routersAddExternalGatewaysAddExternalGatewaysRequest?: RoutersAddExternalGatewaysAddExternalGatewaysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdAddExternalGatewaysPut(id, routersAddExternalGatewaysAddExternalGatewaysRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdAddExternalGatewaysPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExtraroutesAddExtraroutesRequest} [routersAddExtraroutesAddExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdAddExtraroutesPut(id: string, routersAddExtraroutesAddExtraroutesRequest?: RoutersAddExtraroutesAddExtraroutesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersAddExtraroutesAddExtraroutesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdAddExtraroutesPut(id, routersAddExtraroutesAddExtraroutesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdAddExtraroutesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddRouterInterfaceAddRouterInterfaceRequest} [routersAddRouterInterfaceAddRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdAddRouterInterfacePut(id: string, routersAddRouterInterfaceAddRouterInterfaceRequest?: RoutersAddRouterInterfaceAddRouterInterfaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersAddRouterInterfaceAddRouterInterfaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdAddRouterInterfacePut(id, routersAddRouterInterfaceAddRouterInterfaceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdAddRouterInterfacePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RouterUpdateRequest} [routerUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdPut(id: string, routerUpdateRequest?: RouterUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdPut(id, routerUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest} [routersRemoveExternalGatewaysRemoveExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdRemoveExternalGatewaysPut(id: string, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest?: RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdRemoveExternalGatewaysPut(id, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdRemoveExternalGatewaysPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExtraroutesRemoveExtraroutesRequest} [routersRemoveExtraroutesRemoveExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdRemoveExtraroutesPut(id: string, routersRemoveExtraroutesRemoveExtraroutesRequest?: RoutersRemoveExtraroutesRemoveExtraroutesRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersRemoveExtraroutesRemoveExtraroutesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdRemoveExtraroutesPut(id, routersRemoveExtraroutesRemoveExtraroutesRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdRemoveExtraroutesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest} [routersRemoveRouterInterfaceRemoveRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdRemoveRouterInterfacePut(id: string, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest?: RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdRemoveRouterInterfacePut(id, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdRemoveRouterInterfacePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest} [routersUpdateExternalGatewaysUpdateExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersIdUpdateExternalGatewaysPut(id: string, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest?: RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RouterShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersIdUpdateExternalGatewaysPut(id, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersIdUpdateExternalGatewaysPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {RoutersCreateRequest} [routersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersPost(routersCreateRequest?: RoutersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersPost(routersCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdL3AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdL3AgentsGet(sortKey?: string, sortDir?: RoutersRouterIdL3AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdL3AgentsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdL3AgentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdL3AgentsIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdL3AgentsIdDelete(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdL3AgentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdL3AgentsIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdL3AgentsIdGet(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdL3AgentsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdL3AgentsIdPut(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdL3AgentsIdPut(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdL3AgentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdL3AgentsPost(routerId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdL3AgentsPost(routerId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdL3AgentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsDelete(routerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsDelete(routerId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsGet(sortKey?: string, sortDir?: RoutersRouterIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsIdDelete(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsIdGet(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsIdPut(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsIdPut(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {RoutersTagsUpdateAllRequest} [routersTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdTagsPut(routerId: string, routersTagsUpdateAllRequest?: RoutersTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdTagsPut(routerId, routersTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersApi.routersRouterIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RoutersApi - factory interface
 * @export
 */
export const RoutersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers API
         * @param {string} [name] name query parameter for /v2.0/routers API
         * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/routers API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/routers API
         * @param {string | boolean | null} [enableNdpProxy] enable_ndp_proxy query parameter for /v2.0/routers API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/routers API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/routers API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/routers API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/routers API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/routers API
         * @param {string} [description] description query parameter for /v2.0/routers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersGet(id?: string, name?: string, adminStateUp?: string | boolean, tenantId?: string, enableNdpProxy?: string | boolean | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<RoutersIndexResponse> {
            return localVarFp.routersGet(id, name, adminStateUp, tenantId, enableNdpProxy, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExternalGatewaysAddExternalGatewaysRequest} [routersAddExternalGatewaysAddExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddExternalGatewaysPut(id: string, routersAddExternalGatewaysAddExternalGatewaysRequest?: RoutersAddExternalGatewaysAddExternalGatewaysRequest, options?: any): AxiosPromise<RouterShowResponse> {
            return localVarFp.routersIdAddExternalGatewaysPut(id, routersAddExternalGatewaysAddExternalGatewaysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddExtraroutesAddExtraroutesRequest} [routersAddExtraroutesAddExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddExtraroutesPut(id: string, routersAddExtraroutesAddExtraroutesRequest?: RoutersAddExtraroutesAddExtraroutesRequest, options?: any): AxiosPromise<RoutersAddExtraroutesAddExtraroutesResponse> {
            return localVarFp.routersIdAddExtraroutesPut(id, routersAddExtraroutesAddExtraroutesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersAddRouterInterfaceAddRouterInterfaceRequest} [routersAddRouterInterfaceAddRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdAddRouterInterfacePut(id: string, routersAddRouterInterfaceAddRouterInterfaceRequest?: RoutersAddRouterInterfaceAddRouterInterfaceRequest, options?: any): AxiosPromise<RoutersAddRouterInterfaceAddRouterInterfaceResponse> {
            return localVarFp.routersIdAddRouterInterfacePut(id, routersAddRouterInterfaceAddRouterInterfaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdGet(id: string, options?: any): AxiosPromise<RouterShowResponse> {
            return localVarFp.routersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RouterUpdateRequest} [routerUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdPut(id: string, routerUpdateRequest?: RouterUpdateRequest, options?: any): AxiosPromise<RouterUpdateResponse> {
            return localVarFp.routersIdPut(id, routerUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest} [routersRemoveExternalGatewaysRemoveExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveExternalGatewaysPut(id: string, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest?: RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options?: any): AxiosPromise<RouterShowResponse> {
            return localVarFp.routersIdRemoveExternalGatewaysPut(id, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveExtraroutesRemoveExtraroutesRequest} [routersRemoveExtraroutesRemoveExtraroutesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveExtraroutesPut(id: string, routersRemoveExtraroutesRemoveExtraroutesRequest?: RoutersRemoveExtraroutesRemoveExtraroutesRequest, options?: any): AxiosPromise<RoutersRemoveExtraroutesRemoveExtraroutesResponse> {
            return localVarFp.routersIdRemoveExtraroutesPut(id, routersRemoveExtraroutesRemoveExtraroutesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest} [routersRemoveRouterInterfaceRemoveRouterInterfaceRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdRemoveRouterInterfacePut(id: string, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest?: RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options?: any): AxiosPromise<RoutersRemoveRouterInterfaceRemoveRouterInterfaceResponse> {
            return localVarFp.routersIdRemoveRouterInterfacePut(id, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/routers/{id} API
         * @param {RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest} [routersUpdateExternalGatewaysUpdateExternalGatewaysRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersIdUpdateExternalGatewaysPut(id: string, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest?: RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options?: any): AxiosPromise<RouterShowResponse> {
            return localVarFp.routersIdUpdateExternalGatewaysPut(id, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RoutersCreateRequest} [routersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersPost(routersCreateRequest?: RoutersCreateRequest, options?: any): AxiosPromise<RoutersCreateResponse> {
            return localVarFp.routersPost(routersCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdL3AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsGet(sortKey?: string, sortDir?: RoutersRouterIdL3AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<any> {
            return localVarFp.routersRouterIdL3AgentsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdDelete(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdL3AgentsIdDelete(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdGet(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdL3AgentsIdGet(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsIdPut(routerId: string, id: string, options?: any): AxiosPromise<any> {
            return localVarFp.routersRouterIdL3AgentsIdPut(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdL3AgentsPost(routerId: string, body?: any, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdL3AgentsPost(routerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsDelete(routerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdTagsDelete(routerId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsGet(sortKey?: string, sortDir?: RoutersRouterIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<RoutersTagsIndexResponse> {
            return localVarFp.routersRouterIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdDelete(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdTagsIdDelete(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdGet(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdTagsIdGet(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsIdPut(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdTagsIdPut(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
         * @param {RoutersTagsUpdateAllRequest} [routersTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdTagsPut(routerId: string, routersTagsUpdateAllRequest?: RoutersTagsUpdateAllRequest, options?: any): AxiosPromise<RoutersTagsUpdateAllResponse> {
            return localVarFp.routersRouterIdTagsPut(routerId, routersTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutersApi - object-oriented interface
 * @export
 * @class RoutersApi
 * @extends {BaseAPI}
 */
export class RoutersApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/routers API
     * @param {string} [name] name query parameter for /v2.0/routers API
     * @param {string | boolean} [adminStateUp] admin_state_up query parameter for /v2.0/routers API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/routers API
     * @param {string | boolean | null} [enableNdpProxy] enable_ndp_proxy query parameter for /v2.0/routers API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/routers API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/routers API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/routers API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/routers API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/routers API
     * @param {string} [description] description query parameter for /v2.0/routers API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {RoutersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersGet(id?: string, name?: string, adminStateUp?: string | boolean, tenantId?: string, enableNdpProxy?: string | boolean | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: RoutersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersGet(id, name, adminStateUp, tenantId, enableNdpProxy, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersAddExternalGatewaysAddExternalGatewaysRequest} [routersAddExternalGatewaysAddExternalGatewaysRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdAddExternalGatewaysPut(id: string, routersAddExternalGatewaysAddExternalGatewaysRequest?: RoutersAddExternalGatewaysAddExternalGatewaysRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdAddExternalGatewaysPut(id, routersAddExternalGatewaysAddExternalGatewaysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersAddExtraroutesAddExtraroutesRequest} [routersAddExtraroutesAddExtraroutesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdAddExtraroutesPut(id: string, routersAddExtraroutesAddExtraroutesRequest?: RoutersAddExtraroutesAddExtraroutesRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdAddExtraroutesPut(id, routersAddExtraroutesAddExtraroutesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersAddRouterInterfaceAddRouterInterfaceRequest} [routersAddRouterInterfaceAddRouterInterfaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdAddRouterInterfacePut(id: string, routersAddRouterInterfaceAddRouterInterfaceRequest?: RoutersAddRouterInterfaceAddRouterInterfaceRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdAddRouterInterfacePut(id, routersAddRouterInterfaceAddRouterInterfaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RouterUpdateRequest} [routerUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdPut(id: string, routerUpdateRequest?: RouterUpdateRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdPut(id, routerUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest} [routersRemoveExternalGatewaysRemoveExternalGatewaysRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdRemoveExternalGatewaysPut(id: string, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest?: RoutersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdRemoveExternalGatewaysPut(id, routersRemoveExternalGatewaysRemoveExternalGatewaysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersRemoveExtraroutesRemoveExtraroutesRequest} [routersRemoveExtraroutesRemoveExtraroutesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdRemoveExtraroutesPut(id: string, routersRemoveExtraroutesRemoveExtraroutesRequest?: RoutersRemoveExtraroutesRemoveExtraroutesRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdRemoveExtraroutesPut(id, routersRemoveExtraroutesRemoveExtraroutesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest} [routersRemoveRouterInterfaceRemoveRouterInterfaceRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdRemoveRouterInterfacePut(id: string, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest?: RoutersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdRemoveRouterInterfacePut(id, routersRemoveRouterInterfaceRemoveRouterInterfaceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/routers/{id} API
     * @param {RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest} [routersUpdateExternalGatewaysUpdateExternalGatewaysRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersIdUpdateExternalGatewaysPut(id: string, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest?: RoutersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersIdUpdateExternalGatewaysPut(id, routersUpdateExternalGatewaysUpdateExternalGatewaysRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RoutersCreateRequest} [routersCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersPost(routersCreateRequest?: RoutersCreateRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersPost(routersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {RoutersRouterIdL3AgentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdL3AgentsGet(sortKey?: string, sortDir?: RoutersRouterIdL3AgentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdL3AgentsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdL3AgentsIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdL3AgentsIdDelete(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdL3AgentsIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdL3AgentsIdGet(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdL3AgentsIdPut(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdL3AgentsIdPut(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/l3-agents/{id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdL3AgentsPost(routerId: string, body?: any, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdL3AgentsPost(routerId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsDelete(routerId: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsDelete(routerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {RoutersRouterIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsGet(sortKey?: string, sortDir?: RoutersRouterIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsIdDelete(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsIdGet(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsIdPut(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsIdPut(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/tags/{id} API
     * @param {RoutersTagsUpdateAllRequest} [routersTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersApi
     */
    public routersRouterIdTagsPut(routerId: string, routersTagsUpdateAllRequest?: RoutersTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return RoutersApiFp(this.configuration).routersRouterIdTagsPut(routerId, routersTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RoutersGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoutersGetSortDirEnum = typeof RoutersGetSortDirEnum[keyof typeof RoutersGetSortDirEnum];
/**
 * @export
 */
export const RoutersRouterIdL3AgentsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoutersRouterIdL3AgentsGetSortDirEnum = typeof RoutersRouterIdL3AgentsGetSortDirEnum[keyof typeof RoutersRouterIdL3AgentsGetSortDirEnum];
/**
 * @export
 */
export const RoutersRouterIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoutersRouterIdTagsGetSortDirEnum = typeof RoutersRouterIdTagsGetSortDirEnum[keyof typeof RoutersRouterIdTagsGetSortDirEnum];


/**
 * RoutersConntrackHelperApi - axios parameter creator
 * @export
 */
export const RoutersConntrackHelperApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {RoutersRouterIdConntrackHelpersGetProtocolEnum} [protocol] protocol query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string | number} [port] port query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [helper] helper query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdConntrackHelpersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersGet: async (id?: string, protocol?: RoutersRouterIdConntrackHelpersGetProtocolEnum, port?: string | number, helper?: string, sortKey?: string, sortDir?: RoutersRouterIdConntrackHelpersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/routers/{router_id}/conntrack_helpers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (port !== undefined) {
                for (const [key, value] of Object.entries(port)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (helper !== undefined) {
                localVarQueryParameter['helper'] = helper;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdDelete: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdDelete', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdDelete', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/conntrack_helpers/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdGet: async (routerId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdGet', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdGet', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/conntrack_helpers/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelperUpdateRequest} [routersConntrackHelperUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdPut: async (routerId: string, id: string, routersConntrackHelperUpdateRequest?: RoutersConntrackHelperUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdPut', 'routerId', routerId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersIdPut', 'id', id)
            const localVarPath = `/v2.0/routers/{router_id}/conntrack_helpers/{id}`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersConntrackHelperUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelpersCreateRequest} [routersConntrackHelpersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersPost: async (routerId: string, routersConntrackHelpersCreateRequest?: RoutersConntrackHelpersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'routerId' is not null or undefined
            assertParamExists('routersRouterIdConntrackHelpersPost', 'routerId', routerId)
            const localVarPath = `/v2.0/routers/{router_id}/conntrack_helpers`
                .replace(`{${"router_id"}}`, encodeURIComponent(String(routerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(routersConntrackHelpersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoutersConntrackHelperApi - functional programming interface
 * @export
 */
export const RoutersConntrackHelperApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoutersConntrackHelperApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {RoutersRouterIdConntrackHelpersGetProtocolEnum} [protocol] protocol query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string | number} [port] port query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [helper] helper query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdConntrackHelpersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdConntrackHelpersGet(id?: string, protocol?: RoutersRouterIdConntrackHelpersGetProtocolEnum, port?: string | number, helper?: string, sortKey?: string, sortDir?: RoutersRouterIdConntrackHelpersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersConntrackHelpersIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdConntrackHelpersGet(id, protocol, port, helper, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersConntrackHelperApi.routersRouterIdConntrackHelpersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdConntrackHelpersIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdConntrackHelpersIdDelete(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersConntrackHelperApi.routersRouterIdConntrackHelpersIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdConntrackHelpersIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersConntrackHelperShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdConntrackHelpersIdGet(routerId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersConntrackHelperApi.routersRouterIdConntrackHelpersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelperUpdateRequest} [routersConntrackHelperUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdConntrackHelpersIdPut(routerId: string, id: string, routersConntrackHelperUpdateRequest?: RoutersConntrackHelperUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersConntrackHelperUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdConntrackHelpersIdPut(routerId, id, routersConntrackHelperUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersConntrackHelperApi.routersRouterIdConntrackHelpersIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelpersCreateRequest} [routersConntrackHelpersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async routersRouterIdConntrackHelpersPost(routerId: string, routersConntrackHelpersCreateRequest?: RoutersConntrackHelpersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoutersConntrackHelpersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.routersRouterIdConntrackHelpersPost(routerId, routersConntrackHelpersCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoutersConntrackHelperApi.routersRouterIdConntrackHelpersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RoutersConntrackHelperApi - factory interface
 * @export
 */
export const RoutersConntrackHelperApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoutersConntrackHelperApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {RoutersRouterIdConntrackHelpersGetProtocolEnum} [protocol] protocol query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string | number} [port] port query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [helper] helper query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {RoutersRouterIdConntrackHelpersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersGet(id?: string, protocol?: RoutersRouterIdConntrackHelpersGetProtocolEnum, port?: string | number, helper?: string, sortKey?: string, sortDir?: RoutersRouterIdConntrackHelpersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<RoutersConntrackHelpersIndexResponse> {
            return localVarFp.routersRouterIdConntrackHelpersGet(id, protocol, port, helper, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdDelete(routerId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.routersRouterIdConntrackHelpersIdDelete(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdGet(routerId: string, id: string, options?: any): AxiosPromise<RoutersConntrackHelperShowResponse> {
            return localVarFp.routersRouterIdConntrackHelpersIdGet(routerId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelperUpdateRequest} [routersConntrackHelperUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersIdPut(routerId: string, id: string, routersConntrackHelperUpdateRequest?: RoutersConntrackHelperUpdateRequest, options?: any): AxiosPromise<RoutersConntrackHelperUpdateResponse> {
            return localVarFp.routersRouterIdConntrackHelpersIdPut(routerId, id, routersConntrackHelperUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
         * @param {RoutersConntrackHelpersCreateRequest} [routersConntrackHelpersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        routersRouterIdConntrackHelpersPost(routerId: string, routersConntrackHelpersCreateRequest?: RoutersConntrackHelpersCreateRequest, options?: any): AxiosPromise<RoutersConntrackHelpersCreateResponse> {
            return localVarFp.routersRouterIdConntrackHelpersPost(routerId, routersConntrackHelpersCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoutersConntrackHelperApi - object-oriented interface
 * @export
 * @class RoutersConntrackHelperApi
 * @extends {BaseAPI}
 */
export class RoutersConntrackHelperApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
     * @param {RoutersRouterIdConntrackHelpersGetProtocolEnum} [protocol] protocol query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
     * @param {string | number} [port] port query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
     * @param {string} [helper] helper query parameter for /v2.0/routers/{router_id}/conntrack_helpers API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {RoutersRouterIdConntrackHelpersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersConntrackHelperApi
     */
    public routersRouterIdConntrackHelpersGet(id?: string, protocol?: RoutersRouterIdConntrackHelpersGetProtocolEnum, port?: string | number, helper?: string, sortKey?: string, sortDir?: RoutersRouterIdConntrackHelpersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return RoutersConntrackHelperApiFp(this.configuration).routersRouterIdConntrackHelpersGet(id, protocol, port, helper, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersConntrackHelperApi
     */
    public routersRouterIdConntrackHelpersIdDelete(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersConntrackHelperApiFp(this.configuration).routersRouterIdConntrackHelpersIdDelete(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersConntrackHelperApi
     */
    public routersRouterIdConntrackHelpersIdGet(routerId: string, id: string, options?: RawAxiosRequestConfig) {
        return RoutersConntrackHelperApiFp(this.configuration).routersRouterIdConntrackHelpersIdGet(routerId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {string} id id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {RoutersConntrackHelperUpdateRequest} [routersConntrackHelperUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersConntrackHelperApi
     */
    public routersRouterIdConntrackHelpersIdPut(routerId: string, id: string, routersConntrackHelperUpdateRequest?: RoutersConntrackHelperUpdateRequest, options?: RawAxiosRequestConfig) {
        return RoutersConntrackHelperApiFp(this.configuration).routersRouterIdConntrackHelpersIdPut(routerId, id, routersConntrackHelperUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} routerId router_id parameter for /v2.0/routers/{router_id}/conntrack_helpers/{id} API
     * @param {RoutersConntrackHelpersCreateRequest} [routersConntrackHelpersCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoutersConntrackHelperApi
     */
    public routersRouterIdConntrackHelpersPost(routerId: string, routersConntrackHelpersCreateRequest?: RoutersConntrackHelpersCreateRequest, options?: RawAxiosRequestConfig) {
        return RoutersConntrackHelperApiFp(this.configuration).routersRouterIdConntrackHelpersPost(routerId, routersConntrackHelpersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const RoutersRouterIdConntrackHelpersGetProtocolEnum = {
    Dccp: 'dccp',
    Icmp: 'icmp',
    Ipv6Icmp: 'ipv6-icmp',
    Sctp: 'sctp',
    Tcp: 'tcp',
    Udp: 'udp'
} as const;
export type RoutersRouterIdConntrackHelpersGetProtocolEnum = typeof RoutersRouterIdConntrackHelpersGetProtocolEnum[keyof typeof RoutersRouterIdConntrackHelpersGetProtocolEnum];
/**
 * @export
 */
export const RoutersRouterIdConntrackHelpersGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type RoutersRouterIdConntrackHelpersGetSortDirEnum = typeof RoutersRouterIdConntrackHelpersGetSortDirEnum[keyof typeof RoutersRouterIdConntrackHelpersGetSortDirEnum];


/**
 * SecurityGroupRulesApi - axios parameter creator
 * @export
 */
export const SecurityGroupRulesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-group-rules API
         * @param {string} [securityGroupId] security_group_id query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/security-group-rules API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-group-rules API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/security-group-rules API
         * @param {string | null} [normalizedCidr] normalized_cidr query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/security-group-rules API
         * @param {string | boolean | null} [belongsToDefaultSg] belongs_to_default_sg query parameter for /v2.0/security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesGet: async (id?: string, securityGroupId?: string, remoteGroupId?: string, direction?: SecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: SecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, tenantId?: string, revisionNumber?: string, description?: string, normalizedCidr?: string | null, remoteAddressGroupId?: string, belongsToDefaultSg?: string | boolean | null, sortKey?: string, sortDir?: SecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/security-group-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (securityGroupId !== undefined) {
                localVarQueryParameter['security_group_id'] = securityGroupId;
            }

            if (remoteGroupId !== undefined) {
                localVarQueryParameter['remote_group_id'] = remoteGroupId;
            }

            if (direction !== undefined) {
                localVarQueryParameter['direction'] = direction;
            }

            if (protocol !== undefined) {
                localVarQueryParameter['protocol'] = protocol;
            }

            if (portRangeMin !== undefined) {
                localVarQueryParameter['port_range_min'] = portRangeMin;
            }

            if (portRangeMax !== undefined) {
                localVarQueryParameter['port_range_max'] = portRangeMax;
            }

            if (ethertype !== undefined) {
                localVarQueryParameter['ethertype'] = ethertype;
            }

            if (remoteIpPrefix !== undefined) {
                localVarQueryParameter['remote_ip_prefix'] = remoteIpPrefix;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (normalizedCidr !== undefined) {
                localVarQueryParameter['normalized_cidr'] = normalizedCidr;
            }

            if (remoteAddressGroupId !== undefined) {
                localVarQueryParameter['remote_address_group_id'] = remoteAddressGroupId;
            }

            if (belongsToDefaultSg !== undefined) {
                for (const [key, value] of Object.entries(belongsToDefaultSg)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupRulesIdDelete', 'id', id)
            const localVarPath = `/v2.0/security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupRulesIdGet', 'id', id)
            const localVarPath = `/v2.0/security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {SecurityGroupRuleUpdateRequest} [securityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdPut: async (id: string, securityGroupRuleUpdateRequest?: SecurityGroupRuleUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupRulesIdPut', 'id', id)
            const localVarPath = `/v2.0/security-group-rules/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityGroupRuleUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecurityGroupRulesCreateRequest} [securityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesPost: async (securityGroupRulesCreateRequest?: SecurityGroupRulesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/security-group-rules`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityGroupRulesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityGroupRulesApi - functional programming interface
 * @export
 */
export const SecurityGroupRulesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityGroupRulesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-group-rules API
         * @param {string} [securityGroupId] security_group_id query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/security-group-rules API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-group-rules API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/security-group-rules API
         * @param {string | null} [normalizedCidr] normalized_cidr query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/security-group-rules API
         * @param {string | boolean | null} [belongsToDefaultSg] belongs_to_default_sg query parameter for /v2.0/security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupRulesGet(id?: string, securityGroupId?: string, remoteGroupId?: string, direction?: SecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: SecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, tenantId?: string, revisionNumber?: string, description?: string, normalizedCidr?: string | null, remoteAddressGroupId?: string, belongsToDefaultSg?: string | boolean | null, sortKey?: string, sortDir?: SecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupRulesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupRulesGet(id, securityGroupId, remoteGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, tenantId, revisionNumber, description, normalizedCidr, remoteAddressGroupId, belongsToDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupRulesApi.securityGroupRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupRulesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupRulesApi.securityGroupRulesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupRulesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupRuleShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupRulesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupRulesApi.securityGroupRulesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {SecurityGroupRuleUpdateRequest} [securityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupRulesIdPut(id: string, securityGroupRuleUpdateRequest?: SecurityGroupRuleUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupRuleUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupRulesIdPut(id, securityGroupRuleUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupRulesApi.securityGroupRulesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SecurityGroupRulesCreateRequest} [securityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupRulesPost(securityGroupRulesCreateRequest?: SecurityGroupRulesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupRulesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupRulesPost(securityGroupRulesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupRulesApi.securityGroupRulesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SecurityGroupRulesApi - factory interface
 * @export
 */
export const SecurityGroupRulesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityGroupRulesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-group-rules API
         * @param {string} [securityGroupId] security_group_id query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/security-group-rules API
         * @param {string} [protocol] protocol query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/security-group-rules API
         * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/security-group-rules API
         * @param {SecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/security-group-rules API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-group-rules API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-group-rules API
         * @param {string} [description] description query parameter for /v2.0/security-group-rules API
         * @param {string | null} [normalizedCidr] normalized_cidr query parameter for /v2.0/security-group-rules API
         * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/security-group-rules API
         * @param {string | boolean | null} [belongsToDefaultSg] belongs_to_default_sg query parameter for /v2.0/security-group-rules API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesGet(id?: string, securityGroupId?: string, remoteGroupId?: string, direction?: SecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: SecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, tenantId?: string, revisionNumber?: string, description?: string, normalizedCidr?: string | null, remoteAddressGroupId?: string, belongsToDefaultSg?: string | boolean | null, sortKey?: string, sortDir?: SecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SecurityGroupRulesIndexResponse> {
            return localVarFp.securityGroupRulesGet(id, securityGroupId, remoteGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, tenantId, revisionNumber, description, normalizedCidr, remoteAddressGroupId, belongsToDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupRulesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdGet(id: string, options?: any): AxiosPromise<SecurityGroupRuleShowResponse> {
            return localVarFp.securityGroupRulesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
         * @param {SecurityGroupRuleUpdateRequest} [securityGroupRuleUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesIdPut(id: string, securityGroupRuleUpdateRequest?: SecurityGroupRuleUpdateRequest, options?: any): AxiosPromise<SecurityGroupRuleUpdateResponse> {
            return localVarFp.securityGroupRulesIdPut(id, securityGroupRuleUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SecurityGroupRulesCreateRequest} [securityGroupRulesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupRulesPost(securityGroupRulesCreateRequest?: SecurityGroupRulesCreateRequest, options?: any): AxiosPromise<SecurityGroupRulesCreateResponse> {
            return localVarFp.securityGroupRulesPost(securityGroupRulesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityGroupRulesApi - object-oriented interface
 * @export
 * @class SecurityGroupRulesApi
 * @extends {BaseAPI}
 */
export class SecurityGroupRulesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/security-group-rules API
     * @param {string} [securityGroupId] security_group_id query parameter for /v2.0/security-group-rules API
     * @param {string} [remoteGroupId] remote_group_id query parameter for /v2.0/security-group-rules API
     * @param {SecurityGroupRulesGetDirectionEnum} [direction] direction query parameter for /v2.0/security-group-rules API
     * @param {string} [protocol] protocol query parameter for /v2.0/security-group-rules API
     * @param {number | null} [portRangeMin] port_range_min query parameter for /v2.0/security-group-rules API
     * @param {number | null} [portRangeMax] port_range_max query parameter for /v2.0/security-group-rules API
     * @param {SecurityGroupRulesGetEthertypeEnum} [ethertype] ethertype query parameter for /v2.0/security-group-rules API
     * @param {string} [remoteIpPrefix] remote_ip_prefix query parameter for /v2.0/security-group-rules API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-group-rules API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-group-rules API
     * @param {string} [description] description query parameter for /v2.0/security-group-rules API
     * @param {string | null} [normalizedCidr] normalized_cidr query parameter for /v2.0/security-group-rules API
     * @param {string} [remoteAddressGroupId] remote_address_group_id query parameter for /v2.0/security-group-rules API
     * @param {string | boolean | null} [belongsToDefaultSg] belongs_to_default_sg query parameter for /v2.0/security-group-rules API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SecurityGroupRulesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupRulesApi
     */
    public securityGroupRulesGet(id?: string, securityGroupId?: string, remoteGroupId?: string, direction?: SecurityGroupRulesGetDirectionEnum, protocol?: string, portRangeMin?: number | null, portRangeMax?: number | null, ethertype?: SecurityGroupRulesGetEthertypeEnum, remoteIpPrefix?: string, tenantId?: string, revisionNumber?: string, description?: string, normalizedCidr?: string | null, remoteAddressGroupId?: string, belongsToDefaultSg?: string | boolean | null, sortKey?: string, sortDir?: SecurityGroupRulesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SecurityGroupRulesApiFp(this.configuration).securityGroupRulesGet(id, securityGroupId, remoteGroupId, direction, protocol, portRangeMin, portRangeMax, ethertype, remoteIpPrefix, tenantId, revisionNumber, description, normalizedCidr, remoteAddressGroupId, belongsToDefaultSg, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupRulesApi
     */
    public securityGroupRulesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupRulesApiFp(this.configuration).securityGroupRulesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupRulesApi
     */
    public securityGroupRulesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupRulesApiFp(this.configuration).securityGroupRulesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-group-rules/{id} API
     * @param {SecurityGroupRuleUpdateRequest} [securityGroupRuleUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupRulesApi
     */
    public securityGroupRulesIdPut(id: string, securityGroupRuleUpdateRequest?: SecurityGroupRuleUpdateRequest, options?: RawAxiosRequestConfig) {
        return SecurityGroupRulesApiFp(this.configuration).securityGroupRulesIdPut(id, securityGroupRuleUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecurityGroupRulesCreateRequest} [securityGroupRulesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupRulesApi
     */
    public securityGroupRulesPost(securityGroupRulesCreateRequest?: SecurityGroupRulesCreateRequest, options?: RawAxiosRequestConfig) {
        return SecurityGroupRulesApiFp(this.configuration).securityGroupRulesPost(securityGroupRulesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SecurityGroupRulesGetDirectionEnum = {
    Ingress: 'ingress',
    Egress: 'egress'
} as const;
export type SecurityGroupRulesGetDirectionEnum = typeof SecurityGroupRulesGetDirectionEnum[keyof typeof SecurityGroupRulesGetDirectionEnum];
/**
 * @export
 */
export const SecurityGroupRulesGetEthertypeEnum = {
    Ipv4: 'IPv4',
    Ipv6: 'IPv6'
} as const;
export type SecurityGroupRulesGetEthertypeEnum = typeof SecurityGroupRulesGetEthertypeEnum[keyof typeof SecurityGroupRulesGetEthertypeEnum];
/**
 * @export
 */
export const SecurityGroupRulesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SecurityGroupRulesGetSortDirEnum = typeof SecurityGroupRulesGetSortDirEnum[keyof typeof SecurityGroupRulesGetSortDirEnum];


/**
 * SecurityGroupsApi - axios parameter creator
 * @export
 */
export const SecurityGroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-groups API
         * @param {string} [name] name query parameter for /v2.0/security-groups API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-groups API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/security-groups API
         * @param {string} [description] description query parameter for /v2.0/security-groups API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/security-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsGet: async (id?: string, name?: string, tenantId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, shared?: string | boolean, sortKey?: string, sortDir?: SecurityGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/security-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsIdDelete', 'id', id)
            const localVarPath = `/v2.0/security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsIdGet', 'id', id)
            const localVarPath = `/v2.0/security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {SecurityGroupUpdateRequest} [securityGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdPut: async (id: string, securityGroupUpdateRequest?: SecurityGroupUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsIdPut', 'id', id)
            const localVarPath = `/v2.0/security-groups/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityGroupUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SecurityGroupsCreateRequest} [securityGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsPost: async (securityGroupsCreateRequest?: SecurityGroupsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/security-groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityGroupsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsDelete: async (securityGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGroupId' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsDelete', 'securityGroupId', securityGroupId)
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags`
                .replace(`{${"security_group_id"}}`, encodeURIComponent(String(securityGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsSecurityGroupIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsGet: async (sortKey?: string, sortDir?: SecurityGroupsSecurityGroupIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdDelete: async (securityGroupId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGroupId' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdDelete', 'securityGroupId', securityGroupId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags/{id}`
                .replace(`{${"security_group_id"}}`, encodeURIComponent(String(securityGroupId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdGet: async (securityGroupId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGroupId' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdGet', 'securityGroupId', securityGroupId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags/{id}`
                .replace(`{${"security_group_id"}}`, encodeURIComponent(String(securityGroupId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdPut: async (securityGroupId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGroupId' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdPut', 'securityGroupId', securityGroupId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags/{id}`
                .replace(`{${"security_group_id"}}`, encodeURIComponent(String(securityGroupId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {SecurityGroupsTagsUpdateAllRequest} [securityGroupsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsPut: async (securityGroupId: string, securityGroupsTagsUpdateAllRequest?: SecurityGroupsTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'securityGroupId' is not null or undefined
            assertParamExists('securityGroupsSecurityGroupIdTagsPut', 'securityGroupId', securityGroupId)
            const localVarPath = `/v2.0/security-groups/{security_group_id}/tags`
                .replace(`{${"security_group_id"}}`, encodeURIComponent(String(securityGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(securityGroupsTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SecurityGroupsApi - functional programming interface
 * @export
 */
export const SecurityGroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SecurityGroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-groups API
         * @param {string} [name] name query parameter for /v2.0/security-groups API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-groups API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/security-groups API
         * @param {string} [description] description query parameter for /v2.0/security-groups API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/security-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsGet(id?: string, name?: string, tenantId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, shared?: string | boolean, sortKey?: string, sortDir?: SecurityGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsGet(id, name, tenantId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, shared, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {SecurityGroupUpdateRequest} [securityGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsIdPut(id: string, securityGroupUpdateRequest?: SecurityGroupUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsIdPut(id, securityGroupUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SecurityGroupsCreateRequest} [securityGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsPost(securityGroupsCreateRequest?: SecurityGroupsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsPost(securityGroupsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsDelete(securityGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsDelete(securityGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsSecurityGroupIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsGet(sortKey?: string, sortDir?: SecurityGroupsSecurityGroupIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsIdGet(securityGroupId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsIdGet(securityGroupId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsIdPut(securityGroupId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsIdPut(securityGroupId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {SecurityGroupsTagsUpdateAllRequest} [securityGroupsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async securityGroupsSecurityGroupIdTagsPut(securityGroupId: string, securityGroupsTagsUpdateAllRequest?: SecurityGroupsTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SecurityGroupsTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.securityGroupsSecurityGroupIdTagsPut(securityGroupId, securityGroupsTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SecurityGroupsApi.securityGroupsSecurityGroupIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SecurityGroupsApi - factory interface
 * @export
 */
export const SecurityGroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SecurityGroupsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/security-groups API
         * @param {string} [name] name query parameter for /v2.0/security-groups API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-groups API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/security-groups API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/security-groups API
         * @param {string} [description] description query parameter for /v2.0/security-groups API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/security-groups API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsGet(id?: string, name?: string, tenantId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, shared?: string | boolean, sortKey?: string, sortDir?: SecurityGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SecurityGroupsIndexResponse> {
            return localVarFp.securityGroupsGet(id, name, tenantId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, shared, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdGet(id: string, options?: any): AxiosPromise<SecurityGroupShowResponse> {
            return localVarFp.securityGroupsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/security-groups/{id} API
         * @param {SecurityGroupUpdateRequest} [securityGroupUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsIdPut(id: string, securityGroupUpdateRequest?: SecurityGroupUpdateRequest, options?: any): AxiosPromise<SecurityGroupUpdateResponse> {
            return localVarFp.securityGroupsIdPut(id, securityGroupUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SecurityGroupsCreateRequest} [securityGroupsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsPost(securityGroupsCreateRequest?: SecurityGroupsCreateRequest, options?: any): AxiosPromise<SecurityGroupsCreateResponse> {
            return localVarFp.securityGroupsPost(securityGroupsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsDelete(securityGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupsSecurityGroupIdTagsDelete(securityGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SecurityGroupsSecurityGroupIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsGet(sortKey?: string, sortDir?: SecurityGroupsSecurityGroupIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SecurityGroupsTagsIndexResponse> {
            return localVarFp.securityGroupsSecurityGroupIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdGet(securityGroupId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupsSecurityGroupIdTagsIdGet(securityGroupId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsIdPut(securityGroupId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.securityGroupsSecurityGroupIdTagsIdPut(securityGroupId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
         * @param {SecurityGroupsTagsUpdateAllRequest} [securityGroupsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        securityGroupsSecurityGroupIdTagsPut(securityGroupId: string, securityGroupsTagsUpdateAllRequest?: SecurityGroupsTagsUpdateAllRequest, options?: any): AxiosPromise<SecurityGroupsTagsUpdateAllResponse> {
            return localVarFp.securityGroupsSecurityGroupIdTagsPut(securityGroupId, securityGroupsTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SecurityGroupsApi - object-oriented interface
 * @export
 * @class SecurityGroupsApi
 * @extends {BaseAPI}
 */
export class SecurityGroupsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/security-groups API
     * @param {string} [name] name query parameter for /v2.0/security-groups API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/security-groups API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/security-groups API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/security-groups API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/security-groups API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/security-groups API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/security-groups API
     * @param {string} [description] description query parameter for /v2.0/security-groups API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/security-groups API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SecurityGroupsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsGet(id?: string, name?: string, tenantId?: string, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, shared?: string | boolean, sortKey?: string, sortDir?: SecurityGroupsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsGet(id, name, tenantId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, shared, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-groups/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/security-groups/{id} API
     * @param {SecurityGroupUpdateRequest} [securityGroupUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsIdPut(id: string, securityGroupUpdateRequest?: SecurityGroupUpdateRequest, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsIdPut(id, securityGroupUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SecurityGroupsCreateRequest} [securityGroupsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsPost(securityGroupsCreateRequest?: SecurityGroupsCreateRequest, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsPost(securityGroupsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsDelete(securityGroupId: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsDelete(securityGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SecurityGroupsSecurityGroupIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsGet(sortKey?: string, sortDir?: SecurityGroupsSecurityGroupIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId: string, id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsIdDelete(securityGroupId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsIdGet(securityGroupId: string, id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsIdGet(securityGroupId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsIdPut(securityGroupId: string, id: string, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsIdPut(securityGroupId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} securityGroupId security_group_id parameter for /v2.0/security-groups/{security_group_id}/tags/{id} API
     * @param {SecurityGroupsTagsUpdateAllRequest} [securityGroupsTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SecurityGroupsApi
     */
    public securityGroupsSecurityGroupIdTagsPut(securityGroupId: string, securityGroupsTagsUpdateAllRequest?: SecurityGroupsTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return SecurityGroupsApiFp(this.configuration).securityGroupsSecurityGroupIdTagsPut(securityGroupId, securityGroupsTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SecurityGroupsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SecurityGroupsGetSortDirEnum = typeof SecurityGroupsGetSortDirEnum[keyof typeof SecurityGroupsGetSortDirEnum];
/**
 * @export
 */
export const SecurityGroupsSecurityGroupIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SecurityGroupsSecurityGroupIdTagsGetSortDirEnum = typeof SecurityGroupsSecurityGroupIdTagsGetSortDirEnum[keyof typeof SecurityGroupsSecurityGroupIdTagsGetSortDirEnum];


/**
 * SegmentsApi - axios parameter creator
 * @export
 */
export const SegmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/segments API
         * @param {string} [networkId] network_id query parameter for /v2.0/segments API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/segments API
         * @param {string} [networkType] network_type query parameter for /v2.0/segments API
         * @param {string | null} [name] name query parameter for /v2.0/segments API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/segments API
         * @param {string} [description] description query parameter for /v2.0/segments API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SegmentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsGet: async (id?: string, networkId?: string, physicalNetwork?: string, networkType?: string, name?: string | null, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: SegmentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = networkId;
            }

            if (physicalNetwork !== undefined) {
                localVarQueryParameter['physical_network'] = physicalNetwork;
            }

            if (networkType !== undefined) {
                localVarQueryParameter['network_type'] = networkType;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('segmentsIdDelete', 'id', id)
            const localVarPath = `/v2.0/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('segmentsIdGet', 'id', id)
            const localVarPath = `/v2.0/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {SegmentUpdateRequest} [segmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdPut: async (id: string, segmentUpdateRequest?: SegmentUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('segmentsIdPut', 'id', id)
            const localVarPath = `/v2.0/segments/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SegmentsCreateRequest} [segmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsPost: async (segmentsCreateRequest?: SegmentsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/segments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(segmentsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SegmentsApi - functional programming interface
 * @export
 */
export const SegmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SegmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/segments API
         * @param {string} [networkId] network_id query parameter for /v2.0/segments API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/segments API
         * @param {string} [networkType] network_type query parameter for /v2.0/segments API
         * @param {string | null} [name] name query parameter for /v2.0/segments API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/segments API
         * @param {string} [description] description query parameter for /v2.0/segments API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SegmentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentsGet(id?: string, networkId?: string, physicalNetwork?: string, networkType?: string, name?: string | null, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: SegmentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentsGet(id, networkId, physicalNetwork, networkType, name, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.segmentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.segmentsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.segmentsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {SegmentUpdateRequest} [segmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentsIdPut(id: string, segmentUpdateRequest?: SegmentUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentsIdPut(id, segmentUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.segmentsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SegmentsCreateRequest} [segmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async segmentsPost(segmentsCreateRequest?: SegmentsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SegmentsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.segmentsPost(segmentsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SegmentsApi.segmentsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SegmentsApi - factory interface
 * @export
 */
export const SegmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SegmentsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/segments API
         * @param {string} [networkId] network_id query parameter for /v2.0/segments API
         * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/segments API
         * @param {string} [networkType] network_type query parameter for /v2.0/segments API
         * @param {string | null} [name] name query parameter for /v2.0/segments API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/segments API
         * @param {string} [description] description query parameter for /v2.0/segments API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SegmentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsGet(id?: string, networkId?: string, physicalNetwork?: string, networkType?: string, name?: string | null, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: SegmentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SegmentsIndexResponse> {
            return localVarFp.segmentsGet(id, networkId, physicalNetwork, networkType, name, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.segmentsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdGet(id: string, options?: any): AxiosPromise<SegmentShowResponse> {
            return localVarFp.segmentsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/segments/{id} API
         * @param {SegmentUpdateRequest} [segmentUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsIdPut(id: string, segmentUpdateRequest?: SegmentUpdateRequest, options?: any): AxiosPromise<SegmentUpdateResponse> {
            return localVarFp.segmentsIdPut(id, segmentUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SegmentsCreateRequest} [segmentsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        segmentsPost(segmentsCreateRequest?: SegmentsCreateRequest, options?: any): AxiosPromise<SegmentsCreateResponse> {
            return localVarFp.segmentsPost(segmentsCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SegmentsApi - object-oriented interface
 * @export
 * @class SegmentsApi
 * @extends {BaseAPI}
 */
export class SegmentsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/segments API
     * @param {string} [networkId] network_id query parameter for /v2.0/segments API
     * @param {string} [physicalNetwork] physical_network query parameter for /v2.0/segments API
     * @param {string} [networkType] network_type query parameter for /v2.0/segments API
     * @param {string | null} [name] name query parameter for /v2.0/segments API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/segments API
     * @param {string} [description] description query parameter for /v2.0/segments API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SegmentsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public segmentsGet(id?: string, networkId?: string, physicalNetwork?: string, networkType?: string, name?: string | null, revisionNumber?: string, description?: string, sortKey?: string, sortDir?: SegmentsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).segmentsGet(id, networkId, physicalNetwork, networkType, name, revisionNumber, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/segments/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public segmentsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).segmentsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/segments/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public segmentsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).segmentsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/segments/{id} API
     * @param {SegmentUpdateRequest} [segmentUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public segmentsIdPut(id: string, segmentUpdateRequest?: SegmentUpdateRequest, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).segmentsIdPut(id, segmentUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SegmentsCreateRequest} [segmentsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SegmentsApi
     */
    public segmentsPost(segmentsCreateRequest?: SegmentsCreateRequest, options?: RawAxiosRequestConfig) {
        return SegmentsApiFp(this.configuration).segmentsPost(segmentsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SegmentsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SegmentsGetSortDirEnum = typeof SegmentsGetSortDirEnum[keyof typeof SegmentsGetSortDirEnum];


/**
 * ServiceProfilesApi - axios parameter creator
 * @export
 */
export const ServiceProfilesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/service_profiles API
         * @param {string | null} [description] description query parameter for /v2.0/service_profiles API
         * @param {string} [driver] driver query parameter for /v2.0/service_profiles API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/service_profiles API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesGet: async (id?: string, description?: string | null, driver?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: ServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/service_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (driver !== undefined) {
                localVarQueryParameter['driver'] = driver;
            }

            if (enabled !== undefined) {
                for (const [key, value] of Object.entries(enabled)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProfilesIdDelete', 'id', id)
            const localVarPath = `/v2.0/service_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProfilesIdGet', 'id', id)
            const localVarPath = `/v2.0/service_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {ServiceProfileUpdateRequest} [serviceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdPut: async (id: string, serviceProfileUpdateRequest?: ServiceProfileUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProfilesIdPut', 'id', id)
            const localVarPath = `/v2.0/service_profiles/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProfileUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceProfilesCreateRequest} [serviceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesPost: async (serviceProfilesCreateRequest?: ServiceProfilesCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/service_profiles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProfilesCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceProfilesApi - functional programming interface
 * @export
 */
export const ServiceProfilesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceProfilesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/service_profiles API
         * @param {string | null} [description] description query parameter for /v2.0/service_profiles API
         * @param {string} [driver] driver query parameter for /v2.0/service_profiles API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/service_profiles API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProfilesGet(id?: string, description?: string | null, driver?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: ServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProfilesIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProfilesGet(id, description, driver, enabled, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProfilesApi.serviceProfilesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProfilesIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProfilesIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProfilesApi.serviceProfilesIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProfilesIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProfileShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProfilesIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProfilesApi.serviceProfilesIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {ServiceProfileUpdateRequest} [serviceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProfilesIdPut(id: string, serviceProfileUpdateRequest?: ServiceProfileUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProfileUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProfilesIdPut(id, serviceProfileUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProfilesApi.serviceProfilesIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ServiceProfilesCreateRequest} [serviceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProfilesPost(serviceProfilesCreateRequest?: ServiceProfilesCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProfilesCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProfilesPost(serviceProfilesCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProfilesApi.serviceProfilesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceProfilesApi - factory interface
 * @export
 */
export const ServiceProfilesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceProfilesApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/service_profiles API
         * @param {string | null} [description] description query parameter for /v2.0/service_profiles API
         * @param {string} [driver] driver query parameter for /v2.0/service_profiles API
         * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/service_profiles API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesGet(id?: string, description?: string | null, driver?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: ServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<ServiceProfilesIndexResponse> {
            return localVarFp.serviceProfilesGet(id, description, driver, enabled, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serviceProfilesIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdGet(id: string, options?: any): AxiosPromise<ServiceProfileShowResponse> {
            return localVarFp.serviceProfilesIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
         * @param {ServiceProfileUpdateRequest} [serviceProfileUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesIdPut(id: string, serviceProfileUpdateRequest?: ServiceProfileUpdateRequest, options?: any): AxiosPromise<ServiceProfileUpdateResponse> {
            return localVarFp.serviceProfilesIdPut(id, serviceProfileUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceProfilesCreateRequest} [serviceProfilesCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProfilesPost(serviceProfilesCreateRequest?: ServiceProfilesCreateRequest, options?: any): AxiosPromise<ServiceProfilesCreateResponse> {
            return localVarFp.serviceProfilesPost(serviceProfilesCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceProfilesApi - object-oriented interface
 * @export
 * @class ServiceProfilesApi
 * @extends {BaseAPI}
 */
export class ServiceProfilesApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/service_profiles API
     * @param {string | null} [description] description query parameter for /v2.0/service_profiles API
     * @param {string} [driver] driver query parameter for /v2.0/service_profiles API
     * @param {string | boolean | null} [enabled] enabled query parameter for /v2.0/service_profiles API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {ServiceProfilesGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProfilesApi
     */
    public serviceProfilesGet(id?: string, description?: string | null, driver?: string, enabled?: string | boolean | null, sortKey?: string, sortDir?: ServiceProfilesGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return ServiceProfilesApiFp(this.configuration).serviceProfilesGet(id, description, driver, enabled, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProfilesApi
     */
    public serviceProfilesIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ServiceProfilesApiFp(this.configuration).serviceProfilesIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProfilesApi
     */
    public serviceProfilesIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ServiceProfilesApiFp(this.configuration).serviceProfilesIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/flavors/{flavor_id}/service_profiles/{id} API
     * @param {ServiceProfileUpdateRequest} [serviceProfileUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProfilesApi
     */
    public serviceProfilesIdPut(id: string, serviceProfileUpdateRequest?: ServiceProfileUpdateRequest, options?: RawAxiosRequestConfig) {
        return ServiceProfilesApiFp(this.configuration).serviceProfilesIdPut(id, serviceProfileUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceProfilesCreateRequest} [serviceProfilesCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProfilesApi
     */
    public serviceProfilesPost(serviceProfilesCreateRequest?: ServiceProfilesCreateRequest, options?: RawAxiosRequestConfig) {
        return ServiceProfilesApiFp(this.configuration).serviceProfilesPost(serviceProfilesCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ServiceProfilesGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ServiceProfilesGetSortDirEnum = typeof ServiceProfilesGetSortDirEnum[keyof typeof ServiceProfilesGetSortDirEnum];


/**
 * ServiceProvidersApi - axios parameter creator
 * @export
 */
export const ServiceProvidersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersGet: async (sortKey?: string, sortDir?: ServiceProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/service-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProvidersIdDelete', 'id', id)
            const localVarPath = `/v2.0/service-providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProvidersIdGet', 'id', id)
            const localVarPath = `/v2.0/service-providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {ServiceProviderUpdateRequest} [serviceProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdPut: async (id: string, serviceProviderUpdateRequest?: ServiceProviderUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('serviceProvidersIdPut', 'id', id)
            const localVarPath = `/v2.0/service-providers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProviderUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {ServiceProvidersCreateRequest} [serviceProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersPost: async (serviceProvidersCreateRequest?: ServiceProvidersCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/service-providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(serviceProvidersCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServiceProvidersApi - functional programming interface
 * @export
 */
export const ServiceProvidersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServiceProvidersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProvidersGet(sortKey?: string, sortDir?: ServiceProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProvidersIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProvidersApi.serviceProvidersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProvidersIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProvidersIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProvidersApi.serviceProvidersIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProvidersIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProvidersIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProvidersApi.serviceProvidersIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {ServiceProviderUpdateRequest} [serviceProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProvidersIdPut(id: string, serviceProviderUpdateRequest?: ServiceProviderUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProviderUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProvidersIdPut(id, serviceProviderUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProvidersApi.serviceProvidersIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {ServiceProvidersCreateRequest} [serviceProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async serviceProvidersPost(serviceProvidersCreateRequest?: ServiceProvidersCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServiceProvidersCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.serviceProvidersPost(serviceProvidersCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServiceProvidersApi.serviceProvidersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServiceProvidersApi - factory interface
 * @export
 */
export const ServiceProvidersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServiceProvidersApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {ServiceProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersGet(sortKey?: string, sortDir?: ServiceProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<ServiceProvidersIndexResponse> {
            return localVarFp.serviceProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.serviceProvidersIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdGet(id: string, options?: any): AxiosPromise<ServiceProviderShowResponse> {
            return localVarFp.serviceProvidersIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/service-providers/{id} API
         * @param {ServiceProviderUpdateRequest} [serviceProviderUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersIdPut(id: string, serviceProviderUpdateRequest?: ServiceProviderUpdateRequest, options?: any): AxiosPromise<ServiceProviderUpdateResponse> {
            return localVarFp.serviceProvidersIdPut(id, serviceProviderUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {ServiceProvidersCreateRequest} [serviceProvidersCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        serviceProvidersPost(serviceProvidersCreateRequest?: ServiceProvidersCreateRequest, options?: any): AxiosPromise<ServiceProvidersCreateResponse> {
            return localVarFp.serviceProvidersPost(serviceProvidersCreateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServiceProvidersApi - object-oriented interface
 * @export
 * @class ServiceProvidersApi
 * @extends {BaseAPI}
 */
export class ServiceProvidersApi extends BaseAPI {
    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {ServiceProvidersGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProvidersApi
     */
    public serviceProvidersGet(sortKey?: string, sortDir?: ServiceProvidersGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return ServiceProvidersApiFp(this.configuration).serviceProvidersGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/service-providers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProvidersApi
     */
    public serviceProvidersIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return ServiceProvidersApiFp(this.configuration).serviceProvidersIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/service-providers/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProvidersApi
     */
    public serviceProvidersIdGet(id: string, options?: RawAxiosRequestConfig) {
        return ServiceProvidersApiFp(this.configuration).serviceProvidersIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/service-providers/{id} API
     * @param {ServiceProviderUpdateRequest} [serviceProviderUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProvidersApi
     */
    public serviceProvidersIdPut(id: string, serviceProviderUpdateRequest?: ServiceProviderUpdateRequest, options?: RawAxiosRequestConfig) {
        return ServiceProvidersApiFp(this.configuration).serviceProvidersIdPut(id, serviceProviderUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {ServiceProvidersCreateRequest} [serviceProvidersCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServiceProvidersApi
     */
    public serviceProvidersPost(serviceProvidersCreateRequest?: ServiceProvidersCreateRequest, options?: RawAxiosRequestConfig) {
        return ServiceProvidersApiFp(this.configuration).serviceProvidersPost(serviceProvidersCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const ServiceProvidersGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type ServiceProvidersGetSortDirEnum = typeof ServiceProvidersGetSortDirEnum[keyof typeof ServiceProvidersGetSortDirEnum];


/**
 * SubnetpoolsApi - axios parameter creator
 * @export
 */
export const SubnetpoolsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnetpools API
         * @param {string} [name] name query parameter for /v2.0/subnetpools API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultQuota] default_quota query parameter for /v2.0/subnetpools API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultPrefixlen] default_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [minPrefixlen] min_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [maxPrefixlen] max_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnetpools API
         * @param {string | null} [addressScopeId] address_scope_id query parameter for /v2.0/subnetpools API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnetpools API
         * @param {string} [description] description query parameter for /v2.0/subnetpools API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsGet: async (id?: string, name?: string, tenantId?: string, defaultQuota?: string | number, ipVersion?: string, defaultPrefixlen?: string | number, minPrefixlen?: string | number, maxPrefixlen?: string | number, isDefault?: string | boolean, shared?: string | boolean, addressScopeId?: string | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: SubnetpoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnetpools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (defaultQuota !== undefined) {
                for (const [key, value] of Object.entries(defaultQuota)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (ipVersion !== undefined) {
                localVarQueryParameter['ip_version'] = ipVersion;
            }

            if (defaultPrefixlen !== undefined) {
                for (const [key, value] of Object.entries(defaultPrefixlen)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (minPrefixlen !== undefined) {
                for (const [key, value] of Object.entries(minPrefixlen)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (maxPrefixlen !== undefined) {
                for (const [key, value] of Object.entries(maxPrefixlen)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (isDefault !== undefined) {
                for (const [key, value] of Object.entries(isDefault)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (addressScopeId !== undefined) {
                localVarQueryParameter['address_scope_id'] = addressScopeId;
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdAddPrefixesPut: async (id: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdAddPrefixesPut', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}/add_prefixes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdDelete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdDelete', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdGet: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdGet', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdOnboardNetworkSubnetsPut: async (id: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdOnboardNetworkSubnetsPut', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}/onboard_network_subnets`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {SubnetpoolUpdateRequest} [subnetpoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdPut: async (id: string, subnetpoolUpdateRequest?: SubnetpoolUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdPut', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetpoolUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdRemovePrefixesPut: async (id: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsIdRemovePrefixesPut', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{id}/remove_prefixes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubnetpoolsCreateRequest} [subnetpoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsPost: async (subnetpoolsCreateRequest?: SubnetpoolsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnetpools`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetpoolsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsDelete: async (subnetpoolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetpoolId' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsDelete', 'subnetpoolId', subnetpoolId)
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags`
                .replace(`{${"subnetpool_id"}}`, encodeURIComponent(String(subnetpoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsSubnetpoolIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsGet: async (sortKey?: string, sortDir?: SubnetpoolsSubnetpoolIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdDelete: async (subnetpoolId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetpoolId' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdDelete', 'subnetpoolId', subnetpoolId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags/{id}`
                .replace(`{${"subnetpool_id"}}`, encodeURIComponent(String(subnetpoolId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdGet: async (subnetpoolId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetpoolId' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdGet', 'subnetpoolId', subnetpoolId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags/{id}`
                .replace(`{${"subnetpool_id"}}`, encodeURIComponent(String(subnetpoolId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdPut: async (subnetpoolId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetpoolId' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdPut', 'subnetpoolId', subnetpoolId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags/{id}`
                .replace(`{${"subnetpool_id"}}`, encodeURIComponent(String(subnetpoolId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {SubnetpoolsTagsUpdateAllRequest} [subnetpoolsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsPut: async (subnetpoolId: string, subnetpoolsTagsUpdateAllRequest?: SubnetpoolsTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetpoolId' is not null or undefined
            assertParamExists('subnetpoolsSubnetpoolIdTagsPut', 'subnetpoolId', subnetpoolId)
            const localVarPath = `/v2.0/subnetpools/{subnetpool_id}/tags`
                .replace(`{${"subnetpool_id"}}`, encodeURIComponent(String(subnetpoolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetpoolsTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubnetpoolsApi - functional programming interface
 * @export
 */
export const SubnetpoolsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubnetpoolsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnetpools API
         * @param {string} [name] name query parameter for /v2.0/subnetpools API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultQuota] default_quota query parameter for /v2.0/subnetpools API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultPrefixlen] default_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [minPrefixlen] min_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [maxPrefixlen] max_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnetpools API
         * @param {string | null} [addressScopeId] address_scope_id query parameter for /v2.0/subnetpools API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnetpools API
         * @param {string} [description] description query parameter for /v2.0/subnetpools API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsGet(id?: string, name?: string, tenantId?: string, defaultQuota?: string | number, ipVersion?: string, defaultPrefixlen?: string | number, minPrefixlen?: string | number, maxPrefixlen?: string | number, isDefault?: string | boolean, shared?: string | boolean, addressScopeId?: string | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: SubnetpoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsGet(id, name, tenantId, defaultQuota, ipVersion, defaultPrefixlen, minPrefixlen, maxPrefixlen, isDefault, shared, addressScopeId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdAddPrefixesPut(id: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdAddPrefixesPut(id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdAddPrefixesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdDelete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdDelete(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdGet(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdGet(id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdOnboardNetworkSubnetsPut(id: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdOnboardNetworkSubnetsPut(id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdOnboardNetworkSubnetsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {SubnetpoolUpdateRequest} [subnetpoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdPut(id: string, subnetpoolUpdateRequest?: SubnetpoolUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdPut(id, subnetpoolUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsIdRemovePrefixesPut(id: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsIdRemovePrefixesPut(id, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsIdRemovePrefixesPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SubnetpoolsCreateRequest} [subnetpoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsPost(subnetpoolsCreateRequest?: SubnetpoolsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsPost(subnetpoolsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsSubnetpoolIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsGet(sortKey?: string, sortDir?: SubnetpoolsSubnetpoolIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolsTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {SubnetpoolsTagsUpdateAllRequest} [subnetpoolsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetpoolsSubnetpoolIdTagsPut(subnetpoolId: string, subnetpoolsTagsUpdateAllRequest?: SubnetpoolsTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetpoolsTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetpoolsSubnetpoolIdTagsPut(subnetpoolId, subnetpoolsTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetpoolsApi.subnetpoolsSubnetpoolIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SubnetpoolsApi - factory interface
 * @export
 */
export const SubnetpoolsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubnetpoolsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnetpools API
         * @param {string} [name] name query parameter for /v2.0/subnetpools API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultQuota] default_quota query parameter for /v2.0/subnetpools API
         * @param {string} [ipVersion] ip_version query parameter for /v2.0/subnetpools API
         * @param {string | number} [defaultPrefixlen] default_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [minPrefixlen] min_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | number} [maxPrefixlen] max_prefixlen query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/subnetpools API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnetpools API
         * @param {string | null} [addressScopeId] address_scope_id query parameter for /v2.0/subnetpools API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnetpools API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnetpools API
         * @param {string} [description] description query parameter for /v2.0/subnetpools API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsGet(id?: string, name?: string, tenantId?: string, defaultQuota?: string | number, ipVersion?: string, defaultPrefixlen?: string | number, minPrefixlen?: string | number, maxPrefixlen?: string | number, isDefault?: string | boolean, shared?: string | boolean, addressScopeId?: string | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: SubnetpoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SubnetpoolsIndexResponse> {
            return localVarFp.subnetpoolsGet(id, name, tenantId, defaultQuota, ipVersion, defaultPrefixlen, minPrefixlen, maxPrefixlen, isDefault, shared, addressScopeId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdAddPrefixesPut(id: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.subnetpoolsIdAddPrefixesPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdDelete(id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetpoolsIdDelete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdGet(id: string, options?: any): AxiosPromise<SubnetpoolShowResponse> {
            return localVarFp.subnetpoolsIdGet(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdOnboardNetworkSubnetsPut(id: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.subnetpoolsIdOnboardNetworkSubnetsPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {SubnetpoolUpdateRequest} [subnetpoolUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdPut(id: string, subnetpoolUpdateRequest?: SubnetpoolUpdateRequest, options?: any): AxiosPromise<SubnetpoolUpdateResponse> {
            return localVarFp.subnetpoolsIdPut(id, subnetpoolUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsIdRemovePrefixesPut(id: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.subnetpoolsIdRemovePrefixesPut(id, body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubnetpoolsCreateRequest} [subnetpoolsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsPost(subnetpoolsCreateRequest?: SubnetpoolsCreateRequest, options?: any): AxiosPromise<SubnetpoolsCreateResponse> {
            return localVarFp.subnetpoolsPost(subnetpoolsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetpoolsSubnetpoolIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsGet(sortKey?: string, sortDir?: SubnetpoolsSubnetpoolIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SubnetpoolsTagsIndexResponse> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
         * @param {SubnetpoolsTagsUpdateAllRequest} [subnetpoolsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetpoolsSubnetpoolIdTagsPut(subnetpoolId: string, subnetpoolsTagsUpdateAllRequest?: SubnetpoolsTagsUpdateAllRequest, options?: any): AxiosPromise<SubnetpoolsTagsUpdateAllResponse> {
            return localVarFp.subnetpoolsSubnetpoolIdTagsPut(subnetpoolId, subnetpoolsTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubnetpoolsApi - object-oriented interface
 * @export
 * @class SubnetpoolsApi
 * @extends {BaseAPI}
 */
export class SubnetpoolsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/subnetpools API
     * @param {string} [name] name query parameter for /v2.0/subnetpools API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnetpools API
     * @param {string | number} [defaultQuota] default_quota query parameter for /v2.0/subnetpools API
     * @param {string} [ipVersion] ip_version query parameter for /v2.0/subnetpools API
     * @param {string | number} [defaultPrefixlen] default_prefixlen query parameter for /v2.0/subnetpools API
     * @param {string | number} [minPrefixlen] min_prefixlen query parameter for /v2.0/subnetpools API
     * @param {string | number} [maxPrefixlen] max_prefixlen query parameter for /v2.0/subnetpools API
     * @param {string | boolean} [isDefault] is_default query parameter for /v2.0/subnetpools API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/subnetpools API
     * @param {string | null} [addressScopeId] address_scope_id query parameter for /v2.0/subnetpools API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnetpools API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/subnetpools API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnetpools API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnetpools API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnetpools API
     * @param {string} [description] description query parameter for /v2.0/subnetpools API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SubnetpoolsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsGet(id?: string, name?: string, tenantId?: string, defaultQuota?: string | number, ipVersion?: string, defaultPrefixlen?: string | number, minPrefixlen?: string | number, maxPrefixlen?: string | number, isDefault?: string | boolean, shared?: string | boolean, addressScopeId?: string | null, revisionNumber?: string, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, sortKey?: string, sortDir?: SubnetpoolsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsGet(id, name, tenantId, defaultQuota, ipVersion, defaultPrefixlen, minPrefixlen, maxPrefixlen, isDefault, shared, addressScopeId, revisionNumber, tags, tagsAny, notTags, notTagsAny, description, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdAddPrefixesPut(id: string, body?: any, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdAddPrefixesPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdDelete(id: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdDelete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdGet(id: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdGet(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdOnboardNetworkSubnetsPut(id: string, body?: any, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdOnboardNetworkSubnetsPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {SubnetpoolUpdateRequest} [subnetpoolUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdPut(id: string, subnetpoolUpdateRequest?: SubnetpoolUpdateRequest, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdPut(id, subnetpoolUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id id parameter for /v2.0/subnetpools/{id}/remove_prefixes API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsIdRemovePrefixesPut(id: string, body?: any, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsIdRemovePrefixesPut(id, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubnetpoolsCreateRequest} [subnetpoolsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsPost(subnetpoolsCreateRequest?: SubnetpoolsCreateRequest, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsPost(subnetpoolsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsDelete(subnetpoolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SubnetpoolsSubnetpoolIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsGet(sortKey?: string, sortDir?: SubnetpoolsSubnetpoolIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsIdDelete(subnetpoolId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsIdGet(subnetpoolId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsIdPut(subnetpoolId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetpoolId subnetpool_id parameter for /v2.0/subnetpools/{subnetpool_id}/tags/{id} API
     * @param {SubnetpoolsTagsUpdateAllRequest} [subnetpoolsTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetpoolsApi
     */
    public subnetpoolsSubnetpoolIdTagsPut(subnetpoolId: string, subnetpoolsTagsUpdateAllRequest?: SubnetpoolsTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return SubnetpoolsApiFp(this.configuration).subnetpoolsSubnetpoolIdTagsPut(subnetpoolId, subnetpoolsTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SubnetpoolsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SubnetpoolsGetSortDirEnum = typeof SubnetpoolsGetSortDirEnum[keyof typeof SubnetpoolsGetSortDirEnum];
/**
 * @export
 */
export const SubnetpoolsSubnetpoolIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SubnetpoolsSubnetpoolIdTagsGetSortDirEnum = typeof SubnetpoolsSubnetpoolIdTagsGetSortDirEnum[keyof typeof SubnetpoolsSubnetpoolIdTagsGetSortDirEnum];


/**
 * SubnetsApi - axios parameter creator
 * @export
 */
export const SubnetsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnets API
         * @param {string} [name] name query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/subnets API
         * @param {string} [networkId] network_id query parameter for /v2.0/subnets API
         * @param {string | null} [subnetpoolId] subnetpool_id query parameter for /v2.0/subnets API
         * @param {string | null} [cidr] cidr query parameter for /v2.0/subnets API
         * @param {string} [gatewayIp] gateway_ip query parameter for /v2.0/subnets API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnets API
         * @param {string | boolean} [enableDhcp] enable_dhcp query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6RaModeEnum} [ipv6RaMode] ipv6_ra_mode query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6AddressModeEnum} [ipv6AddressMode] ipv6_address_mode query parameter for /v2.0/subnets API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnets API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnets API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/subnets API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnets API
         * @param {string} [description] description query parameter for /v2.0/subnets API
         * @param {string | null} [segmentId] segment_id query parameter for /v2.0/subnets API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsGet: async (id?: string, name?: string, ipVersion?: SubnetsGetIpVersionEnum, networkId?: string, subnetpoolId?: string | null, cidr?: string | null, gatewayIp?: string, tenantId?: string, enableDhcp?: string | boolean, ipv6RaMode?: SubnetsGetIpv6RaModeEnum, ipv6AddressMode?: SubnetsGetIpv6AddressModeEnum, shared?: string | boolean, revisionNumber?: string, routerexternal?: string | boolean, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, segmentId?: string | null, sortKey?: string, sortDir?: SubnetsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (ipVersion !== undefined) {
                localVarQueryParameter['ip_version'] = ipVersion;
            }

            if (networkId !== undefined) {
                localVarQueryParameter['network_id'] = networkId;
            }

            if (subnetpoolId !== undefined) {
                localVarQueryParameter['subnetpool_id'] = subnetpoolId;
            }

            if (cidr !== undefined) {
                localVarQueryParameter['cidr'] = cidr;
            }

            if (gatewayIp !== undefined) {
                localVarQueryParameter['gateway_ip'] = gatewayIp;
            }

            if (tenantId !== undefined) {
                localVarQueryParameter['tenant_id'] = tenantId;
            }

            if (enableDhcp !== undefined) {
                for (const [key, value] of Object.entries(enableDhcp)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (ipv6RaMode !== undefined) {
                localVarQueryParameter['ipv6_ra_mode'] = ipv6RaMode;
            }

            if (ipv6AddressMode !== undefined) {
                localVarQueryParameter['ipv6_address_mode'] = ipv6AddressMode;
            }

            if (shared !== undefined) {
                for (const [key, value] of Object.entries(shared)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (revisionNumber !== undefined) {
                localVarQueryParameter['revision_number'] = revisionNumber;
            }

            if (routerexternal !== undefined) {
                for (const [key, value] of Object.entries(routerexternal)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (tags) {
                localVarQueryParameter['tags'] = tags.join(COLLECTION_FORMATS.csv);
            }

            if (tagsAny) {
                localVarQueryParameter['tags-any'] = tagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (notTags) {
                localVarQueryParameter['not-tags'] = notTags.join(COLLECTION_FORMATS.csv);
            }

            if (notTagsAny) {
                localVarQueryParameter['not-tags-any'] = notTagsAny.join(COLLECTION_FORMATS.csv);
            }

            if (description !== undefined) {
                localVarQueryParameter['description'] = description;
            }

            if (segmentId !== undefined) {
                localVarQueryParameter['segment_id'] = segmentId;
            }

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SubnetsCreateRequest} [subnetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsPost: async (subnetsCreateRequest?: SubnetsCreateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetsCreateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdDelete: async (subnetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdDelete', 'subnetId', subnetId)
            const localVarPath = `/v2.0/subnets/{subnet_id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdGet: async (subnetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdGet', 'subnetId', subnetId)
            const localVarPath = `/v2.0/subnets/{subnet_id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {SubnetUpdateRequest} [subnetUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdPut: async (subnetId: string, subnetUpdateRequest?: SubnetUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdPut', 'subnetId', subnetId)
            const localVarPath = `/v2.0/subnets/{subnet_id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsDelete: async (subnetId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsDelete', 'subnetId', subnetId)
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsSubnetIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsGet: async (sortKey?: string, sortDir?: SubnetsSubnetIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdDelete: async (subnetId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdDelete', 'subnetId', subnetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags/{id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdGet: async (subnetId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdGet', 'subnetId', subnetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags/{id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdPut: async (subnetId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdPut', 'subnetId', subnetId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags/{id}`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {SubnetsTagsUpdateAllRequest} [subnetsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsPut: async (subnetId: string, subnetsTagsUpdateAllRequest?: SubnetsTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'subnetId' is not null or undefined
            assertParamExists('subnetsSubnetIdTagsPut', 'subnetId', subnetId)
            const localVarPath = `/v2.0/subnets/{subnet_id}/tags`
                .replace(`{${"subnet_id"}}`, encodeURIComponent(String(subnetId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(subnetsTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubnetsApi - functional programming interface
 * @export
 */
export const SubnetsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubnetsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnets API
         * @param {string} [name] name query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/subnets API
         * @param {string} [networkId] network_id query parameter for /v2.0/subnets API
         * @param {string | null} [subnetpoolId] subnetpool_id query parameter for /v2.0/subnets API
         * @param {string | null} [cidr] cidr query parameter for /v2.0/subnets API
         * @param {string} [gatewayIp] gateway_ip query parameter for /v2.0/subnets API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnets API
         * @param {string | boolean} [enableDhcp] enable_dhcp query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6RaModeEnum} [ipv6RaMode] ipv6_ra_mode query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6AddressModeEnum} [ipv6AddressMode] ipv6_address_mode query parameter for /v2.0/subnets API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnets API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnets API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/subnets API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnets API
         * @param {string} [description] description query parameter for /v2.0/subnets API
         * @param {string | null} [segmentId] segment_id query parameter for /v2.0/subnets API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsGet(id?: string, name?: string, ipVersion?: SubnetsGetIpVersionEnum, networkId?: string, subnetpoolId?: string | null, cidr?: string | null, gatewayIp?: string, tenantId?: string, enableDhcp?: string | boolean, ipv6RaMode?: SubnetsGetIpv6RaModeEnum, ipv6AddressMode?: SubnetsGetIpv6AddressModeEnum, shared?: string | boolean, revisionNumber?: string, routerexternal?: string | boolean, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, segmentId?: string | null, sortKey?: string, sortDir?: SubnetsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsGet(id, name, ipVersion, networkId, subnetpoolId, cidr, gatewayIp, tenantId, enableDhcp, ipv6RaMode, ipv6AddressMode, shared, revisionNumber, routerexternal, tags, tagsAny, notTags, notTagsAny, description, segmentId, sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {SubnetsCreateRequest} [subnetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsPost(subnetsCreateRequest?: SubnetsCreateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsCreateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsPost(subnetsCreateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdDelete(subnetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdDelete(subnetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdGet(subnetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetShowResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdGet(subnetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {SubnetUpdateRequest} [subnetUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdPut(subnetId: string, subnetUpdateRequest?: SubnetUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetUpdateResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdPut(subnetId, subnetUpdateRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsDelete(subnetId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsDelete(subnetId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsSubnetIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsGet(sortKey?: string, sortDir?: SubnetsSubnetIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsIdDelete(subnetId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsIdDelete(subnetId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsIdGet(subnetId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsIdGet(subnetId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsIdPut(subnetId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsIdPut(subnetId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {SubnetsTagsUpdateAllRequest} [subnetsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async subnetsSubnetIdTagsPut(subnetId: string, subnetsTagsUpdateAllRequest?: SubnetsTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubnetsTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.subnetsSubnetIdTagsPut(subnetId, subnetsTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SubnetsApi.subnetsSubnetIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SubnetsApi - factory interface
 * @export
 */
export const SubnetsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubnetsApiFp(configuration)
    return {
        /**
         * 
         * @param {string} [id] id query parameter for /v2.0/subnets API
         * @param {string} [name] name query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/subnets API
         * @param {string} [networkId] network_id query parameter for /v2.0/subnets API
         * @param {string | null} [subnetpoolId] subnetpool_id query parameter for /v2.0/subnets API
         * @param {string | null} [cidr] cidr query parameter for /v2.0/subnets API
         * @param {string} [gatewayIp] gateway_ip query parameter for /v2.0/subnets API
         * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnets API
         * @param {string | boolean} [enableDhcp] enable_dhcp query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6RaModeEnum} [ipv6RaMode] ipv6_ra_mode query parameter for /v2.0/subnets API
         * @param {SubnetsGetIpv6AddressModeEnum} [ipv6AddressMode] ipv6_address_mode query parameter for /v2.0/subnets API
         * @param {string | boolean} [shared] shared query parameter for /v2.0/subnets API
         * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnets API
         * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/subnets API
         * @param {Array<string>} [tags] tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnets API
         * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnets API
         * @param {string} [description] description query parameter for /v2.0/subnets API
         * @param {string | null} [segmentId] segment_id query parameter for /v2.0/subnets API
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsGet(id?: string, name?: string, ipVersion?: SubnetsGetIpVersionEnum, networkId?: string, subnetpoolId?: string | null, cidr?: string | null, gatewayIp?: string, tenantId?: string, enableDhcp?: string | boolean, ipv6RaMode?: SubnetsGetIpv6RaModeEnum, ipv6AddressMode?: SubnetsGetIpv6AddressModeEnum, shared?: string | boolean, revisionNumber?: string, routerexternal?: string | boolean, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, segmentId?: string | null, sortKey?: string, sortDir?: SubnetsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SubnetsIndexResponse> {
            return localVarFp.subnetsGet(id, name, ipVersion, networkId, subnetpoolId, cidr, gatewayIp, tenantId, enableDhcp, ipv6RaMode, ipv6AddressMode, shared, revisionNumber, routerexternal, tags, tagsAny, notTags, notTagsAny, description, segmentId, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SubnetsCreateRequest} [subnetsCreateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsPost(subnetsCreateRequest?: SubnetsCreateRequest, options?: any): AxiosPromise<SubnetsCreateResponse> {
            return localVarFp.subnetsPost(subnetsCreateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdDelete(subnetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetsSubnetIdDelete(subnetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdGet(subnetId: string, options?: any): AxiosPromise<SubnetShowResponse> {
            return localVarFp.subnetsSubnetIdGet(subnetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
         * @param {SubnetUpdateRequest} [subnetUpdateRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdPut(subnetId: string, subnetUpdateRequest?: SubnetUpdateRequest, options?: any): AxiosPromise<SubnetUpdateResponse> {
            return localVarFp.subnetsSubnetIdPut(subnetId, subnetUpdateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsDelete(subnetId: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetsSubnetIdTagsDelete(subnetId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {SubnetsSubnetIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsGet(sortKey?: string, sortDir?: SubnetsSubnetIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<SubnetsTagsIndexResponse> {
            return localVarFp.subnetsSubnetIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdDelete(subnetId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetsSubnetIdTagsIdDelete(subnetId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdGet(subnetId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetsSubnetIdTagsIdGet(subnetId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsIdPut(subnetId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.subnetsSubnetIdTagsIdPut(subnetId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
         * @param {SubnetsTagsUpdateAllRequest} [subnetsTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        subnetsSubnetIdTagsPut(subnetId: string, subnetsTagsUpdateAllRequest?: SubnetsTagsUpdateAllRequest, options?: any): AxiosPromise<SubnetsTagsUpdateAllResponse> {
            return localVarFp.subnetsSubnetIdTagsPut(subnetId, subnetsTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubnetsApi - object-oriented interface
 * @export
 * @class SubnetsApi
 * @extends {BaseAPI}
 */
export class SubnetsApi extends BaseAPI {
    /**
     * 
     * @param {string} [id] id query parameter for /v2.0/subnets API
     * @param {string} [name] name query parameter for /v2.0/subnets API
     * @param {SubnetsGetIpVersionEnum} [ipVersion] ip_version query parameter for /v2.0/subnets API
     * @param {string} [networkId] network_id query parameter for /v2.0/subnets API
     * @param {string | null} [subnetpoolId] subnetpool_id query parameter for /v2.0/subnets API
     * @param {string | null} [cidr] cidr query parameter for /v2.0/subnets API
     * @param {string} [gatewayIp] gateway_ip query parameter for /v2.0/subnets API
     * @param {string} [tenantId] tenant_id query parameter for /v2.0/subnets API
     * @param {string | boolean} [enableDhcp] enable_dhcp query parameter for /v2.0/subnets API
     * @param {SubnetsGetIpv6RaModeEnum} [ipv6RaMode] ipv6_ra_mode query parameter for /v2.0/subnets API
     * @param {SubnetsGetIpv6AddressModeEnum} [ipv6AddressMode] ipv6_address_mode query parameter for /v2.0/subnets API
     * @param {string | boolean} [shared] shared query parameter for /v2.0/subnets API
     * @param {string} [revisionNumber] revision_number query parameter for /v2.0/subnets API
     * @param {string | boolean} [routerexternal] router:external query parameter for /v2.0/subnets API
     * @param {Array<string>} [tags] tags query parameter for /v2.0/subnets API
     * @param {Array<string>} [tagsAny] tags-any query parameter for /v2.0/subnets API
     * @param {Array<string>} [notTags] not-tags query parameter for /v2.0/subnets API
     * @param {Array<string>} [notTagsAny] not-tags-any query parameter for /v2.0/subnets API
     * @param {string} [description] description query parameter for /v2.0/subnets API
     * @param {string | null} [segmentId] segment_id query parameter for /v2.0/subnets API
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SubnetsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsGet(id?: string, name?: string, ipVersion?: SubnetsGetIpVersionEnum, networkId?: string, subnetpoolId?: string | null, cidr?: string | null, gatewayIp?: string, tenantId?: string, enableDhcp?: string | boolean, ipv6RaMode?: SubnetsGetIpv6RaModeEnum, ipv6AddressMode?: SubnetsGetIpv6AddressModeEnum, shared?: string | boolean, revisionNumber?: string, routerexternal?: string | boolean, tags?: Array<string>, tagsAny?: Array<string>, notTags?: Array<string>, notTagsAny?: Array<string>, description?: string, segmentId?: string | null, sortKey?: string, sortDir?: SubnetsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsGet(id, name, ipVersion, networkId, subnetpoolId, cidr, gatewayIp, tenantId, enableDhcp, ipv6RaMode, ipv6AddressMode, shared, revisionNumber, routerexternal, tags, tagsAny, notTags, notTagsAny, description, segmentId, sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SubnetsCreateRequest} [subnetsCreateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsPost(subnetsCreateRequest?: SubnetsCreateRequest, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsPost(subnetsCreateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdDelete(subnetId: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdDelete(subnetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdGet(subnetId: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdGet(subnetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id} API
     * @param {SubnetUpdateRequest} [subnetUpdateRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdPut(subnetId: string, subnetUpdateRequest?: SubnetUpdateRequest, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdPut(subnetId, subnetUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsDelete(subnetId: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsDelete(subnetId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {SubnetsSubnetIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsGet(sortKey?: string, sortDir?: SubnetsSubnetIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsIdDelete(subnetId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsIdDelete(subnetId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsIdGet(subnetId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsIdGet(subnetId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsIdPut(subnetId: string, id: string, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsIdPut(subnetId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} subnetId subnet_id parameter for /v2.0/subnets/{subnet_id}/tags/{id} API
     * @param {SubnetsTagsUpdateAllRequest} [subnetsTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubnetsApi
     */
    public subnetsSubnetIdTagsPut(subnetId: string, subnetsTagsUpdateAllRequest?: SubnetsTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return SubnetsApiFp(this.configuration).subnetsSubnetIdTagsPut(subnetId, subnetsTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const SubnetsGetIpVersionEnum = {
    _4: '4',
    _6: '6'
} as const;
export type SubnetsGetIpVersionEnum = typeof SubnetsGetIpVersionEnum[keyof typeof SubnetsGetIpVersionEnum];
/**
 * @export
 */
export const SubnetsGetIpv6RaModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;
export type SubnetsGetIpv6RaModeEnum = typeof SubnetsGetIpv6RaModeEnum[keyof typeof SubnetsGetIpv6RaModeEnum];
/**
 * @export
 */
export const SubnetsGetIpv6AddressModeEnum = {
    Dhcpv6Stateful: 'dhcpv6-stateful',
    Dhcpv6Stateless: 'dhcpv6-stateless',
    Slaac: 'slaac'
} as const;
export type SubnetsGetIpv6AddressModeEnum = typeof SubnetsGetIpv6AddressModeEnum[keyof typeof SubnetsGetIpv6AddressModeEnum];
/**
 * @export
 */
export const SubnetsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SubnetsGetSortDirEnum = typeof SubnetsGetSortDirEnum[keyof typeof SubnetsGetSortDirEnum];
/**
 * @export
 */
export const SubnetsSubnetIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type SubnetsSubnetIdTagsGetSortDirEnum = typeof SubnetsSubnetIdTagsGetSortDirEnum[keyof typeof SubnetsSubnetIdTagsGetSortDirEnum];


/**
 * TrunksApi - axios parameter creator
 * @export
 */
export const TrunksApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsDelete: async (trunkId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunkId' is not null or undefined
            assertParamExists('trunksTrunkIdTagsDelete', 'trunkId', trunkId)
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags`
                .replace(`{${"trunk_id"}}`, encodeURIComponent(String(trunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {TrunksTrunkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsGet: async (sortKey?: string, sortDir?: TrunksTrunkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (sortKey !== undefined) {
                localVarQueryParameter['sort_key'] = sortKey;
            }

            if (sortDir !== undefined) {
                localVarQueryParameter['sort_dir'] = sortDir;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (marker !== undefined) {
                localVarQueryParameter['marker'] = marker;
            }

            if (pageReverse !== undefined) {
                localVarQueryParameter['page_reverse'] = pageReverse;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdDelete: async (trunkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunkId' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdDelete', 'trunkId', trunkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdDelete', 'id', id)
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags/{id}`
                .replace(`{${"trunk_id"}}`, encodeURIComponent(String(trunkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdGet: async (trunkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunkId' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdGet', 'trunkId', trunkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdGet', 'id', id)
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags/{id}`
                .replace(`{${"trunk_id"}}`, encodeURIComponent(String(trunkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdPut: async (trunkId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunkId' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdPut', 'trunkId', trunkId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('trunksTrunkIdTagsIdPut', 'id', id)
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags/{id}`
                .replace(`{${"trunk_id"}}`, encodeURIComponent(String(trunkId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {TrunksTagsUpdateAllRequest} [trunksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsPut: async (trunkId: string, trunksTagsUpdateAllRequest?: TrunksTagsUpdateAllRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trunkId' is not null or undefined
            assertParamExists('trunksTrunkIdTagsPut', 'trunkId', trunkId)
            const localVarPath = `/v2.0/trunks/{trunk_id}/tags`
                .replace(`{${"trunk_id"}}`, encodeURIComponent(String(trunkId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(trunksTagsUpdateAllRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TrunksApi - functional programming interface
 * @export
 */
export const TrunksApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TrunksApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsDelete(trunkId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsDelete(trunkId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {TrunksTrunkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsGet(sortKey?: string, sortDir?: TrunksTrunkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrunksTagsIndexResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsIdDelete(trunkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsIdDelete(trunkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsIdGet(trunkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsIdGet(trunkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsIdPut(trunkId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsIdPut(trunkId, id, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {TrunksTagsUpdateAllRequest} [trunksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async trunksTrunkIdTagsPut(trunkId: string, trunksTagsUpdateAllRequest?: TrunksTagsUpdateAllRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TrunksTagsUpdateAllResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.trunksTrunkIdTagsPut(trunkId, trunksTagsUpdateAllRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['TrunksApi.trunksTrunkIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * TrunksApi - factory interface
 * @export
 */
export const TrunksApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TrunksApiFp(configuration)
    return {
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsDelete(trunkId: string, options?: any): AxiosPromise<void> {
            return localVarFp.trunksTrunkIdTagsDelete(trunkId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
         * @param {TrunksTrunkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
         * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
         * @param {boolean} [pageReverse] Reverse the page direction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsGet(sortKey?: string, sortDir?: TrunksTrunkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: any): AxiosPromise<TrunksTagsIndexResponse> {
            return localVarFp.trunksTrunkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdDelete(trunkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trunksTrunkIdTagsIdDelete(trunkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdGet(trunkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trunksTrunkIdTagsIdGet(trunkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsIdPut(trunkId: string, id: string, options?: any): AxiosPromise<void> {
            return localVarFp.trunksTrunkIdTagsIdPut(trunkId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
         * @param {TrunksTagsUpdateAllRequest} [trunksTagsUpdateAllRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trunksTrunkIdTagsPut(trunkId: string, trunksTagsUpdateAllRequest?: TrunksTagsUpdateAllRequest, options?: any): AxiosPromise<TrunksTagsUpdateAllResponse> {
            return localVarFp.trunksTrunkIdTagsPut(trunkId, trunksTagsUpdateAllRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TrunksApi - object-oriented interface
 * @export
 * @class TrunksApi
 * @extends {BaseAPI}
 */
export class TrunksApi extends BaseAPI {
    /**
     * 
     * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsDelete(trunkId: string, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsDelete(trunkId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} [sortKey] Sort results by the attribute. This is an optional feature and may be silently ignored by the server.
     * @param {TrunksTrunkIdTagsGetSortDirEnum} [sortDir] Sort direction. This is an optional feature and may be silently ignored by the server.
     * @param {number} [limit] Requests a page size of items. Returns a number of items up to a limit value. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {string} [marker] The ID of the last-seen item. Use the limit parameter to make an initial limited request and use the ID of the last-seen item from the response as the marker parameter value in a subsequent limited request.
     * @param {boolean} [pageReverse] Reverse the page direction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsGet(sortKey?: string, sortDir?: TrunksTrunkIdTagsGetSortDirEnum, limit?: number, marker?: string, pageReverse?: boolean, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsGet(sortKey, sortDir, limit, marker, pageReverse, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsIdDelete(trunkId: string, id: string, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsIdDelete(trunkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsIdGet(trunkId: string, id: string, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsIdGet(trunkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {string} id id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsIdPut(trunkId: string, id: string, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsIdPut(trunkId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} trunkId trunk_id parameter for /v2.0/trunks/{trunk_id}/tags/{id} API
     * @param {TrunksTagsUpdateAllRequest} [trunksTagsUpdateAllRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TrunksApi
     */
    public trunksTrunkIdTagsPut(trunkId: string, trunksTagsUpdateAllRequest?: TrunksTagsUpdateAllRequest, options?: RawAxiosRequestConfig) {
        return TrunksApiFp(this.configuration).trunksTrunkIdTagsPut(trunkId, trunksTagsUpdateAllRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const TrunksTrunkIdTagsGetSortDirEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type TrunksTrunkIdTagsGetSortDirEnum = typeof TrunksTrunkIdTagsGetSortDirEnum[keyof typeof TrunksTrunkIdTagsGetSortDirEnum];


