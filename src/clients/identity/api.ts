/* tslint:disable */
/* eslint-disable */
/**
 * OpenStack Identity API
 * Identity API provided by Keystone service
 *
 * The version of the OpenAPI document: 3.14
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AuthCatalogGetResponse
 */
export interface AuthCatalogGetResponse {
    /**
     * 
     * @type {Array<AuthCatalogGetResponseCatalogInner>}
     * @memberof AuthCatalogGetResponse
     */
    'catalog'?: Array<AuthCatalogGetResponseCatalogInner>;
}
/**
 * 
 * @export
 * @interface AuthCatalogGetResponseCatalogInner
 */
export interface AuthCatalogGetResponseCatalogInner {
    /**
     * 
     * @type {Array<AuthCatalogGetResponseCatalogInnerEndpointsInner>}
     * @memberof AuthCatalogGetResponseCatalogInner
     */
    'endpoints'?: Array<AuthCatalogGetResponseCatalogInnerEndpointsInner>;
    /**
     * The UUID of the service to which the endpoint belongs.
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInner
     */
    'id'?: string;
    /**
     * The service type, which describes the API implemented by the service
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInner
     */
    'type'?: string;
    /**
     * The service name.
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInner
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuthCatalogGetResponseCatalogInnerEndpointsInner
 */
export interface AuthCatalogGetResponseCatalogInnerEndpointsInner {
    /**
     * The endpoint UUID
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInnerEndpointsInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInnerEndpointsInner
     */
    'interface'?: AuthCatalogGetResponseCatalogInnerEndpointsInnerInterfaceEnum;
    /**
     * Region name of the endpoint
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInnerEndpointsInner
     */
    'region'?: string;
    /**
     * The endpoint url
     * @type {string}
     * @memberof AuthCatalogGetResponseCatalogInnerEndpointsInner
     */
    'url'?: string;
}

export const AuthCatalogGetResponseCatalogInnerEndpointsInnerInterfaceEnum = {
    Public: 'public',
    Internal: 'internal',
    Admin: 'admin'
} as const;

export type AuthCatalogGetResponseCatalogInnerEndpointsInnerInterfaceEnum = typeof AuthCatalogGetResponseCatalogInnerEndpointsInnerInterfaceEnum[keyof typeof AuthCatalogGetResponseCatalogInnerEndpointsInnerInterfaceEnum];

/**
 * 
 * @export
 * @interface AuthDomainsGetResponse
 */
export interface AuthDomainsGetResponse {
    /**
     * 
     * @type {Array<AuthDomainsGetResponseDomainsInner>}
     * @memberof AuthDomainsGetResponse
     */
    'domains'?: Array<AuthDomainsGetResponseDomainsInner>;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof AuthDomainsGetResponse
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface AuthDomainsGetResponseDomainsInner
 */
export interface AuthDomainsGetResponseDomainsInner {
    /**
     * The ID of the domain.
     * @type {string}
     * @memberof AuthDomainsGetResponseDomainsInner
     */
    'id'?: string;
    /**
     * The name of the domain
     * @type {string}
     * @memberof AuthDomainsGetResponseDomainsInner
     */
    'name'?: string;
    /**
     * The description of the domain.
     * @type {string}
     * @memberof AuthDomainsGetResponseDomainsInner
     */
    'description'?: string;
    /**
     * If set to true, domain is enabled. If set to false, domain is disabled.
     * @type {boolean}
     * @memberof AuthDomainsGetResponseDomainsInner
     */
    'enabled'?: boolean;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof AuthDomainsGetResponseDomainsInner
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface AuthOsFederationIdentityProvidersProtocolsWebssoGetResponse
 */
export interface AuthOsFederationIdentityProvidersProtocolsWebssoGetResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof AuthOsFederationIdentityProvidersProtocolsWebssoGetResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface AuthOsFederationIdentityProvidersProtocolsWebssoPostResponse
 */
export interface AuthOsFederationIdentityProvidersProtocolsWebssoPostResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof AuthOsFederationIdentityProvidersProtocolsWebssoPostResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface AuthOsFederationSaml2EcpPostRequest
 */
export interface AuthOsFederationSaml2EcpPostRequest {
    /**
     * 
     * @type {AuthTokensPostRequestAuth}
     * @memberof AuthOsFederationSaml2EcpPostRequest
     */
    'auth'?: AuthTokensPostRequestAuth;
}
/**
 * 
 * @export
 * @interface AuthOsFederationSaml2PostRequest
 */
export interface AuthOsFederationSaml2PostRequest {
    /**
     * 
     * @type {AuthTokensPostRequestAuth}
     * @memberof AuthOsFederationSaml2PostRequest
     */
    'auth'?: AuthTokensPostRequestAuth;
}
/**
 * 
 * @export
 * @interface AuthOsFederationWebssoGetResponse
 */
export interface AuthOsFederationWebssoGetResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof AuthOsFederationWebssoGetResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface AuthOsFederationWebssoGetResponseToken
 */
export interface AuthOsFederationWebssoGetResponseToken {
    /**
     * A list of one or two audit IDs. An audit ID is a unique, randomly generated, URL-safe string that you can use to track a token. The first audit ID is the current audit ID for the token. The second audit ID is present for only re-scoped tokens and is the audit ID from the token before it was re-scoped. A re- scoped token is one that was exchanged for another token of the same or different scope. You can use these audit IDs to track the use of a token or chain of tokens across multiple requests and endpoints without exposing the token ID to non-privileged users.
     * @type {Array<string>}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'audit_ids'?: Array<string>;
    /**
     * A catalog object.
     * @type {Array<AuthCatalogGetResponseCatalogInner>}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'catalog'?: Array<AuthCatalogGetResponseCatalogInner>;
    /**
     * The date and time when the token expires.
     * @type {string}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'expires_at'?: string;
    /**
     * The date and time when the token was issued.
     * @type {string}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'issues_at'?: string;
    /**
     * The authentication methods, which are commonly password, token, or other methods. Indicates the accumulated set of authentication methods that were used to obtain the token. For example, if the token was obtained by password authentication, it contains password. Later, if the token is exchanged by using the token authentication method one or more times, the subsequently created tokens contain both password and token in their methods attribute. Unlike multi-factor authentication, the methods attribute merely indicates the methods that were used to authenticate the user in exchange for a token. The client is responsible for determining the total number of authentication factors.
     * @type {Array<string>}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {AuthTokensGetResponseTokenUser}
     * @memberof AuthOsFederationWebssoGetResponseToken
     */
    'user'?: AuthTokensGetResponseTokenUser;
}
/**
 * 
 * @export
 * @interface AuthOsFederationWebssoPostResponse
 */
export interface AuthOsFederationWebssoPostResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof AuthOsFederationWebssoPostResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface AuthProjectsGetResponse
 */
export interface AuthProjectsGetResponse {
    /**
     * 
     * @type {Array<AuthProjectsGetResponseProjectsInner>}
     * @memberof AuthProjectsGetResponse
     */
    'projects'?: Array<AuthProjectsGetResponseProjectsInner>;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof AuthProjectsGetResponse
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface AuthProjectsGetResponseProjectsInner
 */
export interface AuthProjectsGetResponseProjectsInner {
    /**
     * The ID of the domain for the project.
     * @type {string}
     * @memberof AuthProjectsGetResponseProjectsInner
     */
    'domain_id'?: string;
    /**
     * The ID of the project.
     * @type {string}
     * @memberof AuthProjectsGetResponseProjectsInner
     */
    'id'?: string;
    /**
     * The name of the project
     * @type {string}
     * @memberof AuthProjectsGetResponseProjectsInner
     */
    'name'?: string;
    /**
     * If set to true, project is enabled. If set to false, project is disabled.
     * @type {boolean}
     * @memberof AuthProjectsGetResponseProjectsInner
     */
    'enabled'?: boolean;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof AuthProjectsGetResponseProjectsInner
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
 * @export
 * @interface AuthProjectsGetResponseProjectsInnerLinksInner
 */
export interface AuthProjectsGetResponseProjectsInnerLinksInner {
    /**
     * 
     * @type {string}
     * @memberof AuthProjectsGetResponseProjectsInnerLinksInner
     */
    'href'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthProjectsGetResponseProjectsInnerLinksInner
     */
    'rel'?: string;
}
/**
 * 
 * @export
 * @interface AuthReceiptSchema
 */
export interface AuthReceiptSchema {
    /**
     * 
     * @type {AuthReceiptSchemaReceipt}
     * @memberof AuthReceiptSchema
     */
    'receipt'?: AuthReceiptSchemaReceipt;
    /**
     * A list of authentication rules that may be used with the auth receipt to complete the authentication process.
     * @type {Array<string>}
     * @memberof AuthReceiptSchema
     */
    'required_auth_methods'?: Array<string>;
}
/**
 * 
 * @export
 * @interface AuthReceiptSchemaReceipt
 */
export interface AuthReceiptSchemaReceipt {
    /**
     * The date and time when the token expires.
     * @type {string}
     * @memberof AuthReceiptSchemaReceipt
     */
    'expires_at'?: string;
    /**
     * The date and time when the token was issued.
     * @type {string}
     * @memberof AuthReceiptSchemaReceipt
     */
    'issues_at'?: string;
    /**
     * The authentication methods, which are commonly password, token, or other methods. Indicates the accumulated set of authentication methods that were used to obtain the token. For example, if the token was obtained by password authentication, it contains password. Later, if the token is exchanged by using the token authentication method one or more times, the subsequently created tokens contain both password and token in their methods attribute. Unlike multi-factor authentication, the methods attribute merely indicates the methods that were used to authenticate the user in exchange for a token. The client is responsible for determining the total number of authentication factors.
     * @type {Array<string>}
     * @memberof AuthReceiptSchemaReceipt
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {AuthTokensGetResponseTokenUser}
     * @memberof AuthReceiptSchemaReceipt
     */
    'user'?: AuthTokensGetResponseTokenUser;
}
/**
 * 
 * @export
 * @interface AuthSystemGetResponse
 */
export interface AuthSystemGetResponse {
    /**
     * A list of systems to access based on role assignments.
     * @type {Array<{ [key: string]: boolean; }>}
     * @memberof AuthSystemGetResponse
     */
    'system'?: Array<{ [key: string]: boolean; }>;
}
/**
 * 
 * @export
 * @interface AuthTokensGetResponse
 */
export interface AuthTokensGetResponse {
    /**
     * 
     * @type {AuthTokensGetResponseToken}
     * @memberof AuthTokensGetResponse
     */
    'token'?: AuthTokensGetResponseToken;
}
/**
 * 
 * @export
 * @interface AuthTokensGetResponseToken
 */
export interface AuthTokensGetResponseToken {
    /**
     * A list of one or two audit IDs. An audit ID is a unique, randomly generated, URL-safe string that you can use to track a token. The first audit ID is the current audit ID for the token. The second audit ID is present for only re-scoped tokens and is the audit ID from the token before it was re-scoped. A re- scoped token is one that was exchanged for another token of the same or different scope. You can use these audit IDs to track the use of a token or chain of tokens across multiple requests and endpoints without exposing the token ID to non-privileged users.
     * @type {Array<string>}
     * @memberof AuthTokensGetResponseToken
     */
    'audit_ids'?: Array<string>;
    /**
     * A catalog object.
     * @type {Array<AuthCatalogGetResponseCatalogInner>}
     * @memberof AuthTokensGetResponseToken
     */
    'catalog'?: Array<AuthCatalogGetResponseCatalogInner>;
    /**
     * The date and time when the token expires.
     * @type {string}
     * @memberof AuthTokensGetResponseToken
     */
    'expires_at'?: string;
    /**
     * The date and time when the token was issued.
     * @type {string}
     * @memberof AuthTokensGetResponseToken
     */
    'issues_at'?: string;
    /**
     * The authentication methods, which are commonly password, token, or other methods. Indicates the accumulated set of authentication methods that were used to obtain the token. For example, if the token was obtained by password authentication, it contains password. Later, if the token is exchanged by using the token authentication method one or more times, the subsequently created tokens contain both password and token in their methods attribute. Unlike multi-factor authentication, the methods attribute merely indicates the methods that were used to authenticate the user in exchange for a token. The client is responsible for determining the total number of authentication factors.
     * @type {Array<string>}
     * @memberof AuthTokensGetResponseToken
     */
    'methods'?: Array<string>;
    /**
     * 
     * @type {AuthTokensGetResponseTokenUser}
     * @memberof AuthTokensGetResponseToken
     */
    'user'?: AuthTokensGetResponseTokenUser;
    /**
     * 
     * @type {boolean}
     * @memberof AuthTokensGetResponseToken
     */
    'is_domain'?: boolean;
    /**
     * 
     * @type {AuthTokensGetResponseTokenDomain}
     * @memberof AuthTokensGetResponseToken
     */
    'domain'?: AuthTokensGetResponseTokenDomain;
    /**
     * 
     * @type {AuthTokensGetResponseTokenProject}
     * @memberof AuthTokensGetResponseToken
     */
    'project'?: AuthTokensGetResponseTokenProject;
    /**
     * A list of role objects
     * @type {Array<AuthTokensGetResponseTokenRolesInner>}
     * @memberof AuthTokensGetResponseToken
     */
    'roles'?: Array<AuthTokensGetResponseTokenRolesInner>;
    /**
     * A system object containing information about which parts of the system the token is scoped to. If the token is scoped to the entire deployment system, the system object will consist of {\"all\": true}. This is only included in tokens that are scoped to the system.
     * @type {{ [key: string]: boolean; }}
     * @memberof AuthTokensGetResponseToken
     */
    'system'?: { [key: string]: boolean; };
}
/**
 * A domain object including the id and name representing the domain the token is scoped to. This is only included in tokens that are scoped to a domain.
 * @export
 * @interface AuthTokensGetResponseTokenDomain
 */
export interface AuthTokensGetResponseTokenDomain {
    /**
     * A domain UUID
     * @type {string}
     * @memberof AuthTokensGetResponseTokenDomain
     */
    'id'?: string;
    /**
     * A domain name
     * @type {string}
     * @memberof AuthTokensGetResponseTokenDomain
     */
    'name'?: string;
}
/**
 * A project object including the id, name and domain object representing the project the token is scoped to. This is only included in tokens that are scoped to a project.
 * @export
 * @interface AuthTokensGetResponseTokenProject
 */
export interface AuthTokensGetResponseTokenProject {
    /**
     * A user domain UUID
     * @type {string}
     * @memberof AuthTokensGetResponseTokenProject
     */
    'id'?: string;
    /**
     * A user domain name
     * @type {string}
     * @memberof AuthTokensGetResponseTokenProject
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokensGetResponseTokenRolesInner
 */
export interface AuthTokensGetResponseTokenRolesInner {
    /**
     * A role UUID
     * @type {string}
     * @memberof AuthTokensGetResponseTokenRolesInner
     */
    'id'?: string;
    /**
     * A role name
     * @type {string}
     * @memberof AuthTokensGetResponseTokenRolesInner
     */
    'name'?: string;
}
/**
 * A user object
 * @export
 * @interface AuthTokensGetResponseTokenUser
 */
export interface AuthTokensGetResponseTokenUser {
    /**
     * A user UUID
     * @type {string}
     * @memberof AuthTokensGetResponseTokenUser
     */
    'id'?: string;
    /**
     * A user name
     * @type {string}
     * @memberof AuthTokensGetResponseTokenUser
     */
    'name'?: string;
    /**
     * 
     * @type {AuthTokensGetResponseTokenUserDomain}
     * @memberof AuthTokensGetResponseTokenUser
     */
    'domain'?: AuthTokensGetResponseTokenUserDomain;
    /**
     * DateTime of the user password expiration
     * @type {string}
     * @memberof AuthTokensGetResponseTokenUser
     */
    'password_expires_at'?: string;
    /**
     * 
     * @type {object}
     * @memberof AuthTokensGetResponseTokenUser
     */
    'OS-FEDERATION'?: object;
}
/**
 * 
 * @export
 * @interface AuthTokensGetResponseTokenUserDomain
 */
export interface AuthTokensGetResponseTokenUserDomain {
    /**
     * A user domain UUID
     * @type {string}
     * @memberof AuthTokensGetResponseTokenUserDomain
     */
    'id'?: string;
    /**
     * A user domain name
     * @type {string}
     * @memberof AuthTokensGetResponseTokenUserDomain
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequest
 */
export interface AuthTokensPostRequest {
    /**
     * 
     * @type {AuthTokensPostRequestAuth}
     * @memberof AuthTokensPostRequest
     */
    'auth'?: AuthTokensPostRequestAuth;
}
/**
 * An auth object.
 * @export
 * @interface AuthTokensPostRequestAuth
 */
export interface AuthTokensPostRequestAuth {
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentity}
     * @memberof AuthTokensPostRequestAuth
     */
    'identity': AuthTokensPostRequestAuthIdentity;
    /**
     * 
     * @type {AuthTokensPostRequestAuthScope}
     * @memberof AuthTokensPostRequestAuth
     */
    'scope'?: AuthTokensPostRequestAuthScope;
}
/**
 * An identity object.
 * @export
 * @interface AuthTokensPostRequestAuthIdentity
 */
export interface AuthTokensPostRequestAuthIdentity {
    /**
     * The authentication method.
     * @type {Array<string>}
     * @memberof AuthTokensPostRequestAuthIdentity
     */
    'methods': Array<AuthTokensPostRequestAuthIdentityMethodsEnum>;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityPassword}
     * @memberof AuthTokensPostRequestAuthIdentity
     */
    'password'?: AuthTokensPostRequestAuthIdentityPassword;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityToken}
     * @memberof AuthTokensPostRequestAuthIdentity
     */
    'token'?: AuthTokensPostRequestAuthIdentityToken;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityTotp}
     * @memberof AuthTokensPostRequestAuthIdentity
     */
    'totp'?: AuthTokensPostRequestAuthIdentityTotp;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityApplicationCredential}
     * @memberof AuthTokensPostRequestAuthIdentity
     */
    'application_credential'?: AuthTokensPostRequestAuthIdentityApplicationCredential;
}

export const AuthTokensPostRequestAuthIdentityMethodsEnum = {
    Password: 'password',
    Token: 'token',
    Totp: 'totp',
    ApplicationCredential: 'application_credential'
} as const;

export type AuthTokensPostRequestAuthIdentityMethodsEnum = typeof AuthTokensPostRequestAuthIdentityMethodsEnum[keyof typeof AuthTokensPostRequestAuthIdentityMethodsEnum];

/**
 * An application credential object.
 * @export
 * @interface AuthTokensPostRequestAuthIdentityApplicationCredential
 */
export interface AuthTokensPostRequestAuthIdentityApplicationCredential {
    /**
     * 
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredential
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredential
     */
    'name'?: string;
    /**
     * The secret for authenticating the application credential.
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredential
     */
    'secret': string;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityApplicationCredentialUser}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredential
     */
    'user'?: AuthTokensPostRequestAuthIdentityApplicationCredentialUser;
}
/**
 * A user object, required if an application credential is identified by name and not ID.
 * @export
 * @interface AuthTokensPostRequestAuthIdentityApplicationCredentialUser
 */
export interface AuthTokensPostRequestAuthIdentityApplicationCredentialUser {
    /**
     * The user ID
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredentialUser
     */
    'id'?: string;
    /**
     * The user name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredentialUser
     */
    'name'?: string;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityPasswordUserDomain}
     * @memberof AuthTokensPostRequestAuthIdentityApplicationCredentialUser
     */
    'domain'?: AuthTokensPostRequestAuthIdentityPasswordUserDomain;
}
/**
 * The password object, contains the authentication information.
 * @export
 * @interface AuthTokensPostRequestAuthIdentityPassword
 */
export interface AuthTokensPostRequestAuthIdentityPassword {
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityPasswordUser}
     * @memberof AuthTokensPostRequestAuthIdentityPassword
     */
    'user'?: AuthTokensPostRequestAuthIdentityPasswordUser;
}
/**
 * A `user` object
 * @export
 * @interface AuthTokensPostRequestAuthIdentityPasswordUser
 */
export interface AuthTokensPostRequestAuthIdentityPasswordUser {
    /**
     * User ID
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUser
     */
    'id'?: string;
    /**
     * User Name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUser
     */
    'name'?: string;
    /**
     * User Password
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUser
     */
    'password'?: string;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityPasswordUserDomain}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUser
     */
    'domain'?: AuthTokensPostRequestAuthIdentityPasswordUserDomain;
}
/**
 * User Domain object
 * @export
 * @interface AuthTokensPostRequestAuthIdentityPasswordUserDomain
 */
export interface AuthTokensPostRequestAuthIdentityPasswordUserDomain {
    /**
     * User Domain ID
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUserDomain
     */
    'id'?: string;
    /**
     * User Domain Name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityPasswordUserDomain
     */
    'name'?: string;
}
/**
 * A `token` object
 * @export
 * @interface AuthTokensPostRequestAuthIdentityToken
 */
export interface AuthTokensPostRequestAuthIdentityToken {
    /**
     * Authorization Token value
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityToken
     */
    'id': string;
}
/**
 * Multi Factor Authentication information
 * @export
 * @interface AuthTokensPostRequestAuthIdentityTotp
 */
export interface AuthTokensPostRequestAuthIdentityTotp {
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityTotpUser}
     * @memberof AuthTokensPostRequestAuthIdentityTotp
     */
    'user': AuthTokensPostRequestAuthIdentityTotpUser;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthIdentityTotpUser
 */
export interface AuthTokensPostRequestAuthIdentityTotpUser {
    /**
     * The user ID
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityTotpUser
     */
    'id'?: string;
    /**
     * The user name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityTotpUser
     */
    'name'?: string;
    /**
     * 
     * @type {AuthTokensPostRequestAuthIdentityPasswordUserDomain}
     * @memberof AuthTokensPostRequestAuthIdentityTotpUser
     */
    'domain'?: AuthTokensPostRequestAuthIdentityPasswordUserDomain;
    /**
     * MFA passcode
     * @type {string}
     * @memberof AuthTokensPostRequestAuthIdentityTotpUser
     */
    'passcode': string;
}
/**
 * The authorization scope, including the system (Since v3.10), a project, or a domain (Since v3.4). If multiple scopes are specified in the same request (e.g. project and domain or domain and system) an HTTP 400 Bad Request will be returned, as a token cannot be simultaneously scoped to multiple authorization targets. An ID is sufficient to uniquely identify a project but if a project is specified by name, then the domain of the project must also be specified in order to uniquely identify the project by name. A domain scope may be specified by either the domain’s ID or name with equivalent results.
 * @export
 * @interface AuthTokensPostRequestAuthScope
 */
export interface AuthTokensPostRequestAuthScope {
    /**
     * 
     * @type {AuthTokensPostRequestAuthScopeProject}
     * @memberof AuthTokensPostRequestAuthScope
     */
    'project'?: AuthTokensPostRequestAuthScopeProject;
    /**
     * 
     * @type {AuthTokensPostRequestAuthScopeDomain}
     * @memberof AuthTokensPostRequestAuthScope
     */
    'domain'?: AuthTokensPostRequestAuthScopeDomain;
    /**
     * 
     * @type {AuthTokensPostRequestAuthScopeOSTRUSTTrust}
     * @memberof AuthTokensPostRequestAuthScope
     */
    'OS-TRUST:trust'?: AuthTokensPostRequestAuthScopeOSTRUSTTrust;
    /**
     * 
     * @type {AuthTokensPostRequestAuthScopeSystem}
     * @memberof AuthTokensPostRequestAuthScope
     */
    'system'?: AuthTokensPostRequestAuthScopeSystem;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthScopeDomain
 */
export interface AuthTokensPostRequestAuthScopeDomain {
    /**
     * Domain id
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeDomain
     */
    'id'?: string;
    /**
     * Domain name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeDomain
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthScopeOSTRUSTTrust
 */
export interface AuthTokensPostRequestAuthScopeOSTRUSTTrust {
    /**
     * 
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeOSTRUSTTrust
     */
    'id'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthScopeProject
 */
export interface AuthTokensPostRequestAuthScopeProject {
    /**
     * Project Name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeProject
     */
    'name'?: string;
    /**
     * Project Id
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeProject
     */
    'id'?: string;
    /**
     * 
     * @type {AuthTokensPostRequestAuthScopeProjectDomain}
     * @memberof AuthTokensPostRequestAuthScopeProject
     */
    'domain'?: AuthTokensPostRequestAuthScopeProjectDomain;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthScopeProjectDomain
 */
export interface AuthTokensPostRequestAuthScopeProjectDomain {
    /**
     * Project domain Id
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeProjectDomain
     */
    'id'?: string;
    /**
     * Project domain Name
     * @type {string}
     * @memberof AuthTokensPostRequestAuthScopeProjectDomain
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface AuthTokensPostRequestAuthScopeSystem
 */
export interface AuthTokensPostRequestAuthScopeSystem {
    /**
     * 
     * @type {boolean}
     * @memberof AuthTokensPostRequestAuthScopeSystem
     */
    'all'?: boolean;
}
/**
 * 
 * @export
 * @interface AuthTokensPostResponse
 */
export interface AuthTokensPostResponse {
    /**
     * 
     * @type {AuthTokensGetResponseToken}
     * @memberof AuthTokensPostResponse
     */
    'token'?: AuthTokensGetResponseToken;
}
/**
 * 
 * @export
 * @interface Domain
 */
export interface Domain {
    /**
     * 
     * @type {DomainDomain}
     * @memberof Domain
     */
    'domain'?: DomainDomain;
}
/**
 * 
 * @export
 * @interface DomainConfig
 */
export interface DomainConfig {
    /**
     * A config object.
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof DomainConfig
     */
    'config'?: { [key: string]: { [key: string]: any; }; };
}
/**
 * 
 * @export
 * @interface DomainConfigGroup
 */
export interface DomainConfigGroup {
    /**
     * A config object.
     * @type {{ [key: string]: { [key: string]: any; }; }}
     * @memberof DomainConfigGroup
     */
    'config'?: { [key: string]: { [key: string]: any; }; };
}
/**
 * 
 * @export
 * @interface DomainConfigGroupOption
 */
export interface DomainConfigGroupOption {
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof DomainConfigGroupOption
     */
    'config'?: { [key: string]: any; };
}
/**
 * A domain object
 * @export
 * @interface DomainDomain
 */
export interface DomainDomain {
    /**
     * 
     * @type {string}
     * @memberof DomainDomain
     */
    'id'?: string;
    /**
     * The name of the domain.
     * @type {string}
     * @memberof DomainDomain
     */
    'name'?: string;
    /**
     * The description of the domain.
     * @type {string}
     * @memberof DomainDomain
     */
    'description'?: string;
    /**
     * If set to true, domain is enabled. If set to false, domain is disabled.
     * @type {boolean}
     * @memberof DomainDomain
     */
    'enabled'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof DomainDomain
     */
    'tags'?: Array<string>;
    /**
     * The resource options for the domain. Available resource options are immutable.
     * @type {object}
     * @memberof DomainDomain
     */
    'options'?: object;
}
/**
 * 
 * @export
 * @interface DomainsGetResponse
 */
export interface DomainsGetResponse {
    /**
     * 
     * @type {Array<DomainDomain>}
     * @memberof DomainsGetResponse
     */
    'domains'?: Array<DomainDomain>;
}
/**
 * 
 * @export
 * @interface Endpoint
 */
export interface Endpoint {
    /**
     * 
     * @type {EndpointEndpoint}
     * @memberof Endpoint
     */
    'endpoint'?: EndpointEndpoint;
}
/**
 * 
 * @export
 * @interface EndpointEndpoint
 */
export interface EndpointEndpoint {
    /**
     * Defines whether the service and its endpoints appear in the service catalog.
     * @type {boolean}
     * @memberof EndpointEndpoint
     */
    'enabled'?: boolean;
    /**
     * The UUID of the service to which the endpoint belongs.
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'id'?: string;
    /**
     * The interface type, which describes the visibility of the  Value is: - public. Visible by end users on a publicly available network interface. - internal. Visible by end users on an unmetered internal network interface. - admin. Visible by administrative users on a secure network interface.
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'interface'?: EndpointEndpointInterfaceEnum;
    /**
     * The geographic location of the service endpoint.
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'region'?: string;
    /**
     * The geographic location of the service 
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'region_id'?: string;
    /**
     * The UUID of the service to which the endpoint belongs.
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'service_id'?: string;
    /**
     * The endpoint URL.
     * @type {string}
     * @memberof EndpointEndpoint
     */
    'url'?: string;
}

export const EndpointEndpointInterfaceEnum = {
    Internal: 'internal',
    Admin: 'admin',
    Public: 'public'
} as const;

export type EndpointEndpointInterfaceEnum = typeof EndpointEndpointInterfaceEnum[keyof typeof EndpointEndpointInterfaceEnum];

/**
 * 
 * @export
 * @interface EndpointsGetResponse
 */
export interface EndpointsGetResponse {
    /**
     * 
     * @type {Array<EndpointEndpoint>}
     * @memberof EndpointsGetResponse
     */
    'endpoints'?: Array<EndpointEndpoint>;
}
/**
 * 
 * @export
 * @interface Group
 */
export interface Group {
    /**
     * 
     * @type {GroupGroup}
     * @memberof Group
     */
    'group'?: GroupGroup;
}
/**
 * 
 * @export
 * @interface GroupGroup
 */
export interface GroupGroup {
    /**
     * 
     * @type {string}
     * @memberof GroupGroup
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGroup
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupGroup
     */
    'domain_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupGroup
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface GroupsGetResponse
 */
export interface GroupsGetResponse {
    /**
     * 
     * @type {Array<GroupGroup>}
     * @memberof GroupsGetResponse
     */
    'groups'?: Array<GroupGroup>;
}
/**
 * 
 * @export
 * @interface GroupsUsersGetResponse
 */
export interface GroupsUsersGetResponse {
    /**
     * 
     * @type {Array<GroupsUsersGetResponseUsersInner>}
     * @memberof GroupsUsersGetResponse
     */
    'users'?: Array<GroupsUsersGetResponseUsersInner>;
}
/**
 * 
 * @export
 * @interface GroupsUsersGetResponseUsersInner
 */
export interface GroupsUsersGetResponseUsersInner {
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'default_project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'domain_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'enabled'?: GroupsUsersGetResponseUsersInnerEnabledEnum;
    /**
     * 
     * @type {Array<GroupsUsersGetResponseUsersInnerFederatedInner>}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'federated'?: Array<GroupsUsersGetResponseUsersInnerFederatedInner>;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'password'?: string | null;
    /**
     * 
     * @type {GroupsUsersGetResponseUsersInnerOptions}
     * @memberof GroupsUsersGetResponseUsersInner
     */
    'options'?: GroupsUsersGetResponseUsersInnerOptions;
}

export const GroupsUsersGetResponseUsersInnerEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerEnabledEnum = typeof GroupsUsersGetResponseUsersInnerEnabledEnum[keyof typeof GroupsUsersGetResponseUsersInnerEnabledEnum];

/**
 * 
 * @export
 * @interface GroupsUsersGetResponseUsersInnerFederatedInner
 */
export interface GroupsUsersGetResponseUsersInnerFederatedInner {
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInnerFederatedInner
     */
    'idp_id': string;
    /**
     * 
     * @type {Array<GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner>}
     * @memberof GroupsUsersGetResponseUsersInnerFederatedInner
     */
    'protocols': Array<GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner>;
}
/**
 * 
 * @export
 * @interface GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner
 */
export interface GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner {
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner
     */
    'protocol_id': string;
    /**
     * 
     * @type {string}
     * @memberof GroupsUsersGetResponseUsersInnerFederatedInnerProtocolsInner
     */
    'unique_id': string;
}
/**
 * 
 * @export
 * @interface GroupsUsersGetResponseUsersInnerOptions
 */
export interface GroupsUsersGetResponseUsersInnerOptions {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'ignore_change_password_upon_first_use'?: GroupsUsersGetResponseUsersInnerOptionsIgnoreChangePasswordUponFirstUseEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'ignore_password_expiry'?: GroupsUsersGetResponseUsersInnerOptionsIgnorePasswordExpiryEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'ignore_lockout_failure_attempts'?: GroupsUsersGetResponseUsersInnerOptionsIgnoreLockoutFailureAttemptsEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'lock_password'?: GroupsUsersGetResponseUsersInnerOptionsLockPasswordEnum | null;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'ignore_user_inactivity'?: GroupsUsersGetResponseUsersInnerOptionsIgnoreUserInactivityEnum | null;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'multi_factor_auth_rules'?: Array<Array<string>>;
    /**
     * 
     * @type {boolean}
     * @memberof GroupsUsersGetResponseUsersInnerOptions
     */
    'multi_factor_auth_enabled'?: GroupsUsersGetResponseUsersInnerOptionsMultiFactorAuthEnabledEnum | null;
}

export const GroupsUsersGetResponseUsersInnerOptionsIgnoreChangePasswordUponFirstUseEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsIgnoreChangePasswordUponFirstUseEnum = typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreChangePasswordUponFirstUseEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreChangePasswordUponFirstUseEnum];
export const GroupsUsersGetResponseUsersInnerOptionsIgnorePasswordExpiryEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsIgnorePasswordExpiryEnum = typeof GroupsUsersGetResponseUsersInnerOptionsIgnorePasswordExpiryEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsIgnorePasswordExpiryEnum];
export const GroupsUsersGetResponseUsersInnerOptionsIgnoreLockoutFailureAttemptsEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsIgnoreLockoutFailureAttemptsEnum = typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreLockoutFailureAttemptsEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreLockoutFailureAttemptsEnum];
export const GroupsUsersGetResponseUsersInnerOptionsLockPasswordEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsLockPasswordEnum = typeof GroupsUsersGetResponseUsersInnerOptionsLockPasswordEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsLockPasswordEnum];
export const GroupsUsersGetResponseUsersInnerOptionsIgnoreUserInactivityEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsIgnoreUserInactivityEnum = typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreUserInactivityEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsIgnoreUserInactivityEnum];
export const GroupsUsersGetResponseUsersInnerOptionsMultiFactorAuthEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type GroupsUsersGetResponseUsersInnerOptionsMultiFactorAuthEnabledEnum = typeof GroupsUsersGetResponseUsersInnerOptionsMultiFactorAuthEnabledEnum[keyof typeof GroupsUsersGetResponseUsersInnerOptionsMultiFactorAuthEnabledEnum];

/**
 * 
 * @export
 * @interface OsFederationDomainsGetResponse
 */
export interface OsFederationDomainsGetResponse {
    /**
     * 
     * @type {Array<AuthDomainsGetResponseDomainsInner>}
     * @memberof OsFederationDomainsGetResponse
     */
    'domains'?: Array<AuthDomainsGetResponseDomainsInner>;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof OsFederationDomainsGetResponse
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderGetResponse
 */
export interface OsFederationIdentityProviderGetResponse {
    /**
     * 
     * @type {OsFederationIdentityProviderGetResponseIdentityProvider}
     * @memberof OsFederationIdentityProviderGetResponse
     */
    'identity_provider'?: OsFederationIdentityProviderGetResponseIdentityProvider;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderGetResponseIdentityProvider
 */
export interface OsFederationIdentityProviderGetResponseIdentityProvider {
    /**
     * The Identity Provider unique ID
     * @type {string}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'id'?: string;
    /**
     * The Identity Provider description
     * @type {string}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'description'?: string;
    /**
     * The ID of a domain that is associated with the Identity Provider.
     * @type {string}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'domain_id'?: string;
    /**
     * The length of validity in minutes for group memberships carried over through mapping and persisted in the database.
     * @type {number}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'authorization_ttl'?: number;
    /**
     * Whether the Identity Provider is enabled or not
     * @type {boolean}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'enabled'?: boolean;
    /**
     * List of the unique Identity Provider’s remote IDs
     * @type {Array<string>}
     * @memberof OsFederationIdentityProviderGetResponseIdentityProvider
     */
    'remote_ids'?: Array<string>;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPatchRequest
 */
export interface OsFederationIdentityProviderPatchRequest {
    /**
     * 
     * @type {OsFederationIdentityProviderPatchRequestIdentityProvider}
     * @memberof OsFederationIdentityProviderPatchRequest
     */
    'identity_provider'?: OsFederationIdentityProviderPatchRequestIdentityProvider;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPatchRequestIdentityProvider
 */
export interface OsFederationIdentityProviderPatchRequestIdentityProvider {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof OsFederationIdentityProviderPatchRequestIdentityProvider
     */
    'enabled'?: OsFederationIdentityProviderPatchRequestIdentityProviderEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProviderPatchRequestIdentityProvider
     */
    'description'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OsFederationIdentityProviderPatchRequestIdentityProvider
     */
    'authorization_ttl'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsFederationIdentityProviderPatchRequestIdentityProvider
     */
    'remote_ids'?: Array<string>;
}

export const OsFederationIdentityProviderPatchRequestIdentityProviderEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type OsFederationIdentityProviderPatchRequestIdentityProviderEnabledEnum = typeof OsFederationIdentityProviderPatchRequestIdentityProviderEnabledEnum[keyof typeof OsFederationIdentityProviderPatchRequestIdentityProviderEnabledEnum];

/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPatchResponse
 */
export interface OsFederationIdentityProviderPatchResponse {
    /**
     * 
     * @type {OsFederationIdentityProviderGetResponseIdentityProvider}
     * @memberof OsFederationIdentityProviderPatchResponse
     */
    'identity_provider'?: OsFederationIdentityProviderGetResponseIdentityProvider;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPutRequest
 */
export interface OsFederationIdentityProviderPutRequest {
    /**
     * 
     * @type {OsFederationIdentityProviderPutRequestIdentityProvider}
     * @memberof OsFederationIdentityProviderPutRequest
     */
    'identity_provider'?: OsFederationIdentityProviderPutRequestIdentityProvider;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPutRequestIdentityProvider
 */
export interface OsFederationIdentityProviderPutRequestIdentityProvider {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof OsFederationIdentityProviderPutRequestIdentityProvider
     */
    'enabled'?: OsFederationIdentityProviderPutRequestIdentityProviderEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProviderPutRequestIdentityProvider
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProviderPutRequestIdentityProvider
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {number}
     * @memberof OsFederationIdentityProviderPutRequestIdentityProvider
     */
    'authorization_ttl'?: number | null;
    /**
     * 
     * @type {Array<string>}
     * @memberof OsFederationIdentityProviderPutRequestIdentityProvider
     */
    'remote_ids'?: Array<string>;
}

export const OsFederationIdentityProviderPutRequestIdentityProviderEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type OsFederationIdentityProviderPutRequestIdentityProviderEnabledEnum = typeof OsFederationIdentityProviderPutRequestIdentityProviderEnabledEnum[keyof typeof OsFederationIdentityProviderPutRequestIdentityProviderEnabledEnum];

/**
 * 
 * @export
 * @interface OsFederationIdentityProviderPutResponse
 */
export interface OsFederationIdentityProviderPutResponse {
    /**
     * 
     * @type {OsFederationIdentityProviderGetResponseIdentityProvider}
     * @memberof OsFederationIdentityProviderPutResponse
     */
    'identity_provider'?: OsFederationIdentityProviderGetResponseIdentityProvider;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersGetResponse
 */
export interface OsFederationIdentityProvidersGetResponse {
    /**
     * 
     * @type {Array<OsFederationIdentityProviderGetResponseIdentityProvider>}
     * @memberof OsFederationIdentityProvidersGetResponse
     */
    'identity_providers'?: Array<OsFederationIdentityProviderGetResponseIdentityProvider>;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolGetResponse
 */
export interface OsFederationIdentityProvidersProtocolGetResponse {
    /**
     * 
     * @type {OsFederationIdentityProvidersProtocolGetResponseProtocol}
     * @memberof OsFederationIdentityProvidersProtocolGetResponse
     */
    'protocol'?: OsFederationIdentityProvidersProtocolGetResponseProtocol;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolGetResponseProtocol
 */
export interface OsFederationIdentityProvidersProtocolGetResponseProtocol {
    /**
     * The federation protocol ID
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolGetResponseProtocol
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolGetResponseProtocol
     */
    'mapping_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolGetResponseProtocol
     */
    'remote_id_attribute'?: string;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPatchRequest
 */
export interface OsFederationIdentityProvidersProtocolPatchRequest {
    /**
     * 
     * @type {OsFederationIdentityProvidersProtocolPatchRequestProtocol}
     * @memberof OsFederationIdentityProvidersProtocolPatchRequest
     */
    'protocol'?: OsFederationIdentityProvidersProtocolPatchRequestProtocol;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPatchRequestProtocol
 */
export interface OsFederationIdentityProvidersProtocolPatchRequestProtocol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolPatchRequestProtocol
     */
    'mapping_id'?: string;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolPatchRequestProtocol
     */
    'remote_id_attribute'?: string;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPatchResponse
 */
export interface OsFederationIdentityProvidersProtocolPatchResponse {
    /**
     * 
     * @type {OsFederationIdentityProvidersProtocolGetResponseProtocol}
     * @memberof OsFederationIdentityProvidersProtocolPatchResponse
     */
    'protocol'?: OsFederationIdentityProvidersProtocolGetResponseProtocol;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPutRequest
 */
export interface OsFederationIdentityProvidersProtocolPutRequest {
    /**
     * 
     * @type {OsFederationIdentityProvidersProtocolPutRequestProtocol}
     * @memberof OsFederationIdentityProvidersProtocolPutRequest
     */
    'protocol'?: OsFederationIdentityProvidersProtocolPutRequestProtocol;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPutRequestProtocol
 */
export interface OsFederationIdentityProvidersProtocolPutRequestProtocol {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolPutRequestProtocol
     */
    'mapping_id': string;
    /**
     * 
     * @type {string}
     * @memberof OsFederationIdentityProvidersProtocolPutRequestProtocol
     */
    'remote_id_attribute'?: string;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolPutResponse
 */
export interface OsFederationIdentityProvidersProtocolPutResponse {
    /**
     * 
     * @type {OsFederationIdentityProvidersProtocolGetResponseProtocol}
     * @memberof OsFederationIdentityProvidersProtocolPutResponse
     */
    'protocol'?: OsFederationIdentityProvidersProtocolGetResponseProtocol;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolsAuthGetResponse
 */
export interface OsFederationIdentityProvidersProtocolsAuthGetResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof OsFederationIdentityProvidersProtocolsAuthGetResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolsAuthPostResponse
 */
export interface OsFederationIdentityProvidersProtocolsAuthPostResponse {
    /**
     * 
     * @type {AuthOsFederationWebssoGetResponseToken}
     * @memberof OsFederationIdentityProvidersProtocolsAuthPostResponse
     */
    'token'?: AuthOsFederationWebssoGetResponseToken;
}
/**
 * 
 * @export
 * @interface OsFederationIdentityProvidersProtocolsGetResponse
 */
export interface OsFederationIdentityProvidersProtocolsGetResponse {
    /**
     * 
     * @type {Array<OsFederationIdentityProvidersProtocolGetResponseProtocol>}
     * @memberof OsFederationIdentityProvidersProtocolsGetResponse
     */
    'protocols'?: Array<OsFederationIdentityProvidersProtocolGetResponseProtocol>;
}
/**
 * 
 * @export
 * @interface OsFederationMappingGetResponse
 */
export interface OsFederationMappingGetResponse {
    /**
     * 
     * @type {OsFederationMappingGetResponseMapping}
     * @memberof OsFederationMappingGetResponse
     */
    'mapping'?: OsFederationMappingGetResponseMapping;
}
/**
 * 
 * @export
 * @interface OsFederationMappingGetResponseMapping
 */
export interface OsFederationMappingGetResponseMapping {
    /**
     * The Federation Mapping unique ID
     * @type {string}
     * @memberof OsFederationMappingGetResponseMapping
     */
    'id'?: string;
    /**
     * 
     * @type {any}
     * @memberof OsFederationMappingGetResponseMapping
     */
    'rules'?: any;
    /**
     * Mapping schema version
     * @type {any}
     * @memberof OsFederationMappingGetResponseMapping
     */
    'schema_version'?: any;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPatchRequest
 */
export interface OsFederationMappingPatchRequest {
    /**
     * 
     * @type {OsFederationMappingPatchRequestMapping}
     * @memberof OsFederationMappingPatchRequest
     */
    'mapping'?: OsFederationMappingPatchRequestMapping;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPatchRequestMapping
 */
export interface OsFederationMappingPatchRequestMapping {
    /**
     * 
     * @type {any}
     * @memberof OsFederationMappingPatchRequestMapping
     */
    'rules': any;
    /**
     * Mapping schema version
     * @type {any}
     * @memberof OsFederationMappingPatchRequestMapping
     */
    'schema_version'?: any;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPatchResponse
 */
export interface OsFederationMappingPatchResponse {
    /**
     * 
     * @type {OsFederationMappingPatchResponseMapping}
     * @memberof OsFederationMappingPatchResponse
     */
    'mapping'?: OsFederationMappingPatchResponseMapping;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPatchResponseMapping
 */
export interface OsFederationMappingPatchResponseMapping {
    /**
     * The Federation Mapping unique ID
     * @type {any}
     * @memberof OsFederationMappingPatchResponseMapping
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsFederationMappingPatchResponseMapping
     */
    'rules'?: any;
    /**
     * Mapping schema version
     * @type {any}
     * @memberof OsFederationMappingPatchResponseMapping
     */
    'schema_version'?: any;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPutRequest
 */
export interface OsFederationMappingPutRequest {
    /**
     * 
     * @type {OsFederationMappingPatchRequestMapping}
     * @memberof OsFederationMappingPutRequest
     */
    'mapping'?: OsFederationMappingPatchRequestMapping;
}
/**
 * 
 * @export
 * @interface OsFederationMappingPutResponse
 */
export interface OsFederationMappingPutResponse {
    /**
     * 
     * @type {OsFederationMappingPatchResponseMapping}
     * @memberof OsFederationMappingPutResponse
     */
    'mapping'?: OsFederationMappingPatchResponseMapping;
}
/**
 * 
 * @export
 * @interface OsFederationMappingsGetResponse
 */
export interface OsFederationMappingsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof OsFederationMappingsGetResponse
     */
    'mappings'?: any;
}
/**
 * 
 * @export
 * @interface OsFederationProjectsGetResponse
 */
export interface OsFederationProjectsGetResponse {
    /**
     * 
     * @type {Array<AuthProjectsGetResponseProjectsInner>}
     * @memberof OsFederationProjectsGetResponse
     */
    'projects'?: Array<AuthProjectsGetResponseProjectsInner>;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {Array<AuthProjectsGetResponseProjectsInnerLinksInner>}
     * @memberof OsFederationProjectsGetResponse
     */
    'links'?: Array<AuthProjectsGetResponseProjectsInnerLinksInner>;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderGetResponse
 */
export interface OsFederationServiceProviderGetResponse {
    /**
     * 
     * @type {OsFederationServiceProviderGetResponseServiceProvider}
     * @memberof OsFederationServiceProviderGetResponse
     */
    'service_provider'?: OsFederationServiceProviderGetResponseServiceProvider;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderGetResponseServiceProvider
 */
export interface OsFederationServiceProviderGetResponseServiceProvider {
    /**
     * The URL to authenticate against
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'auth_url': any;
    /**
     * The description of the Service Provider
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'description'?: any;
    /**
     * The Service Provider unique ID
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'id'?: any;
    /**
     * Whether the Service Provider is enabled or not
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'enabled'?: any;
    /**
     * The prefix of the RelayState SAML attribute
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'relay_state_prefix'?: any;
    /**
     * The Service Provider’s URL
     * @type {any}
     * @memberof OsFederationServiceProviderGetResponseServiceProvider
     */
    'sp_url': any;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderPatchRequest
 */
export interface OsFederationServiceProviderPatchRequest {
    /**
     * 
     * @type {OsFederationServiceProviderPatchRequestServiceProvider}
     * @memberof OsFederationServiceProviderPatchRequest
     */
    'service_provider'?: OsFederationServiceProviderPatchRequestServiceProvider;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderPatchRequestServiceProvider
 */
export interface OsFederationServiceProviderPatchRequestServiceProvider {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsFederationServiceProviderPatchRequestServiceProvider
     */
    'auth_url'?: any;
    /**
     * 
     * @type {any}
     * @memberof OsFederationServiceProviderPatchRequestServiceProvider
     */
    'sp_url'?: any;
    /**
     * 
     * @type {string}
     * @memberof OsFederationServiceProviderPatchRequestServiceProvider
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OsFederationServiceProviderPatchRequestServiceProvider
     */
    'enabled'?: OsFederationServiceProviderPatchRequestServiceProviderEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof OsFederationServiceProviderPatchRequestServiceProvider
     */
    'relay_state_prefix'?: string | null;
}

export const OsFederationServiceProviderPatchRequestServiceProviderEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type OsFederationServiceProviderPatchRequestServiceProviderEnabledEnum = typeof OsFederationServiceProviderPatchRequestServiceProviderEnabledEnum[keyof typeof OsFederationServiceProviderPatchRequestServiceProviderEnabledEnum];

/**
 * 
 * @export
 * @interface OsFederationServiceProviderPatchResponse
 */
export interface OsFederationServiceProviderPatchResponse {
    /**
     * 
     * @type {OsFederationServiceProviderGetResponseServiceProvider}
     * @memberof OsFederationServiceProviderPatchResponse
     */
    'service_provider'?: OsFederationServiceProviderGetResponseServiceProvider;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderPutRequest
 */
export interface OsFederationServiceProviderPutRequest {
    /**
     * 
     * @type {OsFederationServiceProviderPutRequestServiceProvider}
     * @memberof OsFederationServiceProviderPutRequest
     */
    'service_provider'?: OsFederationServiceProviderPutRequestServiceProvider;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProviderPutRequestServiceProvider
 */
export interface OsFederationServiceProviderPutRequestServiceProvider {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof OsFederationServiceProviderPutRequestServiceProvider
     */
    'auth_url': any;
    /**
     * 
     * @type {any}
     * @memberof OsFederationServiceProviderPutRequestServiceProvider
     */
    'sp_url': any;
    /**
     * 
     * @type {string}
     * @memberof OsFederationServiceProviderPutRequestServiceProvider
     */
    'description'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof OsFederationServiceProviderPutRequestServiceProvider
     */
    'enabled'?: OsFederationServiceProviderPutRequestServiceProviderEnabledEnum;
    /**
     * 
     * @type {string}
     * @memberof OsFederationServiceProviderPutRequestServiceProvider
     */
    'relay_state_prefix'?: string | null;
}

export const OsFederationServiceProviderPutRequestServiceProviderEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type OsFederationServiceProviderPutRequestServiceProviderEnabledEnum = typeof OsFederationServiceProviderPutRequestServiceProviderEnabledEnum[keyof typeof OsFederationServiceProviderPutRequestServiceProviderEnabledEnum];

/**
 * 
 * @export
 * @interface OsFederationServiceProviderPutResponse
 */
export interface OsFederationServiceProviderPutResponse {
    /**
     * 
     * @type {OsFederationServiceProviderGetResponseServiceProvider}
     * @memberof OsFederationServiceProviderPutResponse
     */
    'service_provider'?: OsFederationServiceProviderGetResponseServiceProvider;
}
/**
 * 
 * @export
 * @interface OsFederationServiceProvidersGetResponse
 */
export interface OsFederationServiceProvidersGetResponse {
    /**
     * 
     * @type {any}
     * @memberof OsFederationServiceProvidersGetResponse
     */
    'service_providers'?: any;
}
/**
 * 
 * @export
 * @interface Project
 */
export interface Project {
    /**
     * 
     * @type {ProjectProject}
     * @memberof Project
     */
    'project'?: ProjectProject;
}
/**
 * 
 * @export
 * @interface ProjectProject
 */
export interface ProjectProject {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'domain_id'?: string | null;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectProject
     */
    'enabled'?: ProjectProjectEnabledEnum;
    /**
     * 
     * @type {boolean}
     * @memberof ProjectProject
     */
    'is_domain'?: ProjectProjectIsDomainEnum;
    /**
     * 
     * @type {string}
     * @memberof ProjectProject
     */
    'parent_id'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof ProjectProject
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof ProjectProject
     */
    'tags'?: any;
    /**
     * 
     * @type {ProjectProjectOptions}
     * @memberof ProjectProject
     */
    'options'?: ProjectProjectOptions;
}

export const ProjectProjectEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type ProjectProjectEnabledEnum = typeof ProjectProjectEnabledEnum[keyof typeof ProjectProjectEnabledEnum];
export const ProjectProjectIsDomainEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type ProjectProjectIsDomainEnum = typeof ProjectProjectIsDomainEnum[keyof typeof ProjectProjectIsDomainEnum];

/**
 * 
 * @export
 * @interface ProjectProjectOptions
 */
export interface ProjectProjectOptions {
    [key: string]: any;

    /**
     * 
     * @type {boolean}
     * @memberof ProjectProjectOptions
     */
    'immutable'?: ProjectProjectOptionsImmutableEnum | null;
}

export const ProjectProjectOptionsImmutableEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type ProjectProjectOptionsImmutableEnum = typeof ProjectProjectOptionsImmutableEnum[keyof typeof ProjectProjectOptionsImmutableEnum];

/**
 * 
 * @export
 * @interface ProjectsGetResponse
 */
export interface ProjectsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof ProjectsGetResponse
     */
    'projects'?: any;
}
/**
 * 
 * @export
 * @interface ProjectsTagsGetResponse
 */
export interface ProjectsTagsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof ProjectsTagsGetResponse
     */
    'tags'?: any;
}
/**
 * 
 * @export
 * @interface ProjectsTagsPutResponse
 */
export interface ProjectsTagsPutResponse {
    /**
     * 
     * @type {any}
     * @memberof ProjectsTagsPutResponse
     */
    'tags'?: any;
}
/**
 * 
 * @export
 * @interface Region
 */
export interface Region {
    /**
     * 
     * @type {RegionRegion}
     * @memberof Region
     */
    'region'?: RegionRegion;
}
/**
 * 
 * @export
 * @interface RegionRegion
 */
export interface RegionRegion {
    /**
     * The region description.
     * @type {any}
     * @memberof RegionRegion
     */
    'description'?: any;
    /**
     * The ID for the region.
     * @type {any}
     * @memberof RegionRegion
     */
    'id'?: any;
    /**
     * To make this region a child of another region, set this parameter to the ID of the parent region.
     * @type {any}
     * @memberof RegionRegion
     */
    'parent_id'?: any;
}
/**
 * 
 * @export
 * @interface RegionsGetResponse
 */
export interface RegionsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof RegionsGetResponse
     */
    'regions'?: any;
}
/**
 * 
 * @export
 * @interface Role
 */
export interface Role {
    /**
     * 
     * @type {RoleRole}
     * @memberof Role
     */
    'role'?: RoleRole;
}
/**
 * 
 * @export
 * @interface RoleAssignmentsGetResponse
 */
export interface RoleAssignmentsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof RoleAssignmentsGetResponse
     */
    'role_assignments'?: any;
}
/**
 * 
 * @export
 * @interface RoleInferencesGetResponse
 */
export interface RoleInferencesGetResponse {
    /**
     * 
     * @type {any}
     * @memberof RoleInferencesGetResponse
     */
    'role_inferences'?: any;
}
/**
 * A role object.
 * @export
 * @interface RoleRole
 */
export interface RoleRole {
    /**
     * The role ID.
     * @type {any}
     * @memberof RoleRole
     */
    'id'?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RoleRole
     */
    'links'?: { [key: string]: any; };
    /**
     * 
     * @type {string}
     * @memberof RoleRole
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof RoleRole
     */
    'description'?: string;
    /**
     * 
     * @type {RoleRoleOptions}
     * @memberof RoleRole
     */
    'options'?: RoleRoleOptions;
}
/**
 * 
 * @export
 * @interface RoleRoleOptions
 */
export interface RoleRoleOptions {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof RoleRoleOptions
     */
    'immutable'?: RoleRoleOptionsImmutableEnum;
}

export const RoleRoleOptionsImmutableEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type RoleRoleOptionsImmutableEnum = typeof RoleRoleOptionsImmutableEnum[keyof typeof RoleRoleOptionsImmutableEnum];

/**
 * 
 * @export
 * @interface RolesGetResponse
 */
export interface RolesGetResponse {
    /**
     * 
     * @type {any}
     * @memberof RolesGetResponse
     */
    'roles'?: any;
    /**
     * 
     * @type {{ [key: string]: any; }}
     * @memberof RolesGetResponse
     */
    'links'?: { [key: string]: any; };
}
/**
 * 
 * @export
 * @interface RolesImpliesGetResponse
 */
export interface RolesImpliesGetResponse {
    /**
     * 
     * @type {RolesImpliesGetResponseRoleInference}
     * @memberof RolesImpliesGetResponse
     */
    'role_inference'?: RolesImpliesGetResponseRoleInference;
}
/**
 * 
 * @export
 * @interface RolesImpliesGetResponseRoleInference
 */
export interface RolesImpliesGetResponseRoleInference {
    /**
     * 
     * @type {RolesImpliesGetResponseRoleInferencePriorRole}
     * @memberof RolesImpliesGetResponseRoleInference
     */
    'prior_role'?: RolesImpliesGetResponseRoleInferencePriorRole;
    /**
     * 
     * @type {any}
     * @memberof RolesImpliesGetResponseRoleInference
     */
    'implies'?: any;
}
/**
 * 
 * @export
 * @interface RolesImpliesGetResponseRoleInferencePriorRole
 */
export interface RolesImpliesGetResponseRoleInferencePriorRole {
    /**
     * The role ID.
     * @type {any}
     * @memberof RolesImpliesGetResponseRoleInferencePriorRole
     */
    'id'?: any;
    /**
     * The role name.
     * @type {any}
     * @memberof RolesImpliesGetResponseRoleInferencePriorRole
     */
    'name'?: any;
    /**
     * The role description.
     * @type {any}
     * @memberof RolesImpliesGetResponseRoleInferencePriorRole
     */
    'description'?: any;
    /**
     * 
     * @type {RolesImpliesGetResponseRoleInferencePriorRoleLinks}
     * @memberof RolesImpliesGetResponseRoleInferencePriorRole
     */
    'links'?: RolesImpliesGetResponseRoleInferencePriorRoleLinks;
}
/**
 * 
 * @export
 * @interface RolesImpliesGetResponseRoleInferencePriorRoleLinks
 */
export interface RolesImpliesGetResponseRoleInferencePriorRoleLinks {
    /**
     * The link to the resource in question.
     * @type {any}
     * @memberof RolesImpliesGetResponseRoleInferencePriorRoleLinks
     */
    'self'?: any;
}
/**
 * 
 * @export
 * @interface RolesImplyGetResponse
 */
export interface RolesImplyGetResponse {
    /**
     * 
     * @type {RolesImplyGetResponseRoleInference}
     * @memberof RolesImplyGetResponse
     */
    'role_inference'?: RolesImplyGetResponseRoleInference;
}
/**
 * 
 * @export
 * @interface RolesImplyGetResponseRoleInference
 */
export interface RolesImplyGetResponseRoleInference {
    /**
     * 
     * @type {RolesImpliesGetResponseRoleInferencePriorRole}
     * @memberof RolesImplyGetResponseRoleInference
     */
    'prior_role'?: RolesImpliesGetResponseRoleInferencePriorRole;
    /**
     * 
     * @type {RolesImpliesGetResponseRoleInferencePriorRole}
     * @memberof RolesImplyGetResponseRoleInference
     */
    'implies'?: RolesImpliesGetResponseRoleInferencePriorRole;
}
/**
 * 
 * @export
 * @interface RolesImplyPutResponse
 */
export interface RolesImplyPutResponse {
    /**
     * 
     * @type {RolesImplyGetResponseRoleInference}
     * @memberof RolesImplyPutResponse
     */
    'role_inference'?: RolesImplyGetResponseRoleInference;
}
/**
 * List of roles assigned to the resource
 * @export
 * @interface RolesInfos
 */
export interface RolesInfos {
    /**
     * 
     * @type {Array<RolesInfosRolesInner>}
     * @memberof RolesInfos
     */
    'roles'?: Array<RolesInfosRolesInner>;
    /**
     * 
     * @type {{ [key: string]: string | null; }}
     * @memberof RolesInfos
     */
    'links'?: { [key: string]: string | null; };
}
/**
 * 
 * @export
 * @interface RolesInfosRolesInner
 */
export interface RolesInfosRolesInner {
    /**
     * The role ID.
     * @type {string}
     * @memberof RolesInfosRolesInner
     */
    'id'?: string;
    /**
     * The role name.
     * @type {string}
     * @memberof RolesInfosRolesInner
     */
    'name'?: string;
    /**
     * The role description.
     * @type {string}
     * @memberof RolesInfosRolesInner
     */
    'description'?: string;
    /**
     * 
     * @type {RolesInfosRolesInnerLinks}
     * @memberof RolesInfosRolesInner
     */
    'links'?: RolesInfosRolesInnerLinks;
}
/**
 * 
 * @export
 * @interface RolesInfosRolesInnerLinks
 */
export interface RolesInfosRolesInnerLinks {
    /**
     * The link to the resource in question.
     * @type {string}
     * @memberof RolesInfosRolesInnerLinks
     */
    'self'?: string;
}
/**
 * 
 * @export
 * @interface Service
 */
export interface Service {
    /**
     * 
     * @type {ServiceService}
     * @memberof Service
     */
    'service'?: ServiceService;
}
/**
 * 
 * @export
 * @interface ServiceService
 */
export interface ServiceService {
    /**
     * The service description.
     * @type {any}
     * @memberof ServiceService
     */
    'description'?: any;
    /**
     * Defines whether the service and its endpoints appear in the service catalog.
     * @type {any}
     * @memberof ServiceService
     */
    'enabled'?: any;
    /**
     * The UUID of the service to which the endpoint belongs.
     * @type {any}
     * @memberof ServiceService
     */
    'id'?: any;
    /**
     * The service name.
     * @type {any}
     * @memberof ServiceService
     */
    'name'?: any;
    /**
     * The service type, which describes the API implemented by the 
     * @type {any}
     * @memberof ServiceService
     */
    'type'?: any;
}
/**
 * 
 * @export
 * @interface ServicesGetResponse
 */
export interface ServicesGetResponse {
    /**
     * 
     * @type {any}
     * @memberof ServicesGetResponse
     */
    'services'?: any;
}
/**
 * 
 * @export
 * @interface UserGetResponse
 */
export interface UserGetResponse {
    /**
     * 
     * @type {UserGetResponseUser}
     * @memberof UserGetResponse
     */
    'user'?: UserGetResponseUser;
}
/**
 * 
 * @export
 * @interface UserGetResponseUser
 */
export interface UserGetResponseUser {
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'default_project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'domain_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'enabled'?: UserGetResponseUserEnabledEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'federated'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUser
     */
    'password'?: any;
    /**
     * 
     * @type {UserGetResponseUserOptions}
     * @memberof UserGetResponseUser
     */
    'options'?: UserGetResponseUserOptions;
}

export const UserGetResponseUserEnabledEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserEnabledEnum = typeof UserGetResponseUserEnabledEnum[keyof typeof UserGetResponseUserEnabledEnum];

/**
 * 
 * @export
 * @interface UserGetResponseUserOptions
 */
export interface UserGetResponseUserOptions {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'ignore_change_password_upon_first_use'?: UserGetResponseUserOptionsIgnoreChangePasswordUponFirstUseEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'ignore_password_expiry'?: UserGetResponseUserOptionsIgnorePasswordExpiryEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'ignore_lockout_failure_attempts'?: UserGetResponseUserOptionsIgnoreLockoutFailureAttemptsEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'lock_password'?: UserGetResponseUserOptionsLockPasswordEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'ignore_user_inactivity'?: UserGetResponseUserOptionsIgnoreUserInactivityEnum;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'multi_factor_auth_rules'?: any;
    /**
     * 
     * @type {any}
     * @memberof UserGetResponseUserOptions
     */
    'multi_factor_auth_enabled'?: UserGetResponseUserOptionsMultiFactorAuthEnabledEnum;
}

export const UserGetResponseUserOptionsIgnoreChangePasswordUponFirstUseEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsIgnoreChangePasswordUponFirstUseEnum = typeof UserGetResponseUserOptionsIgnoreChangePasswordUponFirstUseEnum[keyof typeof UserGetResponseUserOptionsIgnoreChangePasswordUponFirstUseEnum];
export const UserGetResponseUserOptionsIgnorePasswordExpiryEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsIgnorePasswordExpiryEnum = typeof UserGetResponseUserOptionsIgnorePasswordExpiryEnum[keyof typeof UserGetResponseUserOptionsIgnorePasswordExpiryEnum];
export const UserGetResponseUserOptionsIgnoreLockoutFailureAttemptsEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsIgnoreLockoutFailureAttemptsEnum = typeof UserGetResponseUserOptionsIgnoreLockoutFailureAttemptsEnum[keyof typeof UserGetResponseUserOptionsIgnoreLockoutFailureAttemptsEnum];
export const UserGetResponseUserOptionsLockPasswordEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsLockPasswordEnum = typeof UserGetResponseUserOptionsLockPasswordEnum[keyof typeof UserGetResponseUserOptionsLockPasswordEnum];
export const UserGetResponseUserOptionsIgnoreUserInactivityEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsIgnoreUserInactivityEnum = typeof UserGetResponseUserOptionsIgnoreUserInactivityEnum[keyof typeof UserGetResponseUserOptionsIgnoreUserInactivityEnum];
export const UserGetResponseUserOptionsMultiFactorAuthEnabledEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UserGetResponseUserOptionsMultiFactorAuthEnabledEnum = typeof UserGetResponseUserOptionsMultiFactorAuthEnabledEnum[keyof typeof UserGetResponseUserOptionsMultiFactorAuthEnabledEnum];

/**
 * 
 * @export
 * @interface UserPatchRequest
 */
export interface UserPatchRequest {
    /**
     * 
     * @type {UserPatchRequestUser}
     * @memberof UserPatchRequest
     */
    'user'?: UserPatchRequestUser;
}
/**
 * 
 * @export
 * @interface UserPatchRequestUser
 */
export interface UserPatchRequestUser {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UserPatchRequestUser
     */
    'default_project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchRequestUser
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UserPatchRequestUser
     */
    'domain_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserPatchRequestUser
     */
    'enabled'?: UserPatchRequestUserEnabledEnum;
    /**
     * 
     * @type {any}
     * @memberof UserPatchRequestUser
     */
    'federated'?: any;
    /**
     * 
     * @type {string}
     * @memberof UserPatchRequestUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserPatchRequestUser
     */
    'password'?: string | null;
    /**
     * 
     * @type {UserGetResponseUserOptions}
     * @memberof UserPatchRequestUser
     */
    'options'?: UserGetResponseUserOptions;
}

export const UserPatchRequestUserEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type UserPatchRequestUserEnabledEnum = typeof UserPatchRequestUserEnabledEnum[keyof typeof UserPatchRequestUserEnabledEnum];

/**
 * 
 * @export
 * @interface UserPatchResponse
 */
export interface UserPatchResponse {
    /**
     * 
     * @type {UserGetResponseUser}
     * @memberof UserPatchResponse
     */
    'user'?: UserGetResponseUser;
}
/**
 * 
 * @export
 * @interface UsersAccessRuleGetResponse
 */
export interface UsersAccessRuleGetResponse {
    /**
     * 
     * @type {UsersAccessRuleGetResponseAccessRule}
     * @memberof UsersAccessRuleGetResponse
     */
    'access_rule'?: UsersAccessRuleGetResponseAccessRule;
}
/**
 * 
 * @export
 * @interface UsersAccessRuleGetResponseAccessRule
 */
export interface UsersAccessRuleGetResponseAccessRule {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof UsersAccessRuleGetResponseAccessRule
     */
    'path'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersAccessRuleGetResponseAccessRule
     */
    'method'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersAccessRuleGetResponseAccessRule
     */
    'service'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersAccessRuleGetResponseAccessRule
     */
    'id'?: any;
}
/**
 * 
 * @export
 * @interface UsersAccessRulesGetResponse
 */
export interface UsersAccessRulesGetResponse {
    /**
     * 
     * @type {any}
     * @memberof UsersAccessRulesGetResponse
     */
    'access_rules'?: any;
    /**
     * Links to the resources in question. See [API Guide / Links and References](https://docs.openstack.org/api-guide/compute/links_and_references.html) for more info.
     * @type {any}
     * @memberof UsersAccessRulesGetResponse
     */
    'links'?: any;
}
/**
 * 
 * @export
 * @interface UsersApplicationCredentialGetResponse
 */
export interface UsersApplicationCredentialGetResponse {
    /**
     * 
     * @type {UsersApplicationCredentialGetResponseApplicationCredential}
     * @memberof UsersApplicationCredentialGetResponse
     */
    'application_credential'?: UsersApplicationCredentialGetResponseApplicationCredential;
}
/**
 * 
 * @export
 * @interface UsersApplicationCredentialGetResponseApplicationCredential
 */
export interface UsersApplicationCredentialGetResponseApplicationCredential {
    /**
     * The ID of the application credential.
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'id'?: any;
    /**
     * The ID of the project the application credential was created for and that authentication requests using this application credential will be scoped to.
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'project_id'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'name'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'description'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'expires_at'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'roles'?: any;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'unrestricted'?: UsersApplicationCredentialGetResponseApplicationCredentialUnrestrictedEnum;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialGetResponseApplicationCredential
     */
    'access_rules'?: any;
}

export const UsersApplicationCredentialGetResponseApplicationCredentialUnrestrictedEnum = {
    True: 'true',
    False: 'false',
    Null: 'null'
} as const;

export type UsersApplicationCredentialGetResponseApplicationCredentialUnrestrictedEnum = typeof UsersApplicationCredentialGetResponseApplicationCredentialUnrestrictedEnum[keyof typeof UsersApplicationCredentialGetResponseApplicationCredentialUnrestrictedEnum];

/**
 * 
 * @export
 * @interface UsersApplicationCredentialsGetResponse
 */
export interface UsersApplicationCredentialsGetResponse {
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialsGetResponse
     */
    'application_credentials'?: any;
}
/**
 * 
 * @export
 * @interface UsersApplicationCredentialsPostRequest
 */
export interface UsersApplicationCredentialsPostRequest {
    /**
     * 
     * @type {UsersApplicationCredentialsPostRequestApplicationCredential}
     * @memberof UsersApplicationCredentialsPostRequest
     */
    'application_credential'?: UsersApplicationCredentialsPostRequestApplicationCredential;
}
/**
 * 
 * @export
 * @interface UsersApplicationCredentialsPostRequestApplicationCredential
 */
export interface UsersApplicationCredentialsPostRequestApplicationCredential {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'secret'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'roles'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'unrestricted'?: UsersApplicationCredentialsPostRequestApplicationCredentialUnrestrictedEnum;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialsPostRequestApplicationCredential
     */
    'access_rules'?: any;
}

export const UsersApplicationCredentialsPostRequestApplicationCredentialUnrestrictedEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type UsersApplicationCredentialsPostRequestApplicationCredentialUnrestrictedEnum = typeof UsersApplicationCredentialsPostRequestApplicationCredentialUnrestrictedEnum[keyof typeof UsersApplicationCredentialsPostRequestApplicationCredentialUnrestrictedEnum];

/**
 * 
 * @export
 * @interface UsersApplicationCredentialsPostResponse
 */
export interface UsersApplicationCredentialsPostResponse {
    /**
     * 
     * @type {UsersApplicationCredentialsPostResponseApplicationCredential}
     * @memberof UsersApplicationCredentialsPostResponse
     */
    'application_credential'?: UsersApplicationCredentialsPostResponseApplicationCredential;
}
/**
 * 
 * @export
 * @interface UsersApplicationCredentialsPostResponseApplicationCredential
 */
export interface UsersApplicationCredentialsPostResponseApplicationCredential {
    /**
     * The ID of the application credential.
     * @type {any}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'id'?: any;
    /**
     * The ID of the project the application credential was created for and that authentication requests using this application credential will be scoped to.
     * @type {any}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'project_id'?: any;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'expires_at'?: string | null;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'roles'?: any;
    /**
     * 
     * @type {boolean}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'unrestricted'?: UsersApplicationCredentialsPostResponseApplicationCredentialUnrestrictedEnum;
    /**
     * 
     * @type {any}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'access_rules'?: any;
    /**
     * The secret for the application credential, either generated by the server or provided by the user. This is only ever shown once in the response to a create request. It is not stored nor ever shown again. If the secret is lost, a new application credential must be created.
     * @type {any}
     * @memberof UsersApplicationCredentialsPostResponseApplicationCredential
     */
    'secret'?: any;
}

export const UsersApplicationCredentialsPostResponseApplicationCredentialUnrestrictedEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type UsersApplicationCredentialsPostResponseApplicationCredentialUnrestrictedEnum = typeof UsersApplicationCredentialsPostResponseApplicationCredentialUnrestrictedEnum[keyof typeof UsersApplicationCredentialsPostResponseApplicationCredentialUnrestrictedEnum];

/**
 * 
 * @export
 * @interface UsersGetResponse
 */
export interface UsersGetResponse {
    /**
     * 
     * @type {any}
     * @memberof UsersGetResponse
     */
    'users'?: any;
}
/**
 * 
 * @export
 * @interface UsersGroupsGetResponse
 */
export interface UsersGroupsGetResponse {
    /**
     * A list of group objects
     * @type {any}
     * @memberof UsersGroupsGetResponse
     */
    'groups'?: any;
}
/**
 * 
 * @export
 * @interface UsersPasswordPostRequest
 */
export interface UsersPasswordPostRequest {
    /**
     * 
     * @type {UsersPasswordPostRequestUser}
     * @memberof UsersPasswordPostRequest
     */
    'user'?: UsersPasswordPostRequestUser;
}
/**
 * 
 * @export
 * @interface UsersPasswordPostRequestUser
 */
export interface UsersPasswordPostRequestUser {
    [key: string]: any;

    /**
     * 
     * @type {any}
     * @memberof UsersPasswordPostRequestUser
     */
    'original_password': any;
    /**
     * 
     * @type {any}
     * @memberof UsersPasswordPostRequestUser
     */
    'password': any;
}
/**
 * 
 * @export
 * @interface UsersPostRequest
 */
export interface UsersPostRequest {
    /**
     * 
     * @type {UsersPostRequestUser}
     * @memberof UsersPostRequest
     */
    'user'?: UsersPostRequestUser;
}
/**
 * 
 * @export
 * @interface UsersPostRequestUser
 */
export interface UsersPostRequestUser {
    [key: string]: any;

    /**
     * 
     * @type {string}
     * @memberof UsersPostRequestUser
     */
    'default_project_id'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequestUser
     */
    'description'?: string | null;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequestUser
     */
    'domain_id'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UsersPostRequestUser
     */
    'enabled'?: UsersPostRequestUserEnabledEnum;
    /**
     * 
     * @type {any}
     * @memberof UsersPostRequestUser
     */
    'federated'?: any;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequestUser
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UsersPostRequestUser
     */
    'password'?: string | null;
    /**
     * 
     * @type {UserGetResponseUserOptions}
     * @memberof UsersPostRequestUser
     */
    'options'?: UserGetResponseUserOptions;
}

export const UsersPostRequestUserEnabledEnum = {
    True: true,
    False: false,
    Null: null
} as const;

export type UsersPostRequestUserEnabledEnum = typeof UsersPostRequestUserEnabledEnum[keyof typeof UsersPostRequestUserEnabledEnum];

/**
 * 
 * @export
 * @interface UsersProjectsGetResponse
 */
export interface UsersProjectsGetResponse {
    /**
     * A list of project objects
     * @type {any}
     * @memberof UsersProjectsGetResponse
     */
    'projects'?: any;
}

/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCatalogGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCatalogHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/catalog`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDomainsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDomainsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2/ecp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2/ecp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a scoped token for an ECP assertion.  POST /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {AuthOsFederationSaml2EcpPostRequest} [authOsFederationSaml2EcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpPost: async (authOsFederationSaml2EcpPostRequest?: AuthOsFederationSaml2EcpPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2/ecp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authOsFederationSaml2EcpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Get: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Head: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Exchange a scoped token for a SAML assertion.  POST /v3/auth/OS-FEDERATION/saml2
         * @param {AuthOsFederationSaml2PostRequest} [authOsFederationSaml2PostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Post: async (authOsFederationSaml2PostRequest?: AuthOsFederationSaml2PostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/OS-FEDERATION/saml2`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authOsFederationSaml2PostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdGet: async (protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONWebssoProtocolIdGet', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/websso/{protocol_id}`
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdHead: async (protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONWebssoProtocolIdHead', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/websso/{protocol_id}`
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdPost: async (protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('authOSFEDERATIONWebssoProtocolIdPost', 'protocolId', protocolId)
            const localVarPath = `/v3/auth/OS-FEDERATION/websso/{protocol_id}`
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProjectsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProjectsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSystemGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSystemHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/system`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a token.  DELETE /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {string} xSubjectToken The authentication token. An authentication response returns the token ID in this header rather than in the response body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensGet: async (xSubjectToken: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'xSubjectToken' is not null or undefined
            assertParamExists('authTokensGet', 'xSubjectToken', xSubjectToken)
            const localVarPath = `/v3/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (xSubjectToken != null) {
                localVarHeaderParameter['X-Subject-Token'] = String(xSubjectToken);
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensOSPKIRevokedGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/tokens/OS-PKI/revoked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensOSPKIRevokedHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/tokens/OS-PKI/revoked`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Issue a token.  POST /v3/auth/tokens
         * @param {AuthTokensPostRequest} [authTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensPost: async (authTokensPostRequest?: AuthTokensPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/auth/tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authTokensPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCatalogGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthCatalogGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCatalogGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authCatalogGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCatalogHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCatalogHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authCatalogHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDomainsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthDomainsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDomainsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authDomainsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authDomainsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authDomainsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authDomainsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthOsFederationIdentityProvidersProtocolsWebssoGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthOsFederationIdentityProvidersProtocolsWebssoPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2EcpGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2EcpGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2EcpGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2EcpHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2EcpHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2EcpHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Exchange a scoped token for an ECP assertion.  POST /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {AuthOsFederationSaml2EcpPostRequest} [authOsFederationSaml2EcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest?: AuthOsFederationSaml2EcpPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2EcpPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2Get(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2Get(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2Get']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2Head(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2Head(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2Head']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Exchange a scoped token for a SAML assertion.  POST /v3/auth/OS-FEDERATION/saml2
         * @param {AuthOsFederationSaml2PostRequest} [authOsFederationSaml2PostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest?: AuthOsFederationSaml2PostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONSaml2Post']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONWebssoProtocolIdGet(protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthOsFederationWebssoGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONWebssoProtocolIdGet(protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONWebssoProtocolIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONWebssoProtocolIdHead(protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONWebssoProtocolIdHead(protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONWebssoProtocolIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authOSFEDERATIONWebssoProtocolIdPost(protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthOsFederationWebssoPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authOSFEDERATIONWebssoProtocolIdPost(protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authOSFEDERATIONWebssoProtocolIdPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProjectsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthProjectsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProjectsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authProjectsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authProjectsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSystemGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSystemGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSystemGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authSystemGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSystemHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSystemHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authSystemHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a token.  DELETE /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensDelete(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {string} xSubjectToken The authentication token. An authentication response returns the token ID in this header rather than in the response body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensGet(xSubjectToken: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokensGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensGet(xSubjectToken, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensOSPKIRevokedGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensOSPKIRevokedGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensOSPKIRevokedGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensOSPKIRevokedHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensOSPKIRevokedHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensOSPKIRevokedHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Issue a token.  POST /v3/auth/tokens
         * @param {AuthTokensPostRequest} [authTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokensPost(authTokensPostRequest?: AuthTokensPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthTokensPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokensPost(authTokensPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['AuthApi.authTokensPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCatalogGet(options?: any): AxiosPromise<AuthCatalogGetResponse> {
            return localVarFp.authCatalogGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get service catalog for token.  GET/HEAD /v3/auth/catalog
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCatalogHead(options?: any): AxiosPromise<void> {
            return localVarFp.authCatalogHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDomainsGet(options?: any): AxiosPromise<AuthDomainsGetResponse> {
            return localVarFp.authDomainsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authDomainsHead(options?: any): AxiosPromise<void> {
            return localVarFp.authDomainsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId: string, protocolId: string, options?: any): AxiosPromise<AuthOsFederationIdentityProvidersProtocolsWebssoGetResponse> {
            return localVarFp.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId: string, protocolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
         * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId: string, protocolId: string, options?: any): AxiosPromise<AuthOsFederationIdentityProvidersProtocolsWebssoPostResponse> {
            return localVarFp.authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpGet(options?: any): AxiosPromise<object> {
            return localVarFp.authOSFEDERATIONSaml2EcpGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpHead(options?: any): AxiosPromise<void> {
            return localVarFp.authOSFEDERATIONSaml2EcpHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a scoped token for an ECP assertion.  POST /v3/auth/OS-FEDERATION/saml2/ecp
         * @param {AuthOsFederationSaml2EcpPostRequest} [authOsFederationSaml2EcpPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest?: AuthOsFederationSaml2EcpPostRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Get(options?: any): AxiosPromise<object> {
            return localVarFp.authOSFEDERATIONSaml2Get(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/saml2
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Head(options?: any): AxiosPromise<void> {
            return localVarFp.authOSFEDERATIONSaml2Head(options).then((request) => request(axios, basePath));
        },
        /**
         * Exchange a scoped token for a SAML assertion.  POST /v3/auth/OS-FEDERATION/saml2
         * @param {AuthOsFederationSaml2PostRequest} [authOsFederationSaml2PostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest?: AuthOsFederationSaml2PostRequest, options?: any): AxiosPromise<string> {
            return localVarFp.authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdGet(protocolId: string, options?: any): AxiosPromise<AuthOsFederationWebssoGetResponse> {
            return localVarFp.authOSFEDERATIONWebssoProtocolIdGet(protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdHead(protocolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.authOSFEDERATIONWebssoProtocolIdHead(protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
         * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authOSFEDERATIONWebssoProtocolIdPost(protocolId: string, options?: any): AxiosPromise<AuthOsFederationWebssoPostResponse> {
            return localVarFp.authOSFEDERATIONWebssoProtocolIdPost(protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProjectsGet(options?: any): AxiosPromise<AuthProjectsGetResponse> {
            return localVarFp.authProjectsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authProjectsHead(options?: any): AxiosPromise<void> {
            return localVarFp.authProjectsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSystemGet(options?: any): AxiosPromise<AuthSystemGetResponse> {
            return localVarFp.authSystemGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible system scopes for token.  GET/HEAD /v3/auth/system
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSystemHead(options?: any): AxiosPromise<void> {
            return localVarFp.authSystemHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a token.  DELETE /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensDelete(options?: any): AxiosPromise<void> {
            return localVarFp.authTokensDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {string} xSubjectToken The authentication token. An authentication response returns the token ID in this header rather than in the response body.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensGet(xSubjectToken: string, options?: any): AxiosPromise<AuthTokensGetResponse> {
            return localVarFp.authTokensGet(xSubjectToken, options).then((request) => request(axios, basePath));
        },
        /**
         * Validate a token.  HEAD/GET /v3/auth/tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensHead(options?: any): AxiosPromise<void> {
            return localVarFp.authTokensHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensOSPKIRevokedGet(options?: any): AxiosPromise<object> {
            return localVarFp.authTokensOSPKIRevokedGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensOSPKIRevokedHead(options?: any): AxiosPromise<void> {
            return localVarFp.authTokensOSPKIRevokedHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Issue a token.  POST /v3/auth/tokens
         * @param {AuthTokensPostRequest} [authTokensPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokensPost(authTokensPostRequest?: AuthTokensPostRequest, options?: any): AxiosPromise<AuthTokensPostResponse> {
            return localVarFp.authTokensPost(authTokensPostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Get service catalog for token.  GET/HEAD /v3/auth/catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCatalogGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCatalogGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get service catalog for token.  GET/HEAD /v3/auth/catalog
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCatalogHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCatalogHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDomainsGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDomainsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authDomainsHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authDomainsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
     * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoGet(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
     * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoHead(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso
     * @param {string} idpId idp_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/websso API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdWebssoPost(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/auth/OS-FEDERATION/saml2/ecp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2EcpGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2EcpGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/auth/OS-FEDERATION/saml2/ecp
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2EcpHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2EcpHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a scoped token for an ECP assertion.  POST /v3/auth/OS-FEDERATION/saml2/ecp
     * @param {AuthOsFederationSaml2EcpPostRequest} [authOsFederationSaml2EcpPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest?: AuthOsFederationSaml2EcpPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2EcpPost(authOsFederationSaml2EcpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/auth/OS-FEDERATION/saml2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2Get(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2Get(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/auth/OS-FEDERATION/saml2
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2Head(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2Head(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Exchange a scoped token for a SAML assertion.  POST /v3/auth/OS-FEDERATION/saml2
     * @param {AuthOsFederationSaml2PostRequest} [authOsFederationSaml2PostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest?: AuthOsFederationSaml2PostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONSaml2Post(authOsFederationSaml2PostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONWebssoProtocolIdGet(protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONWebssoProtocolIdGet(protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONWebssoProtocolIdHead(protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONWebssoProtocolIdHead(protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/auth/OS-FEDERATION/websso/{protocol_id}
     * @param {string} protocolId protocol_id parameter for /v3/auth/OS-FEDERATION/websso/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authOSFEDERATIONWebssoProtocolIdPost(protocolId: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authOSFEDERATIONWebssoProtocolIdPost(protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authProjectsGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authProjectsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authProjectsHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authProjectsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible system scopes for token.  GET/HEAD /v3/auth/system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSystemGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSystemGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible system scopes for token.  GET/HEAD /v3/auth/system
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSystemHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSystemHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a token.  DELETE /v3/auth/tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensDelete(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a token.  HEAD/GET /v3/auth/tokens
     * @param {string} xSubjectToken The authentication token. An authentication response returns the token ID in this header rather than in the response body.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensGet(xSubjectToken: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensGet(xSubjectToken, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Validate a token.  HEAD/GET /v3/auth/tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensOSPKIRevokedGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensOSPKIRevokedGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deprecated; get revoked token list.  GET/HEAD /v3/auth/tokens/OS-PKI/revoked
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensOSPKIRevokedHead(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensOSPKIRevokedHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Issue a token.  POST /v3/auth/tokens
     * @param {AuthTokensPostRequest} [authTokensPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokensPost(authTokensPostRequest?: AuthTokensPostRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokensPost(authTokensPostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * CredentialsApi - axios parameter creator
 * @export
 */
export const CredentialsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DELETE operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdDelete: async (credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('credentialsCredentialIdDelete', 'credentialId', credentialId)
            const localVarPath = `/v3/credentials/{credential_id}`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdGet: async (credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('credentialsCredentialIdGet', 'credentialId', credentialId)
            const localVarPath = `/v3/credentials/{credential_id}`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdHead: async (credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('credentialsCredentialIdHead', 'credentialId', credentialId)
            const localVarPath = `/v3/credentials/{credential_id}`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdPatch: async (credentialId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('credentialsCredentialIdPatch', 'credentialId', credentialId)
            const localVarPath = `/v3/credentials/{credential_id}`
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/credentials
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsPost: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CredentialsApi - functional programming interface
 * @export
 */
export const CredentialsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CredentialsApiAxiosParamCreator(configuration)
    return {
        /**
         * DELETE operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsCredentialIdDelete(credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsCredentialIdDelete(credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsCredentialIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsCredentialIdGet(credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsCredentialIdGet(credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsCredentialIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsCredentialIdHead(credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsCredentialIdHead(credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsCredentialIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsCredentialIdPatch(credentialId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsCredentialIdPatch(credentialId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsCredentialIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/credentials
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async credentialsPost(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.credentialsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['CredentialsApi.credentialsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * CredentialsApi - factory interface
 * @export
 */
export const CredentialsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CredentialsApiFp(configuration)
    return {
        /**
         * DELETE operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdDelete(credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsCredentialIdDelete(credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdGet(credentialId: string, options?: any): AxiosPromise<object> {
            return localVarFp.credentialsCredentialIdGet(credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdHead(credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.credentialsCredentialIdHead(credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/credentials/{credential_id}
         * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsCredentialIdPatch(credentialId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.credentialsCredentialIdPatch(credentialId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsGet(options?: any): AxiosPromise<object> {
            return localVarFp.credentialsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/credentials
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsHead(options?: any): AxiosPromise<void> {
            return localVarFp.credentialsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/credentials
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        credentialsPost(body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.credentialsPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CredentialsApi - object-oriented interface
 * @export
 * @class CredentialsApi
 * @extends {BaseAPI}
 */
export class CredentialsApi extends BaseAPI {
    /**
     * DELETE operation on /v3/credentials/{credential_id}
     * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsCredentialIdDelete(credentialId: string, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsCredentialIdDelete(credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/credentials/{credential_id}
     * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsCredentialIdGet(credentialId: string, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsCredentialIdGet(credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/credentials/{credential_id}
     * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsCredentialIdHead(credentialId: string, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsCredentialIdHead(credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/credentials/{credential_id}
     * @param {string} credentialId credential_id parameter for /v3/credentials/{credential_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsCredentialIdPatch(credentialId: string, body?: object, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsCredentialIdPatch(credentialId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsGet(options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/credentials
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsHead(options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/credentials
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CredentialsApi
     */
    public credentialsPost(body?: object, options?: RawAxiosRequestConfig) {
        return CredentialsApiFp(this.configuration).credentialsPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainConfigurationApi - axios parameter creator
 * @export
 */
export const DomainConfigurationApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigDefaultGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/domains/config/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigDefaultHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/domains/config/default`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupDefaultGet: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsConfigGroupDefaultGet', 'group', group)
            const localVarPath = `/v3/domains/config/{group}/default`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupDefaultHead: async (group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsConfigGroupDefaultHead', 'group', group)
            const localVarPath = `/v3/domains/config/{group}/default`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupOptionDefaultGet: async (group: string, option: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsConfigGroupOptionDefaultGet', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsConfigGroupOptionDefaultGet', 'option', option)
            const localVarPath = `/v3/domains/config/{group}/{option}/default`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupOptionDefaultHead: async (group: string, option: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsConfigGroupOptionDefaultHead', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsConfigGroupOptionDefaultHead', 'option', option)
            const localVarPath = `/v3/domains/config/{group}/{option}/default`
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigDelete: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigDelete', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}/config`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGet: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGet', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}/config`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupDelete: async (domainId: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupDelete', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupDelete', 'group', group)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupGet: async (domainId: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupGet', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupGet', 'group', group)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupHead: async (domainId: string, group: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupHead', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupHead', 'group', group)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionDelete: async (domainId: string, group: string, option: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionDelete', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionDelete', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionDelete', 'option', option)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}/{option}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionGet: async (domainId: string, group: string, option: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionGet', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionGet', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionGet', 'option', option)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}/{option}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionHead: async (domainId: string, group: string, option: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionHead', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionHead', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionHead', 'option', option)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}/{option}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroupOption} [domainConfigGroupOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionPatch: async (domainId: string, group: string, option: string, domainConfigGroupOption?: DomainConfigGroupOption, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionPatch', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionPatch', 'group', group)
            // verify required parameter 'option' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupOptionPatch', 'option', option)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}/{option}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)))
                .replace(`{${"option"}}`, encodeURIComponent(String(option)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainConfigGroupOption, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroup} [domainConfigGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupPatch: async (domainId: string, group: string, domainConfigGroup?: DomainConfigGroup, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupPatch', 'domainId', domainId)
            // verify required parameter 'group' is not null or undefined
            assertParamExists('domainsDomainIdConfigGroupPatch', 'group', group)
            const localVarPath = `/v3/domains/{domain_id}/config/{group}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group"}}`, encodeURIComponent(String(group)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainConfigGroup, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigHead: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigHead', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}/config`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigPatch: async (domainId: string, domainConfig?: DomainConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigPatch', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}/config`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create domain config.  PUT /v3/domains/{domain_id}/config
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigPut: async (domainId: string, domainConfig?: DomainConfig, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdConfigPut', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}/config`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domainConfig, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainConfigurationApi - functional programming interface
 * @export
 */
export const DomainConfigurationApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainConfigurationApiAxiosParamCreator(configuration)
    return {
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigDefaultGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigDefaultGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigDefaultGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigDefaultHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigDefaultHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigDefaultHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigGroupDefaultGet(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigGroupDefaultGet(group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigGroupDefaultGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigGroupDefaultHead(group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigGroupDefaultHead(group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigGroupDefaultHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigGroupOptionDefaultGet(group: string, option: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroupOption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigGroupOptionDefaultGet(group, option, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigGroupOptionDefaultGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsConfigGroupOptionDefaultHead(group: string, option: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsConfigGroupOptionDefaultHead(group, option, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsConfigGroupOptionDefaultHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigDelete(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigDelete(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGet(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGet(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupDelete(domainId: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupDelete(domainId, group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupGet(domainId: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupGet(domainId, group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupHead(domainId: string, group: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupHead(domainId, group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupOptionDelete(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupOptionDelete(domainId, group, option, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupOptionDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupOptionGet(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroupOption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupOptionGet(domainId, group, option, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupOptionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupOptionHead(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupOptionHead(domainId, group, option, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupOptionHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroupOption} [domainConfigGroupOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupOptionPatch(domainId: string, group: string, option: string, domainConfigGroupOption?: DomainConfigGroupOption, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroupOption>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupOptionPatch(domainId, group, option, domainConfigGroupOption, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupOptionPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroup} [domainConfigGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigGroupPatch(domainId: string, group: string, domainConfigGroup?: DomainConfigGroup, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfigGroup>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigGroupPatch(domainId, group, domainConfigGroup, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigGroupPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigHead(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigHead(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigPatch(domainId: string, domainConfig?: DomainConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigPatch(domainId, domainConfig, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create domain config.  PUT /v3/domains/{domain_id}/config
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdConfigPut(domainId: string, domainConfig?: DomainConfig, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainConfig>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdConfigPut(domainId, domainConfig, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainConfigurationApi.domainsDomainIdConfigPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DomainConfigurationApi - factory interface
 * @export
 */
export const DomainConfigurationApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainConfigurationApiFp(configuration)
    return {
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigDefaultGet(options?: any): AxiosPromise<DomainConfig> {
            return localVarFp.domainsConfigDefaultGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get default domain config.  GET/HEAD /v3/domains/config/default
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigDefaultHead(options?: any): AxiosPromise<void> {
            return localVarFp.domainsConfigDefaultHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupDefaultGet(group: string, options?: any): AxiosPromise<DomainConfigGroup> {
            return localVarFp.domainsConfigGroupDefaultGet(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupDefaultHead(group: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsConfigGroupDefaultHead(group, options).then((request) => request(axios, basePath));
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupOptionDefaultGet(group: string, option: string, options?: any): AxiosPromise<DomainConfigGroupOption> {
            return localVarFp.domainsConfigGroupOptionDefaultGet(group, option, options).then((request) => request(axios, basePath));
        },
        /**
         * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
         * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
         * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsConfigGroupOptionDefaultHead(group: string, option: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsConfigGroupOptionDefaultHead(group, option, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigDelete(domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigDelete(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGet(domainId: string, options?: any): AxiosPromise<DomainConfig> {
            return localVarFp.domainsDomainIdConfigGet(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupDelete(domainId: string, group: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigGroupDelete(domainId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupGet(domainId: string, group: string, options?: any): AxiosPromise<DomainConfigGroup> {
            return localVarFp.domainsDomainIdConfigGroupGet(domainId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupHead(domainId: string, group: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigGroupHead(domainId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionDelete(domainId: string, group: string, option: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigGroupOptionDelete(domainId, group, option, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionGet(domainId: string, group: string, option: string, options?: any): AxiosPromise<DomainConfigGroupOption> {
            return localVarFp.domainsDomainIdConfigGroupOptionGet(domainId, group, option, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionHead(domainId: string, group: string, option: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigGroupOptionHead(domainId, group, option, options).then((request) => request(axios, basePath));
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroupOption} [domainConfigGroupOption] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupOptionPatch(domainId: string, group: string, option: string, domainConfigGroupOption?: DomainConfigGroupOption, options?: any): AxiosPromise<DomainConfigGroupOption> {
            return localVarFp.domainsDomainIdConfigGroupOptionPatch(domainId, group, option, domainConfigGroupOption, options).then((request) => request(axios, basePath));
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfigGroup} [domainConfigGroup] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigGroupPatch(domainId: string, group: string, domainConfigGroup?: DomainConfigGroup, options?: any): AxiosPromise<DomainConfigGroup> {
            return localVarFp.domainsDomainIdConfigGroupPatch(domainId, group, domainConfigGroup, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigHead(domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdConfigHead(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigPatch(domainId: string, domainConfig?: DomainConfig, options?: any): AxiosPromise<DomainConfig> {
            return localVarFp.domainsDomainIdConfigPatch(domainId, domainConfig, options).then((request) => request(axios, basePath));
        },
        /**
         * Create domain config.  PUT /v3/domains/{domain_id}/config
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
         * @param {DomainConfig} [domainConfig] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdConfigPut(domainId: string, domainConfig?: DomainConfig, options?: any): AxiosPromise<DomainConfig> {
            return localVarFp.domainsDomainIdConfigPut(domainId, domainConfig, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainConfigurationApi - object-oriented interface
 * @export
 * @class DomainConfigurationApi
 * @extends {BaseAPI}
 */
export class DomainConfigurationApi extends BaseAPI {
    /**
     * Get default domain config.  GET/HEAD /v3/domains/config/default
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigDefaultGet(options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigDefaultGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get default domain config.  GET/HEAD /v3/domains/config/default
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigDefaultHead(options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigDefaultHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
     * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigGroupDefaultGet(group: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigGroupDefaultGet(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get default domain group config.  GET/HEAD /v3/domains/config/{group}/default
     * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigGroupDefaultHead(group: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigGroupDefaultHead(group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
     * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
     * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigGroupOptionDefaultGet(group: string, option: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigGroupOptionDefaultGet(group, option, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get default domain group option config.  GET/HEAD /v3/domains/config/{group}/{option}/default
     * @param {string} group group parameter for /v3/domains/config/{group}/{option}/default API
     * @param {string} option option parameter for /v3/domains/config/{group}/{option}/default API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsConfigGroupOptionDefaultHead(group: string, option: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsConfigGroupOptionDefaultHead(group, option, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigDelete(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigDelete(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGet(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGet(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupDelete(domainId: string, group: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupDelete(domainId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupGet(domainId: string, group: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupGet(domainId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupHead(domainId: string, group: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupHead(domainId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete domain config.  DELETE /v3/domains/{domain_id}/config DELETE /v3/domains/{domain_id}/config/{group} DELETE /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupOptionDelete(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupOptionDelete(domainId, group, option, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupOptionGet(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupOptionGet(domainId, group, option, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupOptionHead(domainId: string, group: string, option: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupOptionHead(domainId, group, option, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} option option parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {DomainConfigGroupOption} [domainConfigGroupOption] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupOptionPatch(domainId: string, group: string, option: string, domainConfigGroupOption?: DomainConfigGroupOption, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupOptionPatch(domainId, group, option, domainConfigGroupOption, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {string} group group parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {DomainConfigGroup} [domainConfigGroup] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigGroupPatch(domainId: string, group: string, domainConfigGroup?: DomainConfigGroup, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigGroupPatch(domainId, group, domainConfigGroup, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if config option exists.  GET/HEAD /v3/domains/{domain_id}/config GET/HEAD /v3/domains/{domain_id}/config/{group} GET/HEAD /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigHead(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigHead(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update domain config option.  PATCH /v3/domains/{domain_id}/config PATCH /v3/domains/{domain_id}/config/{group} PATCH /v3/domains/{domain_id}/config/{group}/{option}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {DomainConfig} [domainConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigPatch(domainId: string, domainConfig?: DomainConfig, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigPatch(domainId, domainConfig, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create domain config.  PUT /v3/domains/{domain_id}/config
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/config/{group}/{option} API
     * @param {DomainConfig} [domainConfig] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainConfigurationApi
     */
    public domainsDomainIdConfigPut(domainId: string, domainConfig?: DomainConfig, options?: RawAxiosRequestConfig) {
        return DomainConfigurationApiFp(this.configuration).domainsDomainIdConfigPut(domainId, domainConfig, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DomainsApi - axios parameter creator
 * @export
 */
export const DomainsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Delete domain.  DELETE /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdDelete: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdDelete', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGet: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGet', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdHead: async (domainId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdHead', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update domain.  PATCH /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdPatch: async (domainId: string, domain?: Domain, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdPatch', 'domainId', domainId)
            const localVarPath = `/v3/domains/{domain_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} [name] Filters the response by a domain name.
         * @param {boolean} [enabled] If set to true, then only domains that are enabled will be returned, if set to false only that are disabled will be returned. Any value other than 0, including no value, will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsGet: async (name?: string, enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create domain.  POST /v3/domains
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsPost: async (domain?: Domain, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(domain, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DomainsApi - functional programming interface
 * @export
 */
export const DomainsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DomainsApiAxiosParamCreator(configuration)
    return {
        /**
         * Delete domain.  DELETE /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdDelete(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdDelete(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsDomainIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGet(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGet(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsDomainIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdHead(domainId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdHead(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsDomainIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update domain.  PATCH /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdPatch(domainId: string, domain?: Domain, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdPatch(domainId, domain, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsDomainIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} [name] Filters the response by a domain name.
         * @param {boolean} [enabled] If set to true, then only domains that are enabled will be returned, if set to false only that are disabled will be returned. Any value other than 0, including no value, will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsGet(name?: string, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DomainsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsGet(name, enabled, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create domain.  POST /v3/domains
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsPost(domain?: Domain, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Domain>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsPost(domain, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['DomainsApi.domainsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * DomainsApi - factory interface
 * @export
 */
export const DomainsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DomainsApiFp(configuration)
    return {
        /**
         * Delete domain.  DELETE /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdDelete(domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdDelete(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGet(domainId: string, options?: any): AxiosPromise<Domain> {
            return localVarFp.domainsDomainIdGet(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdHead(domainId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdHead(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update domain.  PATCH /v3/domains/{domain_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdPatch(domainId: string, domain?: Domain, options?: any): AxiosPromise<Domain> {
            return localVarFp.domainsDomainIdPatch(domainId, domain, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {string} [name] Filters the response by a domain name.
         * @param {boolean} [enabled] If set to true, then only domains that are enabled will be returned, if set to false only that are disabled will be returned. Any value other than 0, including no value, will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsGet(name?: string, enabled?: boolean, options?: any): AxiosPromise<DomainsGetResponse> {
            return localVarFp.domainsGet(name, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsHead(options?: any): AxiosPromise<void> {
            return localVarFp.domainsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create domain.  POST /v3/domains
         * @param {Domain} [domain] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsPost(domain?: Domain, options?: any): AxiosPromise<Domain> {
            return localVarFp.domainsPost(domain, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DomainsApi - object-oriented interface
 * @export
 * @class DomainsApi
 * @extends {BaseAPI}
 */
export class DomainsApi extends BaseAPI {
    /**
     * Delete domain.  DELETE /v3/domains/{domain_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsDomainIdDelete(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsDomainIdDelete(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsDomainIdGet(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsDomainIdGet(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsDomainIdHead(domainId: string, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsDomainIdHead(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update domain.  PATCH /v3/domains/{domain_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id} API
     * @param {Domain} [domain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsDomainIdPatch(domainId: string, domain?: Domain, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsDomainIdPatch(domainId, domain, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
     * @param {string} [name] Filters the response by a domain name.
     * @param {boolean} [enabled] If set to true, then only domains that are enabled will be returned, if set to false only that are disabled will be returned. Any value other than 0, including no value, will be interpreted as true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsGet(name?: string, enabled?: boolean, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsGet(name, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get domain or list domains.  GET/HEAD /v3/domains GET/HEAD /v3/domains/{domain_id}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsHead(options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create domain.  POST /v3/domains
     * @param {Domain} [domain] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DomainsApi
     */
    public domainsPost(domain?: Domain, options?: RawAxiosRequestConfig) {
        return DomainsApiFp(this.configuration).domainsPost(domain, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * Ec2tokensApi - axios parameter creator
 * @export
 */
export const Ec2tokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/ec2tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/ec2tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate ec2 token.  POST /v3/ec2tokens
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensPost: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/ec2tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * Ec2tokensApi - functional programming interface
 * @export
 */
export const Ec2tokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = Ec2tokensApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ec2tokensGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ec2tokensGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['Ec2tokensApi.ec2tokensGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ec2tokensHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ec2tokensHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['Ec2tokensApi.ec2tokensHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authenticate ec2 token.  POST /v3/ec2tokens
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async ec2tokensPost(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.ec2tokensPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['Ec2tokensApi.ec2tokensPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * Ec2tokensApi - factory interface
 * @export
 */
export const Ec2tokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = Ec2tokensApiFp(configuration)
    return {
        /**
         * GET operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensGet(options?: any): AxiosPromise<object> {
            return localVarFp.ec2tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/ec2tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensHead(options?: any): AxiosPromise<void> {
            return localVarFp.ec2tokensHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate ec2 token.  POST /v3/ec2tokens
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        ec2tokensPost(body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.ec2tokensPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Ec2tokensApi - object-oriented interface
 * @export
 * @class Ec2tokensApi
 * @extends {BaseAPI}
 */
export class Ec2tokensApi extends BaseAPI {
    /**
     * GET operation on /v3/ec2tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Ec2tokensApi
     */
    public ec2tokensGet(options?: RawAxiosRequestConfig) {
        return Ec2tokensApiFp(this.configuration).ec2tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/ec2tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Ec2tokensApi
     */
    public ec2tokensHead(options?: RawAxiosRequestConfig) {
        return Ec2tokensApiFp(this.configuration).ec2tokensHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate ec2 token.  POST /v3/ec2tokens
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof Ec2tokensApi
     */
    public ec2tokensPost(body?: object, options?: RawAxiosRequestConfig) {
        return Ec2tokensApiFp(this.configuration).ec2tokensPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * EndpointsApi - axios parameter creator
 * @export
 */
export const EndpointsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DELETE operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdDelete: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdDelete', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdGet: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdGet', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdHead: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdHead', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        endpointsEndpointIdOSENDPOINTPOLICYPolicyGet: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdOSENDPOINTPOLICYPolicyGet', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdOSENDPOINTPOLICYPolicyHead: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdOSENDPOINTPOLICYPolicyHead', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdPatch: async (endpointId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('endpointsEndpointIdPatch', 'endpointId', endpointId)
            const localVarPath = `/v3/endpoints/{endpoint_id}`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/endpoints
         * @param {string} [serviceId] Filters the response by a service ID.
         * @param {string} [region] Filters the response by a region ID.
         * @param {EndpointsGetInterfaceEnum} [_interface] Filters the response by an interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsGet: async (serviceId?: string, region?: string, _interface?: EndpointsGetInterfaceEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (serviceId !== undefined) {
                localVarQueryParameter['service_id'] = serviceId;
            }

            if (region !== undefined) {
                localVarQueryParameter['region'] = region;
            }

            if (_interface !== undefined) {
                localVarQueryParameter['interface'] = _interface;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/endpoints
         * @param {Endpoint} [endpoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsPost: async (endpoint?: Endpoint, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/endpoints`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(endpoint, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EndpointsApi - functional programming interface
 * @export
 */
export const EndpointsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = EndpointsApiAxiosParamCreator(configuration)
    return {
        /**
         * DELETE operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsEndpointIdDelete(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdDelete(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsEndpointIdGet(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Endpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdGet(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsEndpointIdHead(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdHead(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdOSENDPOINTPOLICYPolicyGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdOSENDPOINTPOLICYPolicyHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsEndpointIdPatch(endpointId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Endpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsEndpointIdPatch(endpointId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsEndpointIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/endpoints
         * @param {string} [serviceId] Filters the response by a service ID.
         * @param {string} [region] Filters the response by a region ID.
         * @param {EndpointsGetInterfaceEnum} [_interface] Filters the response by an interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsGet(serviceId?: string, region?: string, _interface?: EndpointsGetInterfaceEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EndpointsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsGet(serviceId, region, _interface, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/endpoints
         * @param {Endpoint} [endpoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async endpointsPost(endpoint?: Endpoint, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Endpoint>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.endpointsPost(endpoint, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['EndpointsApi.endpointsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * EndpointsApi - factory interface
 * @export
 */
export const EndpointsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = EndpointsApiFp(configuration)
    return {
        /**
         * DELETE operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdDelete(endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsEndpointIdDelete(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdGet(endpointId: string, options?: any): AxiosPromise<Endpoint> {
            return localVarFp.endpointsEndpointIdGet(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdHead(endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsEndpointIdHead(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId: string, options?: any): AxiosPromise<object> {
            return localVarFp.endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/endpoints/{endpoint_id}
         * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsEndpointIdPatch(endpointId: string, body?: object, options?: any): AxiosPromise<Endpoint> {
            return localVarFp.endpointsEndpointIdPatch(endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/endpoints
         * @param {string} [serviceId] Filters the response by a service ID.
         * @param {string} [region] Filters the response by a region ID.
         * @param {EndpointsGetInterfaceEnum} [_interface] Filters the response by an interface.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsGet(serviceId?: string, region?: string, _interface?: EndpointsGetInterfaceEnum, options?: any): AxiosPromise<EndpointsGetResponse> {
            return localVarFp.endpointsGet(serviceId, region, _interface, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/endpoints
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsHead(options?: any): AxiosPromise<void> {
            return localVarFp.endpointsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/endpoints
         * @param {Endpoint} [endpoint] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        endpointsPost(endpoint?: Endpoint, options?: any): AxiosPromise<Endpoint> {
            return localVarFp.endpointsPost(endpoint, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * EndpointsApi - object-oriented interface
 * @export
 * @class EndpointsApi
 * @extends {BaseAPI}
 */
export class EndpointsApi extends BaseAPI {
    /**
     * DELETE operation on /v3/endpoints/{endpoint_id}
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdDelete(endpointId: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdDelete(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/endpoints/{endpoint_id}
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdGet(endpointId: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdGet(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/endpoints/{endpoint_id}
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdHead(endpointId: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdHead(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdOSENDPOINTPOLICYPolicyGet(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id}/OS-ENDPOINT-POLICY/policy API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId: string, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdOSENDPOINTPOLICYPolicyHead(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/endpoints/{endpoint_id}
     * @param {string} endpointId endpoint_id parameter for /v3/endpoints/{endpoint_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsEndpointIdPatch(endpointId: string, body?: object, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsEndpointIdPatch(endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/endpoints
     * @param {string} [serviceId] Filters the response by a service ID.
     * @param {string} [region] Filters the response by a region ID.
     * @param {EndpointsGetInterfaceEnum} [_interface] Filters the response by an interface.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsGet(serviceId?: string, region?: string, _interface?: EndpointsGetInterfaceEnum, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsGet(serviceId, region, _interface, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/endpoints
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsHead(options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/endpoints
     * @param {Endpoint} [endpoint] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EndpointsApi
     */
    public endpointsPost(endpoint?: Endpoint, options?: RawAxiosRequestConfig) {
        return EndpointsApiFp(this.configuration).endpointsPost(endpoint, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const EndpointsGetInterfaceEnum = {
    Public: 'public',
    Internal: 'internal',
    Admin: 'admin'
} as const;
export type EndpointsGetInterfaceEnum = typeof EndpointsGetInterfaceEnum[keyof typeof EndpointsGetInterfaceEnum];


/**
 * GroupsApi - axios parameter creator
 * @export
 */
export const GroupsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/groups
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet: async (domainId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (domainId !== undefined) {
                localVarQueryParameter['domain_id'] = domainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete group.  DELETE /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdDelete: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdDelete', 'groupId', groupId)
            const localVarPath = `/v3/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdGet', 'groupId', groupId)
            const localVarPath = `/v3/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdHead: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdHead', 'groupId', groupId)
            const localVarPath = `/v3/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update group.  PATCH /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdPatch: async (groupId: string, group?: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdPatch', 'groupId', groupId)
            const localVarPath = `/v3/groups/{group_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersGet: async (passwordExpiresAt?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/groups/{group_id}/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (passwordExpiresAt !== undefined) {
                localVarQueryParameter['password_expires_at'] = (passwordExpiresAt as any instanceof Date) ?
                    (passwordExpiresAt as any).toISOString() :
                    passwordExpiresAt;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersHead: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdUsersHead', 'groupId', groupId)
            const localVarPath = `/v3/groups/{group_id}/users`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Remove user from group.  DELETE /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdDelete: async (groupId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdDelete', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdDelete', 'userId', userId)
            const localVarPath = `/v3/groups/{group_id}/users/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdGet: async (groupId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdGet', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdGet', 'userId', userId)
            const localVarPath = `/v3/groups/{group_id}/users/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdHead: async (groupId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdHead', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdHead', 'userId', userId)
            const localVarPath = `/v3/groups/{group_id}/users/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add user to group.  PUT /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdPut: async (groupId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdPut', 'groupId', groupId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('groupsGroupIdUsersUserIdPut', 'userId', userId)
            const localVarPath = `/v3/groups/{group_id}/users/{user_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create group.  POST /groups
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost: async (group?: Group, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(group, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * GroupsApi - functional programming interface
 * @export
 */
export const GroupsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = GroupsApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/groups
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGet(domainId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGet(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete group.  DELETE /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdDelete(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdGet(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdHead(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdHead(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update group.  PATCH /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdPatch(groupId: string, group?: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdPatch(groupId, group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersGet(passwordExpiresAt?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GroupsUsersGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersGet(passwordExpiresAt, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersHead(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersHead(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Remove user from group.  DELETE /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersUserIdDelete(groupId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersUserIdDelete(groupId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersUserIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersUserIdGet(groupId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersUserIdGet(groupId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersUserIdHead(groupId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersUserIdHead(groupId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersUserIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Add user to group.  PUT /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsGroupIdUsersUserIdPut(groupId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsGroupIdUsersUserIdPut(groupId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsGroupIdUsersUserIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create group.  POST /groups
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async groupsPost(group?: Group, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Group>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.groupsPost(group, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['GroupsApi.groupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * GroupsApi - factory interface
 * @export
 */
export const GroupsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = GroupsApiFp(configuration)
    return {
        /**
         * GET operation on /v3/groups
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGet(domainId?: string, options?: any): AxiosPromise<GroupsGetResponse> {
            return localVarFp.groupsGet(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete group.  DELETE /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdDelete(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdDelete(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdGet(groupId: string, options?: any): AxiosPromise<Group> {
            return localVarFp.groupsGroupIdGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdHead(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdHead(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update group.  PATCH /groups/{group_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdPatch(groupId: string, group?: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.groupsGroupIdPatch(groupId, group, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersGet(passwordExpiresAt?: string, options?: any): AxiosPromise<GroupsUsersGetResponse> {
            return localVarFp.groupsGroupIdUsersGet(passwordExpiresAt, options).then((request) => request(axios, basePath));
        },
        /**
         * Get list of users in group.  GET/HEAD /groups/{group_id}/users
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersHead(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdUsersHead(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Remove user from group.  DELETE /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdDelete(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdUsersUserIdDelete(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdGet(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdUsersUserIdGet(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdHead(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdUsersUserIdHead(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Add user to group.  PUT /groups/{group_id}/users/{user_id}
         * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsGroupIdUsersUserIdPut(groupId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.groupsGroupIdUsersUserIdPut(groupId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsHead(options?: any): AxiosPromise<void> {
            return localVarFp.groupsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create group.  POST /groups
         * @param {Group} [group] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        groupsPost(group?: Group, options?: any): AxiosPromise<Group> {
            return localVarFp.groupsPost(group, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * GroupsApi - object-oriented interface
 * @export
 * @class GroupsApi
 * @extends {BaseAPI}
 */
export class GroupsApi extends BaseAPI {
    /**
     * GET operation on /v3/groups
     * @param {string} [domainId] Filters the response by a domain ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGet(domainId?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGet(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete group.  DELETE /groups/{group_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdDelete(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdDelete(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/groups/{group_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdGet(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/groups/{group_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdHead(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdHead(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update group.  PATCH /groups/{group_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id} API
     * @param {Group} [group] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdPatch(groupId: string, group?: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdPatch(groupId, group, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of users in group.  GET/HEAD /groups/{group_id}/users
     * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersGet(passwordExpiresAt?: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersGet(passwordExpiresAt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get list of users in group.  GET/HEAD /groups/{group_id}/users
     * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersHead(groupId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersHead(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Remove user from group.  DELETE /groups/{group_id}/users/{user_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersUserIdDelete(groupId: string, userId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersUserIdDelete(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersUserIdGet(groupId: string, userId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersUserIdGet(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user is in a group.  GET/HEAD /groups/{group_id}/users/{user_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersUserIdHead(groupId: string, userId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersUserIdHead(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add user to group.  PUT /groups/{group_id}/users/{user_id}
     * @param {string} groupId group_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {string} userId user_id parameter for /v3/groups/{group_id}/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsGroupIdUsersUserIdPut(groupId: string, userId: string, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsGroupIdUsersUserIdPut(groupId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsHead(options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create group.  POST /groups
     * @param {Group} [group] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof GroupsApi
     */
    public groupsPost(group?: Group, options?: RawAxiosRequestConfig) {
        return GroupsApiFp(this.configuration).groupsPost(group, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LimitsApi - axios parameter creator
 * @export
 */
export const LimitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdDelete: async (limitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('limitsLimitIdDelete', 'limitId', limitId)
            const localVarPath = `/v3/limits/{limit_id}`
                .replace(`{${"limit_id"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdGet: async (limitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('limitsLimitIdGet', 'limitId', limitId)
            const localVarPath = `/v3/limits/{limit_id}`
                .replace(`{${"limit_id"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdHead: async (limitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('limitsLimitIdHead', 'limitId', limitId)
            const localVarPath = `/v3/limits/{limit_id}`
                .replace(`{${"limit_id"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdPatch: async (limitId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'limitId' is not null or undefined
            assertParamExists('limitsLimitIdPatch', 'limitId', limitId)
            const localVarPath = `/v3/limits/{limit_id}`
                .replace(`{${"limit_id"}}`, encodeURIComponent(String(limitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsModelGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/limits/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsModelHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/limits/model`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/limits
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsPost: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LimitsApi - functional programming interface
 * @export
 */
export const LimitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LimitsApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsLimitIdDelete(limitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsLimitIdDelete(limitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsLimitIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsLimitIdGet(limitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsLimitIdGet(limitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsLimitIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsLimitIdHead(limitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsLimitIdHead(limitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsLimitIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsLimitIdPatch(limitId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsLimitIdPatch(limitId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsLimitIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsModelGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsModelGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsModelGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsModelHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsModelHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsModelHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/limits
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async limitsPost(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.limitsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['LimitsApi.limitsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * LimitsApi - factory interface
 * @export
 */
export const LimitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LimitsApiFp(configuration)
    return {
        /**
         * GET operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsGet(options?: any): AxiosPromise<object> {
            return localVarFp.limitsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsHead(options?: any): AxiosPromise<void> {
            return localVarFp.limitsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdDelete(limitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.limitsLimitIdDelete(limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdGet(limitId: string, options?: any): AxiosPromise<object> {
            return localVarFp.limitsLimitIdGet(limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdHead(limitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.limitsLimitIdHead(limitId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/limits/{limit_id}
         * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsLimitIdPatch(limitId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.limitsLimitIdPatch(limitId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsModelGet(options?: any): AxiosPromise<object> {
            return localVarFp.limitsModelGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/limits/model
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsModelHead(options?: any): AxiosPromise<void> {
            return localVarFp.limitsModelHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/limits
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        limitsPost(body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.limitsPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LimitsApi - object-oriented interface
 * @export
 * @class LimitsApi
 * @extends {BaseAPI}
 */
export class LimitsApi extends BaseAPI {
    /**
     * GET operation on /v3/limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsGet(options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsHead(options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/limits/{limit_id}
     * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsLimitIdDelete(limitId: string, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsLimitIdDelete(limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/limits/{limit_id}
     * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsLimitIdGet(limitId: string, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsLimitIdGet(limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/limits/{limit_id}
     * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsLimitIdHead(limitId: string, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsLimitIdHead(limitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/limits/{limit_id}
     * @param {string} limitId limit_id parameter for /v3/limits/{limit_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsLimitIdPatch(limitId: string, body?: object, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsLimitIdPatch(limitId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/limits/model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsModelGet(options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsModelGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/limits/model
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsModelHead(options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsModelHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/limits
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LimitsApi
     */
    public limitsPost(body?: object, options?: RawAxiosRequestConfig) {
        return LimitsApiFp(this.configuration).limitsPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSEPFILTERApi - axios parameter creator
 * @export
 */
export const OSEPFILTERApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdDelete: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdDelete', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdGet: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdGet', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdHead: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdHead', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdPatch: async (endpointGroupId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdPatch', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead: async (endpointGroupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead', 'endpointGroupId', endpointGroupId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete: async (endpointGroupId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete', 'endpointGroupId', endpointGroupId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet: async (endpointGroupId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet', 'endpointGroupId', endpointGroupId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead: async (endpointGroupId: string, projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead', 'endpointGroupId', endpointGroupId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut: async (endpointGroupId: string, projectId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointGroupId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut', 'endpointGroupId', endpointGroupId)
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}`
                .replace(`{${"endpoint_group_id"}}`, encodeURIComponent(String(endpointGroupId)))
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsPost: async (body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-EP-FILTER/endpoint_groups`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointsEndpointIdProjectsGet: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointsEndpointIdProjectsGet', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointsEndpointIdProjectsHead: async (endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTEREndpointsEndpointIdProjectsHead', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects`
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointGroupsGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointGroupsGet', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointGroupsHead: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointGroupsHead', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete: async (projectId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete', 'projectId', projectId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet: async (projectId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet', 'projectId', projectId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead: async (projectId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead', 'projectId', projectId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut: async (projectId: string, endpointId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut', 'projectId', projectId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut', 'endpointId', endpointId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsGet', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsHead: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSEPFILTERProjectsProjectIdEndpointsHead', 'projectId', projectId)
            const localVarPath = `/v3/OS-EP-FILTER/projects/{project_id}/endpoints`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSEPFILTERApi - functional programming interface
 * @export
 */
export const OSEPFILTERApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSEPFILTERApiAxiosParamCreator(configuration)
    return {
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId, projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId, projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId, projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId: string, projectId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId, projectId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointGroupsPost(body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointGroupsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointGroupsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointsEndpointIdProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTEREndpointsEndpointIdProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointGroupsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId: string, endpointId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId, endpointId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsGet(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSEPFILTERProjectsProjectIdEndpointsHead(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSEPFILTERProjectsProjectIdEndpointsHead(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSEPFILTERApi.oSEPFILTERProjectsProjectIdEndpointsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSEPFILTERApi - factory interface
 * @export
 */
export const OSEPFILTERApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSEPFILTERApiFp(configuration)
    return {
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId: string, projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId: string, projectId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId: string, projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId, projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
         * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId: string, projectId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId, projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsGet(options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointGroupsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/OS-EP-FILTER/endpoint_groups
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointGroupsPost(body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointGroupsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * Return a list of projects associated with the endpoint.
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId: string, endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId: string, endpointId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId: string, endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId: string, endpointId: string, body?: object, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId, endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsGet(projectId: string, options?: any): AxiosPromise<object> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
         * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSEPFILTERProjectsProjectIdEndpointsHead(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSEPFILTERProjectsProjectIdEndpointsHead(projectId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSEPFILTERApi - object-oriented interface
 * @export
 * @class OSEPFILTERApi
 * @extends {BaseAPI}
 */
export class OSEPFILTERApi extends BaseAPI {
    /**
     * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdDelete(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsGet(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/endpoints API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdEndpointsHead(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdGet(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdHead(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId: string, body?: object, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdPatch(endpointGroupId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsGet(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsHead(endpointGroupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdDelete(endpointGroupId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdGet(endpointGroupId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId: string, projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdHead(endpointGroupId, projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id}
     * @param {string} endpointGroupId endpoint_group_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/endpoint_groups/{endpoint_group_id}/projects/{project_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId: string, projectId: string, body?: object, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsEndpointGroupIdProjectsProjectIdPut(endpointGroupId, projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/endpoint_groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsGet(options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/endpoint_groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsHead(options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/OS-EP-FILTER/endpoint_groups
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointGroupsPost(body?: object, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointGroupsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of projects associated with the endpoint.
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointsEndpointIdProjectsGet(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Return a list of projects associated with the endpoint.
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/endpoints/{endpoint_id}/projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTEREndpointsEndpointIdProjectsHead(endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointGroupsGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoint_groups API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointGroupsHead(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsEndpointIdDelete(projectId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsEndpointIdGet(projectId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsEndpointIdHead(projectId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id}
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {string} endpointId endpoint_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints/{endpoint_id} API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId: string, endpointId: string, body?: object, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsEndpointIdPut(projectId, endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsGet(projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-EP-FILTER/projects/{project_id}/endpoints
     * @param {string} projectId project_id parameter for /v3/OS-EP-FILTER/projects/{project_id}/endpoints API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSEPFILTERApi
     */
    public oSEPFILTERProjectsProjectIdEndpointsHead(projectId: string, options?: RawAxiosRequestConfig) {
        return OSEPFILTERApiFp(this.configuration).oSEPFILTERProjectsProjectIdEndpointsHead(projectId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSFEDERATIONApi - axios parameter creator
 * @export
 */
export const OSFEDERATIONApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONDomainsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONDomainsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/domains`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {boolean} [enabled] Filter for Identity Providers’ enabled attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersGet: async (id?: string, enabled?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/identity_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/identity_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdDelete: async (idpId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdDelete', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdGet: async (idpId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdGet', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdHead: async (idpId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdHead', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPatchRequest} [osFederationIdentityProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdPatch: async (idpId: string, osFederationIdentityProviderPatchRequest?: OsFederationIdentityProviderPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdPatch', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationIdentityProviderPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsGet: async (idpId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsGet', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsHead: async (idpId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsHead', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate from dedicated uri endpoint.  POST /OS-FEDERATION/identity_providers/      {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost: async (idpId: string, protocolId: string, body?: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a protocol from an IDP.  DELETE /OS-FEDERATION/identity_providers/        {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead: async (idpId: string, protocolId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update protocol for an IDP.  PATCH /OS-FEDERATION/identity_providers/       {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPatchRequest} [osFederationIdentityProvidersProtocolPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch: async (idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPatchRequest?: OsFederationIdentityProvidersProtocolPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationIdentityProvidersProtocolPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create protocol for an IDP.  PUT /OS-Federation/identity_providers/{idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPutRequest} [osFederationIdentityProvidersProtocolPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut: async (idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPutRequest?: OsFederationIdentityProvidersProtocolPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut', 'idpId', idpId)
            // verify required parameter 'protocolId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut', 'protocolId', protocolId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)))
                .replace(`{${"protocol_id"}}`, encodeURIComponent(String(protocolId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationIdentityProvidersProtocolPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an idp resource for federated authentication.  PUT /OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPutRequest} [osFederationIdentityProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdPut: async (idpId: string, osFederationIdentityProviderPutRequest?: OsFederationIdentityProviderPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'idpId' is not null or undefined
            assertParamExists('oSFEDERATIONIdentityProvidersIdpIdPut', 'idpId', idpId)
            const localVarPath = `/v3/OS-FEDERATION/identity_providers/{idp_id}`
                .replace(`{${"idp_id"}}`, encodeURIComponent(String(idpId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationIdentityProviderPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/mappings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a mapping.  DELETE /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdDelete: async (mappingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('oSFEDERATIONMappingsMappingIdDelete', 'mappingId', mappingId)
            const localVarPath = `/v3/OS-FEDERATION/mappings/{mapping_id}`
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdGet: async (mappingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('oSFEDERATIONMappingsMappingIdGet', 'mappingId', mappingId)
            const localVarPath = `/v3/OS-FEDERATION/mappings/{mapping_id}`
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdHead: async (mappingId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('oSFEDERATIONMappingsMappingIdHead', 'mappingId', mappingId)
            const localVarPath = `/v3/OS-FEDERATION/mappings/{mapping_id}`
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update an attribute mapping for identity federation.  PATCH /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPatchRequest} [osFederationMappingPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdPatch: async (mappingId: string, osFederationMappingPatchRequest?: OsFederationMappingPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('oSFEDERATIONMappingsMappingIdPatch', 'mappingId', mappingId)
            const localVarPath = `/v3/OS-FEDERATION/mappings/{mapping_id}`
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationMappingPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a mapping.  PUT /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPutRequest} [osFederationMappingPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdPut: async (mappingId: string, osFederationMappingPutRequest?: OsFederationMappingPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'mappingId' is not null or undefined
            assertParamExists('oSFEDERATIONMappingsMappingIdPut', 'mappingId', mappingId)
            const localVarPath = `/v3/OS-FEDERATION/mappings/{mapping_id}`
                .replace(`{${"mapping_id"}}`, encodeURIComponent(String(mappingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationMappingPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONProjectsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONProjectsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONSaml2MetadataGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/saml2/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONSaml2MetadataHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/saml2/metadata`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/service_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-FEDERATION/service_providers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a service provider.  DELETE /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdDelete: async (spId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spId' is not null or undefined
            assertParamExists('oSFEDERATIONServiceProvidersSpIdDelete', 'spId', spId)
            const localVarPath = `/v3/OS-FEDERATION/service_providers/{sp_id}`
                .replace(`{${"sp_id"}}`, encodeURIComponent(String(spId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdGet: async (spId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spId' is not null or undefined
            assertParamExists('oSFEDERATIONServiceProvidersSpIdGet', 'spId', spId)
            const localVarPath = `/v3/OS-FEDERATION/service_providers/{sp_id}`
                .replace(`{${"sp_id"}}`, encodeURIComponent(String(spId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdHead: async (spId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spId' is not null or undefined
            assertParamExists('oSFEDERATIONServiceProvidersSpIdHead', 'spId', spId)
            const localVarPath = `/v3/OS-FEDERATION/service_providers/{sp_id}`
                .replace(`{${"sp_id"}}`, encodeURIComponent(String(spId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a service provider.  PATCH /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPatchRequest} [osFederationServiceProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdPatch: async (spId: string, osFederationServiceProviderPatchRequest?: OsFederationServiceProviderPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spId' is not null or undefined
            assertParamExists('oSFEDERATIONServiceProvidersSpIdPatch', 'spId', spId)
            const localVarPath = `/v3/OS-FEDERATION/service_providers/{sp_id}`
                .replace(`{${"sp_id"}}`, encodeURIComponent(String(spId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationServiceProviderPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a service provider.  PUT /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPutRequest} [osFederationServiceProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdPut: async (spId: string, osFederationServiceProviderPutRequest?: OsFederationServiceProviderPutRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'spId' is not null or undefined
            assertParamExists('oSFEDERATIONServiceProvidersSpIdPut', 'spId', spId)
            const localVarPath = `/v3/OS-FEDERATION/service_providers/{sp_id}`
                .replace(`{${"sp_id"}}`, encodeURIComponent(String(spId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(osFederationServiceProviderPutRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSFEDERATIONApi - functional programming interface
 * @export
 */
export const OSFEDERATIONApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSFEDERATIONApiAxiosParamCreator(configuration)
    return {
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async oSFEDERATIONDomainsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationDomainsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONDomainsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONDomainsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async oSFEDERATIONDomainsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONDomainsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONDomainsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {boolean} [enabled] Filter for Identity Providers’ enabled attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersGet(id?: string, enabled?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersGet(id, enabled, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdDelete(idpId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdDelete(idpId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdGet(idpId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProviderGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdGet(idpId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdHead(idpId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdHead(idpId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPatchRequest} [osFederationIdentityProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdPatch(idpId: string, osFederationIdentityProviderPatchRequest?: OsFederationIdentityProviderPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProviderPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdPatch(idpId, osFederationIdentityProviderPatchRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolsAuthGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authenticate from dedicated uri endpoint.  POST /OS-FEDERATION/identity_providers/      {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId: string, protocolId: string, body?: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolsAuthPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId, protocolId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a protocol from an IDP.  DELETE /OS-FEDERATION/identity_providers/        {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId, protocolId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update protocol for an IDP.  PATCH /OS-FEDERATION/identity_providers/       {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPatchRequest} [osFederationIdentityProvidersProtocolPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPatchRequest?: OsFederationIdentityProvidersProtocolPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId, protocolId, osFederationIdentityProvidersProtocolPatchRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create protocol for an IDP.  PUT /OS-Federation/identity_providers/{idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPutRequest} [osFederationIdentityProvidersProtocolPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPutRequest?: OsFederationIdentityProvidersProtocolPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProvidersProtocolPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId, protocolId, osFederationIdentityProvidersProtocolPutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an idp resource for federated authentication.  PUT /OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPutRequest} [osFederationIdentityProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONIdentityProvidersIdpIdPut(idpId: string, osFederationIdentityProviderPutRequest?: OsFederationIdentityProviderPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationIdentityProviderPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONIdentityProvidersIdpIdPut(idpId, osFederationIdentityProviderPutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONIdentityProvidersIdpIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationMappingsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a mapping.  DELETE /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsMappingIdDelete(mappingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsMappingIdDelete(mappingId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsMappingIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsMappingIdGet(mappingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationMappingGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsMappingIdGet(mappingId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsMappingIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsMappingIdHead(mappingId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsMappingIdHead(mappingId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsMappingIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update an attribute mapping for identity federation.  PATCH /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPatchRequest} [osFederationMappingPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsMappingIdPatch(mappingId: string, osFederationMappingPatchRequest?: OsFederationMappingPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationMappingPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsMappingIdPatch(mappingId, osFederationMappingPatchRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsMappingIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a mapping.  PUT /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPutRequest} [osFederationMappingPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONMappingsMappingIdPut(mappingId: string, osFederationMappingPutRequest?: OsFederationMappingPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationMappingPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONMappingsMappingIdPut(mappingId, osFederationMappingPutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONMappingsMappingIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async oSFEDERATIONProjectsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationProjectsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONProjectsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async oSFEDERATIONProjectsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONProjectsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONSaml2MetadataGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONSaml2MetadataGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONSaml2MetadataGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONSaml2MetadataHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONSaml2MetadataHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONSaml2MetadataHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationServiceProvidersGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a service provider.  DELETE /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersSpIdDelete(spId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersSpIdDelete(spId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersSpIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersSpIdGet(spId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationServiceProviderGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersSpIdGet(spId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersSpIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersSpIdHead(spId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersSpIdHead(spId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersSpIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a service provider.  PATCH /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPatchRequest} [osFederationServiceProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersSpIdPatch(spId: string, osFederationServiceProviderPatchRequest?: OsFederationServiceProviderPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationServiceProviderPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersSpIdPatch(spId, osFederationServiceProviderPatchRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersSpIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a service provider.  PUT /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPutRequest} [osFederationServiceProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSFEDERATIONServiceProvidersSpIdPut(spId: string, osFederationServiceProviderPutRequest?: OsFederationServiceProviderPutRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OsFederationServiceProviderPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSFEDERATIONServiceProvidersSpIdPut(spId, osFederationServiceProviderPutRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSFEDERATIONApi.oSFEDERATIONServiceProvidersSpIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSFEDERATIONApi - factory interface
 * @export
 */
export const OSFEDERATIONApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSFEDERATIONApiFp(configuration)
    return {
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONDomainsGet(options?: any): AxiosPromise<OsFederationDomainsGetResponse> {
            return localVarFp.oSFEDERATIONDomainsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONDomainsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONDomainsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {boolean} [enabled] Filter for Identity Providers’ enabled attribute
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersGet(id?: string, enabled?: boolean, options?: any): AxiosPromise<OsFederationIdentityProvidersGetResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersGet(id, enabled, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersHead(options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdDelete(idpId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdDelete(idpId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdGet(idpId: string, options?: any): AxiosPromise<OsFederationIdentityProviderGetResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdGet(idpId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdHead(idpId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdHead(idpId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPatchRequest} [osFederationIdentityProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdPatch(idpId: string, osFederationIdentityProviderPatchRequest?: OsFederationIdentityProviderPatchRequest, options?: any): AxiosPromise<OsFederationIdentityProviderPatchResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdPatch(idpId, osFederationIdentityProviderPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId: string, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolsGetResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId, options).then((request) => request(axios, basePath));
        },
        /**
         * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId: string, protocolId: string, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolsAuthGetResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId: string, protocolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate from dedicated uri endpoint.  POST /OS-FEDERATION/identity_providers/      {idp_id}/protocols/{protocol_id}/auth
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
         * @param {object} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId: string, protocolId: string, body?: object, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolsAuthPostResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId, protocolId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a protocol from an IDP.  DELETE /OS-FEDERATION/identity_providers/        {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId: string, protocolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId: string, protocolId: string, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolGetResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId: string, protocolId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId, protocolId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update protocol for an IDP.  PATCH /OS-FEDERATION/identity_providers/       {idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPatchRequest} [osFederationIdentityProvidersProtocolPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPatchRequest?: OsFederationIdentityProvidersProtocolPatchRequest, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolPatchResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId, protocolId, osFederationIdentityProvidersProtocolPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create protocol for an IDP.  PUT /OS-Federation/identity_providers/{idp_id}/protocols/{protocol_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
         * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
         * @param {OsFederationIdentityProvidersProtocolPutRequest} [osFederationIdentityProvidersProtocolPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPutRequest?: OsFederationIdentityProvidersProtocolPutRequest, options?: any): AxiosPromise<OsFederationIdentityProvidersProtocolPutResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId, protocolId, osFederationIdentityProvidersProtocolPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an idp resource for federated authentication.  PUT /OS-FEDERATION/identity_providers/{idp_id}
         * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
         * @param {OsFederationIdentityProviderPutRequest} [osFederationIdentityProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONIdentityProvidersIdpIdPut(idpId: string, osFederationIdentityProviderPutRequest?: OsFederationIdentityProviderPutRequest, options?: any): AxiosPromise<OsFederationIdentityProviderPutResponse> {
            return localVarFp.oSFEDERATIONIdentityProvidersIdpIdPut(idpId, osFederationIdentityProviderPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsGet(options?: any): AxiosPromise<OsFederationMappingsGetResponse> {
            return localVarFp.oSFEDERATIONMappingsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONMappingsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a mapping.  DELETE /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdDelete(mappingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONMappingsMappingIdDelete(mappingId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdGet(mappingId: string, options?: any): AxiosPromise<OsFederationMappingGetResponse> {
            return localVarFp.oSFEDERATIONMappingsMappingIdGet(mappingId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdHead(mappingId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONMappingsMappingIdHead(mappingId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update an attribute mapping for identity federation.  PATCH /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPatchRequest} [osFederationMappingPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdPatch(mappingId: string, osFederationMappingPatchRequest?: OsFederationMappingPatchRequest, options?: any): AxiosPromise<OsFederationMappingPatchResponse> {
            return localVarFp.oSFEDERATIONMappingsMappingIdPatch(mappingId, osFederationMappingPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a mapping.  PUT /OS-FEDERATION/mappings/{mapping_id}
         * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
         * @param {OsFederationMappingPutRequest} [osFederationMappingPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONMappingsMappingIdPut(mappingId: string, osFederationMappingPutRequest?: OsFederationMappingPutRequest, options?: any): AxiosPromise<OsFederationMappingPutResponse> {
            return localVarFp.oSFEDERATIONMappingsMappingIdPut(mappingId, osFederationMappingPutRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONProjectsGet(options?: any): AxiosPromise<OsFederationProjectsGetResponse> {
            return localVarFp.oSFEDERATIONProjectsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        oSFEDERATIONProjectsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONProjectsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONSaml2MetadataGet(options?: any): AxiosPromise<string> {
            return localVarFp.oSFEDERATIONSaml2MetadataGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONSaml2MetadataHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONSaml2MetadataHead(options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersGet(options?: any): AxiosPromise<OsFederationServiceProvidersGetResponse> {
            return localVarFp.oSFEDERATIONServiceProvidersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONServiceProvidersHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a service provider.  DELETE /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdDelete(spId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONServiceProvidersSpIdDelete(spId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdGet(spId: string, options?: any): AxiosPromise<OsFederationServiceProviderGetResponse> {
            return localVarFp.oSFEDERATIONServiceProvidersSpIdGet(spId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdHead(spId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSFEDERATIONServiceProvidersSpIdHead(spId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a service provider.  PATCH /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPatchRequest} [osFederationServiceProviderPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdPatch(spId: string, osFederationServiceProviderPatchRequest?: OsFederationServiceProviderPatchRequest, options?: any): AxiosPromise<OsFederationServiceProviderPatchResponse> {
            return localVarFp.oSFEDERATIONServiceProvidersSpIdPatch(spId, osFederationServiceProviderPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a service provider.  PUT /OS-FEDERATION/service_providers/{sp_id}
         * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
         * @param {OsFederationServiceProviderPutRequest} [osFederationServiceProviderPutRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSFEDERATIONServiceProvidersSpIdPut(spId: string, osFederationServiceProviderPutRequest?: OsFederationServiceProviderPutRequest, options?: any): AxiosPromise<OsFederationServiceProviderPutResponse> {
            return localVarFp.oSFEDERATIONServiceProvidersSpIdPut(spId, osFederationServiceProviderPutRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSFEDERATIONApi - object-oriented interface
 * @export
 * @class OSFEDERATIONApi
 * @extends {BaseAPI}
 */
export class OSFEDERATIONApi extends BaseAPI {
    /**
     * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONDomainsGet(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONDomainsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible domain scopes for token.  GET/HEAD /v3/auth/domains GET/HEAD /v3/OS-FEDERATION/domains
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONDomainsHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONDomainsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/identity_providers
     * @param {string} [id] Filter for Identity Providers’ ID attribute
     * @param {boolean} [enabled] Filter for Identity Providers’ enabled attribute
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersGet(id?: string, enabled?: boolean, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersGet(id, enabled, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/identity_providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdDelete(idpId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdDelete(idpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdGet(idpId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdGet(idpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdHead(idpId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdHead(idpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/OS-FEDERATION/identity_providers/{idp_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
     * @param {OsFederationIdentityProviderPatchRequest} [osFederationIdentityProviderPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdPatch(idpId: string, osFederationIdentityProviderPatchRequest?: OsFederationIdentityProviderPatchRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdPatch(idpId, osFederationIdentityProviderPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsGet(idpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/{idp_id}/protocols
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsHead(idpId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthGet(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate from dedicated uri endpoint.  GET/HEAD /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}/auth
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthHead(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate from dedicated uri endpoint.  POST /OS-FEDERATION/identity_providers/      {idp_id}/protocols/{protocol_id}/auth
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id}/auth API
     * @param {object} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId: string, protocolId: string, body?: object, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdAuthPost(idpId, protocolId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a protocol from an IDP.  DELETE /OS-FEDERATION/identity_providers/        {idp_id}/protocols/{protocol_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdDelete(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdGet(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get protocols for an IDP.  HEAD/GET /OS-FEDERATION/identity_providers/          {idp_id}/protocols/{protocol_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId: string, protocolId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdHead(idpId, protocolId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update protocol for an IDP.  PATCH /OS-FEDERATION/identity_providers/       {idp_id}/protocols/{protocol_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
     * @param {OsFederationIdentityProvidersProtocolPatchRequest} [osFederationIdentityProvidersProtocolPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPatchRequest?: OsFederationIdentityProvidersProtocolPatchRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPatch(idpId, protocolId, osFederationIdentityProvidersProtocolPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create protocol for an IDP.  PUT /OS-Federation/identity_providers/{idp_id}/protocols/{protocol_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols API
     * @param {string} protocolId protocol_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id}/protocols/{protocol_id} API
     * @param {OsFederationIdentityProvidersProtocolPutRequest} [osFederationIdentityProvidersProtocolPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId: string, protocolId: string, osFederationIdentityProvidersProtocolPutRequest?: OsFederationIdentityProvidersProtocolPutRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdProtocolsProtocolIdPut(idpId, protocolId, osFederationIdentityProvidersProtocolPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an idp resource for federated authentication.  PUT /OS-FEDERATION/identity_providers/{idp_id}
     * @param {string} idpId idp_id parameter for /v3/OS-FEDERATION/identity_providers/{idp_id} API
     * @param {OsFederationIdentityProviderPutRequest} [osFederationIdentityProviderPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONIdentityProvidersIdpIdPut(idpId: string, osFederationIdentityProviderPutRequest?: OsFederationIdentityProviderPutRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONIdentityProvidersIdpIdPut(idpId, osFederationIdentityProviderPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/mappings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsGet(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/mappings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a mapping.  DELETE /OS-FEDERATION/mappings/{mapping_id}
     * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsMappingIdDelete(mappingId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsMappingIdDelete(mappingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/mappings/{mapping_id}
     * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsMappingIdGet(mappingId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsMappingIdGet(mappingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/mappings/{mapping_id}
     * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsMappingIdHead(mappingId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsMappingIdHead(mappingId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update an attribute mapping for identity federation.  PATCH /OS-FEDERATION/mappings/{mapping_id}
     * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
     * @param {OsFederationMappingPatchRequest} [osFederationMappingPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsMappingIdPatch(mappingId: string, osFederationMappingPatchRequest?: OsFederationMappingPatchRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsMappingIdPatch(mappingId, osFederationMappingPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a mapping.  PUT /OS-FEDERATION/mappings/{mapping_id}
     * @param {string} mappingId mapping_id parameter for /v3/OS-FEDERATION/mappings/{mapping_id} API
     * @param {OsFederationMappingPutRequest} [osFederationMappingPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONMappingsMappingIdPut(mappingId: string, osFederationMappingPutRequest?: OsFederationMappingPutRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONMappingsMappingIdPut(mappingId, osFederationMappingPutRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONProjectsGet(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONProjectsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get possible project scopes for token.  GET/HEAD /v3/auth/projects GET/HEAD /v3/OS-FEDERATION/projects
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONProjectsHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONProjectsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONSaml2MetadataGet(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONSaml2MetadataGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get SAML2 metadata.  GET/HEAD /OS-FEDERATION/saml2/metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONSaml2MetadataHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONSaml2MetadataHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/service_providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersGet(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/service_providers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersHead(options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a service provider.  DELETE /OS-FEDERATION/service_providers/{sp_id}
     * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersSpIdDelete(spId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersSpIdDelete(spId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-FEDERATION/service_providers/{sp_id}
     * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersSpIdGet(spId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersSpIdGet(spId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-FEDERATION/service_providers/{sp_id}
     * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersSpIdHead(spId: string, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersSpIdHead(spId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a service provider.  PATCH /OS-FEDERATION/service_providers/{sp_id}
     * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
     * @param {OsFederationServiceProviderPatchRequest} [osFederationServiceProviderPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersSpIdPatch(spId: string, osFederationServiceProviderPatchRequest?: OsFederationServiceProviderPatchRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersSpIdPatch(spId, osFederationServiceProviderPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a service provider.  PUT /OS-FEDERATION/service_providers/{sp_id}
     * @param {string} spId sp_id parameter for /v3/OS-FEDERATION/service_providers/{sp_id} API
     * @param {OsFederationServiceProviderPutRequest} [osFederationServiceProviderPutRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSFEDERATIONApi
     */
    public oSFEDERATIONServiceProvidersSpIdPut(spId: string, osFederationServiceProviderPutRequest?: OsFederationServiceProviderPutRequest, options?: RawAxiosRequestConfig) {
        return OSFEDERATIONApiFp(this.configuration).oSFEDERATIONServiceProvidersSpIdPut(spId, osFederationServiceProviderPutRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSINHERITApi - axios parameter creator
 * @export
 */
export const OSINHERITApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet: async (domainId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet', 'groupId', groupId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead: async (domainId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead', 'groupId', groupId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an inherited grant for a group on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an inherited grant for a group on a domain.  PUT /OS-INHERIT/domains/{domain_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut: async (domainId: string, groupId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet: async (domainId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet', 'userId', userId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead: async (domainId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead', 'userId', userId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a grant from a user on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles        /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an inherited grant for a user on a domain.  PUT /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}     /inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut: async (domainId: string, userId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an inherited grant for a group on a project.  DELETE /OS-INHERIT/projects/{project_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an inherited grant for a group on a project.  PUT /OS-INHERIT/projects/{project_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut: async (projectId: string, groupId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke an inherited grant for a user on a project.  DELETE /OS-INHERIT/projects/{project_id}/users/{user_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create an inherited grant for a user on a project.  PUT /OS-INHERIT/projects/{project_id}/users/{user_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut: async (projectId: string, userId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut', 'roleId', roleId)
            const localVarPath = `/v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSINHERITApi - functional programming interface
 * @export
 */
export const OSINHERITApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSINHERITApiAxiosParamCreator(configuration)
    return {
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke an inherited grant for a group on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an inherited grant for a group on a domain.  PUT /OS-INHERIT/domains/{domain_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId: string, groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId, groupId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a grant from a user on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles        /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an inherited grant for a user on a domain.  PUT /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}     /inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId: string, userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId, userId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke an inherited grant for a group on a project.  DELETE /OS-INHERIT/projects/{project_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an inherited grant for a group on a project.  PUT /OS-INHERIT/projects/{project_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId: string, groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId, groupId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke an inherited grant for a user on a project.  DELETE /OS-INHERIT/projects/{project_id}/users/{user_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create an inherited grant for a user on a project.  PUT /OS-INHERIT/projects/{project_id}/users/{user_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId: string, userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId, userId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSINHERITApi.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSINHERITApi - factory interface
 * @export
 */
export const OSINHERITApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSINHERITApiFp(configuration)
    return {
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId: string, groupId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an inherited grant for a group on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an inherited grant for a group on a domain.  PUT /OS-INHERIT/domains/{domain_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId: string, groupId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId, groupId, roleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId: string, userId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a grant from a user on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles        /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an inherited grant for a user on a domain.  PUT /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}     /inherited_to_projects
         * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId: string, userId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId, userId, roleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an inherited grant for a group on a project.  DELETE /OS-INHERIT/projects/{project_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an inherited grant for a group on a project.  PUT /OS-INHERIT/projects/{project_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId: string, groupId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId, groupId, roleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke an inherited grant for a user on a project.  DELETE /OS-INHERIT/projects/{project_id}/users/{user_id}        /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create an inherited grant for a user on a project.  PUT /OS-INHERIT/projects/{project_id}/users/{user_id}     /roles/{role_id}/inherited_to_projects
         * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId: string, userId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId, userId, roleId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSINHERITApi - object-oriented interface
 * @export
 * @class OSINHERITApi
 * @extends {BaseAPI}
 */
export class OSINHERITApi extends BaseAPI {
    /**
     * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsGet(domainId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List roles (inherited) for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesInheritedToProjectsHead(domainId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an inherited grant for a group on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a group on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an inherited grant for a group on a domain.  PUT /OS-INHERIT/domains/{domain_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId: string, groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(domainId, groupId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId: string, userId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsGet(domainId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List roles (inherited) for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}          /roles/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId: string, userId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesInheritedToProjectsHead(domainId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a grant from a user on a domain.  DELETE /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles        /{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsGet(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a user on a domain.  GET/HEAD /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles          /{role_id}/inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsHead(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an inherited grant for a user on a domain.  PUT /OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}     /inherited_to_projects
     * @param {string} domainId domain_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/domains/{domain_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId: string, userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITDomainsDomainIdUsersUserIdRolesRoleIdInheritedToProjectsPut(domainId, userId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an inherited grant for a group on a project.  DELETE /OS-INHERIT/projects/{project_id}/groups/{group_id}        /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsDelete(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsGet(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a group on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/groups/{group_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsHead(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an inherited grant for a group on a project.  PUT /OS-INHERIT/projects/{project_id}/groups/{group_id}     /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} groupId group_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/groups/{group_id}/roles/{role_id}/inherited_to_projects API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId: string, groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdGroupsGroupIdRolesRoleIdInheritedToProjectsPut(projectId, groupId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke an inherited grant for a user on a project.  DELETE /OS-INHERIT/projects/{project_id}/users/{user_id}        /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsDelete(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsGet(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check for an inherited grant for a user on a project.  GET/HEAD /OS-INHERIT/projects/{project_id}/users/{user_id}          /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsHead(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create an inherited grant for a user on a project.  PUT /OS-INHERIT/projects/{project_id}/users/{user_id}     /roles/{role_id}/inherited_to_projects
     * @param {string} projectId project_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} userId user_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {string} roleId role_id parameter for /v3/OS-INHERIT/projects/{project_id}/users/{user_id}/roles/{role_id}/inherited_to_projects API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSINHERITApi
     */
    public oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId: string, userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSINHERITApiFp(this.configuration).oSINHERITProjectsProjectIdUsersUserIdRolesRoleIdInheritedToProjectsPut(projectId, userId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSOAUTH1Api - axios parameter creator
 * @export
 */
export const OSOAUTH1ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/OS-OAUTH1/access_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/access_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/OS-OAUTH1/authorize/{request_token_id}
         * @param {string} requestTokenId request_token_id parameter for /v3/OS-OAUTH1/authorize/{request_token_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AuthorizeRequestTokenIdPut: async (requestTokenId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'requestTokenId' is not null or undefined
            assertParamExists('oSOAUTH1AuthorizeRequestTokenIdPut', 'requestTokenId', requestTokenId)
            const localVarPath = `/v3/OS-OAUTH1/authorize/{request_token_id}`
                .replace(`{${"request_token_id"}}`, encodeURIComponent(String(requestTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdDelete: async (consumerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consumerId' is not null or undefined
            assertParamExists('oSOAUTH1ConsumersConsumerIdDelete', 'consumerId', consumerId)
            const localVarPath = `/v3/OS-OAUTH1/consumers/{consumer_id}`
                .replace(`{${"consumer_id"}}`, encodeURIComponent(String(consumerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdGet: async (consumerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consumerId' is not null or undefined
            assertParamExists('oSOAUTH1ConsumersConsumerIdGet', 'consumerId', consumerId)
            const localVarPath = `/v3/OS-OAUTH1/consumers/{consumer_id}`
                .replace(`{${"consumer_id"}}`, encodeURIComponent(String(consumerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdHead: async (consumerId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consumerId' is not null or undefined
            assertParamExists('oSOAUTH1ConsumersConsumerIdHead', 'consumerId', consumerId)
            const localVarPath = `/v3/OS-OAUTH1/consumers/{consumer_id}`
                .replace(`{${"consumer_id"}}`, encodeURIComponent(String(consumerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdPatch: async (consumerId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'consumerId' is not null or undefined
            assertParamExists('oSOAUTH1ConsumersConsumerIdPatch', 'consumerId', consumerId)
            const localVarPath = `/v3/OS-OAUTH1/consumers/{consumer_id}`
                .replace(`{${"consumer_id"}}`, encodeURIComponent(String(consumerId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/consumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/consumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/OS-OAUTH1/consumers
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/consumers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/request_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/request_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/OS-OAUTH1/request_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH1/request_token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSOAUTH1Api - functional programming interface
 * @export
 */
export const OSOAUTH1ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSOAUTH1ApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1AccessTokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1AccessTokenGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1AccessTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1AccessTokenHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1AccessTokenHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1AccessTokenHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/OS-OAUTH1/access_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1AccessTokenPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1AccessTokenPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1AccessTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/OS-OAUTH1/authorize/{request_token_id}
         * @param {string} requestTokenId request_token_id parameter for /v3/OS-OAUTH1/authorize/{request_token_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1AuthorizeRequestTokenIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersConsumerIdDelete(consumerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersConsumerIdDelete(consumerId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersConsumerIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersConsumerIdGet(consumerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersConsumerIdGet(consumerId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersConsumerIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersConsumerIdHead(consumerId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersConsumerIdHead(consumerId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersConsumerIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersConsumerIdPatch(consumerId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersConsumerIdPatch(consumerId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersConsumerIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/OS-OAUTH1/consumers
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1ConsumersPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1ConsumersPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1ConsumersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1RequestTokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1RequestTokenGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1RequestTokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1RequestTokenHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1RequestTokenHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1RequestTokenHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/OS-OAUTH1/request_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH1RequestTokenPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH1RequestTokenPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH1Api.oSOAUTH1RequestTokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSOAUTH1Api - factory interface
 * @export
 */
export const OSOAUTH1ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSOAUTH1ApiFp(configuration)
    return {
        /**
         * GET operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1AccessTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/access_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH1AccessTokenHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/OS-OAUTH1/access_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AccessTokenPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1AccessTokenPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/OS-OAUTH1/authorize/{request_token_id}
         * @param {string} requestTokenId request_token_id parameter for /v3/OS-OAUTH1/authorize/{request_token_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdDelete(consumerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH1ConsumersConsumerIdDelete(consumerId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdGet(consumerId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1ConsumersConsumerIdGet(consumerId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdHead(consumerId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH1ConsumersConsumerIdHead(consumerId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/OS-OAUTH1/consumers/{consumer_id}
         * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersConsumerIdPatch(consumerId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1ConsumersConsumerIdPatch(consumerId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1ConsumersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/consumers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH1ConsumersHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/OS-OAUTH1/consumers
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1ConsumersPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1ConsumersPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1RequestTokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-OAUTH1/request_token
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH1RequestTokenHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/OS-OAUTH1/request_token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH1RequestTokenPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH1RequestTokenPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSOAUTH1Api - object-oriented interface
 * @export
 * @class OSOAUTH1Api
 * @extends {BaseAPI}
 */
export class OSOAUTH1Api extends BaseAPI {
    /**
     * GET operation on /v3/OS-OAUTH1/access_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1AccessTokenGet(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1AccessTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-OAUTH1/access_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1AccessTokenHead(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1AccessTokenHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/OS-OAUTH1/access_token
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1AccessTokenPost(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1AccessTokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/OS-OAUTH1/authorize/{request_token_id}
     * @param {string} requestTokenId request_token_id parameter for /v3/OS-OAUTH1/authorize/{request_token_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1AuthorizeRequestTokenIdPut(requestTokenId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/OS-OAUTH1/consumers/{consumer_id}
     * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersConsumerIdDelete(consumerId: string, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersConsumerIdDelete(consumerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-OAUTH1/consumers/{consumer_id}
     * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersConsumerIdGet(consumerId: string, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersConsumerIdGet(consumerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-OAUTH1/consumers/{consumer_id}
     * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersConsumerIdHead(consumerId: string, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersConsumerIdHead(consumerId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/OS-OAUTH1/consumers/{consumer_id}
     * @param {string} consumerId consumer_id parameter for /v3/OS-OAUTH1/consumers/{consumer_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersConsumerIdPatch(consumerId: string, body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersConsumerIdPatch(consumerId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-OAUTH1/consumers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersGet(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-OAUTH1/consumers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersHead(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/OS-OAUTH1/consumers
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1ConsumersPost(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1ConsumersPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-OAUTH1/request_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1RequestTokenGet(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1RequestTokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-OAUTH1/request_token
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1RequestTokenHead(options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1RequestTokenHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/OS-OAUTH1/request_token
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH1Api
     */
    public oSOAUTH1RequestTokenPost(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH1ApiFp(this.configuration).oSOAUTH1RequestTokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSOAUTH2Api - axios parameter creator
 * @export
 */
export const OSOAUTH2ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenDelete: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPatch: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get an OAuth2.0 Access Token.  POST /v3/OS-OAUTH2/token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPut: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-OAUTH2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSOAUTH2Api - functional programming interface
 * @export
 */
export const OSOAUTH2ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSOAUTH2ApiAxiosParamCreator(configuration)
    return {
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenDelete(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenDelete(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenPatch(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenPatch(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get an OAuth2.0 Access Token.  POST /v3/OS-OAUTH2/token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSOAUTH2TokenPut(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSOAUTH2TokenPut(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSOAUTH2Api.oSOAUTH2TokenPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSOAUTH2Api - factory interface
 * @export
 */
export const OSOAUTH2ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSOAUTH2ApiFp(configuration)
    return {
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenDelete(options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH2TokenDelete(options).then((request) => request(axios, basePath));
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH2TokenGet(options).then((request) => request(axios, basePath));
        },
        /**
         * The method is not allowed.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSOAUTH2TokenHead(options).then((request) => request(axios, basePath));
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPatch(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH2TokenPatch(body, options).then((request) => request(axios, basePath));
        },
        /**
         * Get an OAuth2.0 Access Token.  POST /v3/OS-OAUTH2/token
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH2TokenPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * The method is not allowed.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSOAUTH2TokenPut(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSOAUTH2TokenPut(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSOAUTH2Api - object-oriented interface
 * @export
 * @class OSOAUTH2Api
 * @extends {BaseAPI}
 */
export class OSOAUTH2Api extends BaseAPI {
    /**
     * The method is not allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenDelete(options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenDelete(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method is not allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenGet(options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method is not allowed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenHead(options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method is not allowed.
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenPatch(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenPatch(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get an OAuth2.0 Access Token.  POST /v3/OS-OAUTH2/token
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenPost(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * The method is not allowed.
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSOAUTH2Api
     */
    public oSOAUTH2TokenPut(body?: any, options?: RawAxiosRequestConfig) {
        return OSOAUTH2ApiFp(this.configuration).oSOAUTH2TokenPut(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSREVOKEApi - axios parameter creator
 * @export
 */
export const OSREVOKEApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSREVOKEEventsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-REVOKE/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSREVOKEEventsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-REVOKE/events`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSREVOKEApi - functional programming interface
 * @export
 */
export const OSREVOKEApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSREVOKEApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSREVOKEEventsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSREVOKEEventsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSREVOKEApi.oSREVOKEEventsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSREVOKEEventsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSREVOKEEventsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSREVOKEApi.oSREVOKEEventsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSREVOKEApi - factory interface
 * @export
 */
export const OSREVOKEApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSREVOKEApiFp(configuration)
    return {
        /**
         * GET operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSREVOKEEventsGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSREVOKEEventsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-REVOKE/events
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSREVOKEEventsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSREVOKEEventsHead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSREVOKEApi - object-oriented interface
 * @export
 * @class OSREVOKEApi
 * @extends {BaseAPI}
 */
export class OSREVOKEApi extends BaseAPI {
    /**
     * GET operation on /v3/OS-REVOKE/events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSREVOKEApi
     */
    public oSREVOKEEventsGet(options?: RawAxiosRequestConfig) {
        return OSREVOKEApiFp(this.configuration).oSREVOKEEventsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-REVOKE/events
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSREVOKEApi
     */
    public oSREVOKEEventsHead(options?: RawAxiosRequestConfig) {
        return OSREVOKEApiFp(this.configuration).oSREVOKEEventsHead(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSSIMPLECERTApi - axios parameter creator
 * @export
 */
export const OSSIMPLECERTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCaGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-SIMPLE-CERT/ca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCaHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-SIMPLE-CERT/ca`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCertificatesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-SIMPLE-CERT/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCertificatesHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-SIMPLE-CERT/certificates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSSIMPLECERTApi - functional programming interface
 * @export
 */
export const OSSIMPLECERTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSSIMPLECERTApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSSIMPLECERTCaGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSSIMPLECERTCaGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSSIMPLECERTApi.oSSIMPLECERTCaGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSSIMPLECERTCaHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSSIMPLECERTCaHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSSIMPLECERTApi.oSSIMPLECERTCaHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSSIMPLECERTCertificatesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSSIMPLECERTCertificatesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSSIMPLECERTApi.oSSIMPLECERTCertificatesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSSIMPLECERTCertificatesHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSSIMPLECERTCertificatesHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSSIMPLECERTApi.oSSIMPLECERTCertificatesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSSIMPLECERTApi - factory interface
 * @export
 */
export const OSSIMPLECERTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSSIMPLECERTApiFp(configuration)
    return {
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCaGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSSIMPLECERTCaGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/ca
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCaHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSSIMPLECERTCaHead(options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCertificatesGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSSIMPLECERTCertificatesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-SIMPLE-CERT/certificates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSSIMPLECERTCertificatesHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSSIMPLECERTCertificatesHead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSSIMPLECERTApi - object-oriented interface
 * @export
 * @class OSSIMPLECERTApi
 * @extends {BaseAPI}
 */
export class OSSIMPLECERTApi extends BaseAPI {
    /**
     * GET operation on /v3/OS-SIMPLE-CERT/ca
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSSIMPLECERTApi
     */
    public oSSIMPLECERTCaGet(options?: RawAxiosRequestConfig) {
        return OSSIMPLECERTApiFp(this.configuration).oSSIMPLECERTCaGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-SIMPLE-CERT/ca
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSSIMPLECERTApi
     */
    public oSSIMPLECERTCaHead(options?: RawAxiosRequestConfig) {
        return OSSIMPLECERTApiFp(this.configuration).oSSIMPLECERTCaHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-SIMPLE-CERT/certificates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSSIMPLECERTApi
     */
    public oSSIMPLECERTCertificatesGet(options?: RawAxiosRequestConfig) {
        return OSSIMPLECERTApiFp(this.configuration).oSSIMPLECERTCertificatesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-SIMPLE-CERT/certificates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSSIMPLECERTApi
     */
    public oSSIMPLECERTCertificatesHead(options?: RawAxiosRequestConfig) {
        return OSSIMPLECERTApiFp(this.configuration).oSSIMPLECERTCertificatesHead(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * OSTRUSTApi - axios parameter creator
 * @export
 */
export const OSTRUSTApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-TRUST/trusts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-TRUST/trusts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a new trust.  The User creating the trust must be the trustor.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/OS-TRUST/trusts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/OS-TRUST/trusts/{trust_id}
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdDelete: async (trustId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdDelete', 'trustId', trustId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdGet: async (trustId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdGet', 'trustId', trustId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdHead: async (trustId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdHead', 'trustId', trustId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesGet: async (trustId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesGet', 'trustId', trustId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}/roles`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesHead: async (trustId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesHead', 'trustId', trustId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}/roles`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesRoleIdGet: async (trustId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesRoleIdGet', 'trustId', trustId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}/roles/{role_id}`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesRoleIdHead: async (trustId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'trustId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesRoleIdHead', 'trustId', trustId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('oSTRUSTTrustsTrustIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/OS-TRUST/trusts/{trust_id}/roles/{role_id}`
                .replace(`{${"trust_id"}}`, encodeURIComponent(String(trustId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OSTRUSTApi - functional programming interface
 * @export
 */
export const OSTRUSTApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OSTRUSTApiAxiosParamCreator(configuration)
    return {
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a new trust.  The User creating the trust must be the trustor.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/OS-TRUST/trusts/{trust_id}
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdDelete(trustId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdDelete(trustId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdGet(trustId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdGet(trustId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdHead(trustId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdHead(trustId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdRolesGet(trustId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdRolesGet(trustId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdRolesHead(trustId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdRolesHead(trustId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['OSTRUSTApi.oSTRUSTTrustsTrustIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * OSTRUSTApi - factory interface
 * @export
 */
export const OSTRUSTApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OSTRUSTApiFp(configuration)
    return {
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsGet(options?: any): AxiosPromise<any> {
            return localVarFp.oSTRUSTTrustsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsHead(options?: any): AxiosPromise<void> {
            return localVarFp.oSTRUSTTrustsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a new trust.  The User creating the trust must be the trustor.
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.oSTRUSTTrustsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/OS-TRUST/trusts/{trust_id}
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdDelete(trustId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSTRUSTTrustsTrustIdDelete(trustId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdGet(trustId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSTRUSTTrustsTrustIdGet(trustId, options).then((request) => request(axios, basePath));
        },
        /**
         * Dispatch for GET/HEAD or LIST trusts.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdHead(trustId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSTRUSTTrustsTrustIdHead(trustId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesGet(trustId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSTRUSTTrustsTrustIdRolesGet(trustId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/OS-TRUST/trusts/{trust_id}/roles
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesHead(trustId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSTRUSTTrustsTrustIdRolesHead(trustId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a role that has been assigned to a trust.
         * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId, roleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OSTRUSTApi - object-oriented interface
 * @export
 * @class OSTRUSTApi
 * @extends {BaseAPI}
 */
export class OSTRUSTApi extends BaseAPI {
    /**
     * Dispatch for GET/HEAD or LIST trusts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsGet(options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch for GET/HEAD or LIST trusts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsHead(options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a new trust.  The User creating the trust must be the trustor.
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsPost(body?: any, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/OS-TRUST/trusts/{trust_id}
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdDelete(trustId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdDelete(trustId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch for GET/HEAD or LIST trusts.
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdGet(trustId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdGet(trustId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Dispatch for GET/HEAD or LIST trusts.
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdHead(trustId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdHead(trustId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/OS-TRUST/trusts/{trust_id}/roles
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdRolesGet(trustId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdRolesGet(trustId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/OS-TRUST/trusts/{trust_id}/roles
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdRolesHead(trustId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdRolesHead(trustId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a role that has been assigned to a trust.
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdRolesRoleIdGet(trustId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a role that has been assigned to a trust.
     * @param {string} trustId trust_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/OS-TRUST/trusts/{trust_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OSTRUSTApi
     */
    public oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return OSTRUSTApiFp(this.configuration).oSTRUSTTrustsTrustIdRolesRoleIdHead(trustId, roleId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PoliciesApi - axios parameter creator
 * @export
 */
export const PoliciesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdDelete: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdDelete', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdGet: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdGet', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdHead: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdHead', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete: async (policyId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete', 'policyId', policyId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete', 'endpointId', endpointId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet: async (policyId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet', 'policyId', policyId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet', 'endpointId', endpointId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead: async (policyId: string, endpointId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead', 'policyId', policyId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead', 'endpointId', endpointId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut: async (policyId: string, endpointId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut', 'policyId', policyId)
            // verify required parameter 'endpointId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut', 'endpointId', endpointId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"endpoint_id"}}`, encodeURIComponent(String(endpointId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsGet: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsGet', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsHead: async (policyId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYEndpointsHead', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete: async (policyId: string, serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete', 'serviceId', serviceId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet: async (policyId: string, serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet', 'serviceId', serviceId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead: async (policyId: string, serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead', 'serviceId', serviceId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut: async (policyId: string, serviceId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut', 'serviceId', serviceId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete: async (policyId: string, serviceId: string, regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete', 'serviceId', serviceId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete', 'regionId', regionId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet: async (policyId: string, serviceId: string, regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet', 'serviceId', serviceId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet', 'regionId', regionId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead: async (policyId: string, serviceId: string, regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead', 'serviceId', serviceId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead', 'regionId', regionId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut: async (policyId: string, serviceId: string, regionId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut', 'policyId', policyId)
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut', 'serviceId', serviceId)
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut', 'regionId', regionId)
            const localVarPath = `/v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)))
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)))
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPatch: async (policyId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'policyId' is not null or undefined
            assertParamExists('policiesPolicyIdPatch', 'policyId', policyId)
            const localVarPath = `/v3/policies/{policy_id}`
                .replace(`{${"policy_id"}}`, encodeURIComponent(String(policyId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/policies
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/policies`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PoliciesApi - functional programming interface
 * @export
 */
export const PoliciesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PoliciesApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdDelete(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdDelete(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdGet(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdHead(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdHead(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId: string, endpointId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId, endpointId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId: string, endpointId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId, endpointId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYEndpointsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId: string, serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId, serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId: string, serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId, serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId: string, serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId, serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId: string, serviceId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId, serviceId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId, serviceId, regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId, serviceId, regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId, serviceId, regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId: string, serviceId: string, regionId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId, serviceId, regionId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPolicyIdPatch(policyId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPolicyIdPatch(policyId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPolicyIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/policies
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async policiesPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.policiesPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['PoliciesApi.policiesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * PoliciesApi - factory interface
 * @export
 */
export const PoliciesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PoliciesApiFp(configuration)
    return {
        /**
         * GET operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesGet(options?: any): AxiosPromise<any> {
            return localVarFp.policiesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesHead(options?: any): AxiosPromise<void> {
            return localVarFp.policiesHead(options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdDelete(policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdDelete(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdGet(policyId: string, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdGet(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdHead(policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdHead(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId: string, endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId: string, endpointId: string, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId: string, endpointId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId, endpointId, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId: string, endpointId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId, endpointId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId: string, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId: string, serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId: string, serviceId: string, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId: string, serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId, serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId: string, serviceId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId, serviceId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId: string, serviceId: string, regionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId, serviceId, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId: string, serviceId: string, regionId: string, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId, serviceId, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId: string, serviceId: string, regionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId, serviceId, regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId: string, serviceId: string, regionId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId, serviceId, regionId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/policies/{policy_id}
         * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPolicyIdPatch(policyId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPolicyIdPatch(policyId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/policies
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        policiesPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.policiesPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PoliciesApi - object-oriented interface
 * @export
 * @class PoliciesApi
 * @extends {BaseAPI}
 */
export class PoliciesApi extends BaseAPI {
    /**
     * GET operation on /v3/policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesGet(options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesHead(options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/policies/{policy_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdDelete(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdDelete(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/policies/{policy_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdGet(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdGet(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies/{policy_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdHead(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdHead(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdDelete(policyId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdGet(policyId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId: string, endpointId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdHead(policyId, endpointId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {string} endpointId endpoint_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId: string, endpointId: string, body?: any, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsEndpointIdPut(policyId, endpointId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsGet(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/endpoints/{endpoint_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYEndpointsHead(policyId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId: string, serviceId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdDelete(policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId: string, serviceId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdGet(policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId: string, serviceId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdHead(policyId, serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId: string, serviceId: string, body?: any, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdPut(policyId, serviceId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdDelete(policyId, serviceId, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdGet(policyId, serviceId, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId: string, serviceId: string, regionId: string, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdHead(policyId, serviceId, regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} serviceId service_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {string} regionId region_id parameter for /v3/policies/{policy_id}/OS-ENDPOINT-POLICY/services/{service_id}/regions/{region_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId: string, serviceId: string, regionId: string, body?: any, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdOSENDPOINTPOLICYServicesServiceIdRegionsRegionIdPut(policyId, serviceId, regionId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/policies/{policy_id}
     * @param {string} policyId policy_id parameter for /v3/policies/{policy_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPolicyIdPatch(policyId: string, body?: any, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPolicyIdPatch(policyId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/policies
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PoliciesApi
     */
    public policiesPost(body?: any, options?: RawAxiosRequestConfig) {
        return PoliciesApiFp(this.configuration).policiesPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ProjectsApi - axios parameter creator
 * @export
 */
export const ProjectsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {boolean} [isDomain] If this is specified as true, then only projects acting as a domain are included. Otherwise, only projects that are not acting as a domain are included.
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [parentId] Filters the response by a parent ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet: async (domainId?: string, enabled?: boolean, isDomain?: boolean, name?: string, parentId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (domainId !== undefined) {
                localVarQueryParameter['domain_id'] = domainId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (isDomain !== undefined) {
                localVarQueryParameter['is_domain'] = isDomain;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parent_id'] = parentId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create project.  POST /v3/projects
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost: async (project?: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/projects`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete project.  DELETE /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdDelete: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdDelete', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGet', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesGet: async (projectId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesGet', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesGet', 'groupId', groupId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesHead: async (projectId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesHead', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesHead', 'groupId', groupId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete grant of role for group on project.  DELETE /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdDelete: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdDelete', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdDelete', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdGet: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdGet', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdGet', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdHead: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdHead', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdHead', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant role for group on project.  PUT /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdPut: async (projectId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdPut', 'projectId', projectId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdPut', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdGroupsGroupIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdHead: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdHead', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update project.  PATCH /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdPatch: async (projectId: string, project?: Project, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdPatch', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(project, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete all tags associated with a given project.  DELETE /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsDelete: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsDelete', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsGet: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsGet', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsHead: async (projectId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsHead', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update all tags associated with a given project.  PUT /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsPut: async (projectId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsPut', 'projectId', projectId)
            const localVarPath = `/v3/projects/{project_id}/tags`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a single tag from a project.  /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueDelete: async (projectId: string, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueDelete', 'projectId', projectId)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueDelete', 'value', value)
            const localVarPath = `/v3/projects/{project_id}/tags/{value}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueGet: async (projectId: string, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueGet', 'projectId', projectId)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueGet', 'value', value)
            const localVarPath = `/v3/projects/{project_id}/tags/{value}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueHead: async (projectId: string, value: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueHead', 'projectId', projectId)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('projectsProjectIdTagsValueHead', 'value', value)
            const localVarPath = `/v3/projects/{project_id}/tags/{value}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Add a single tag to a project.  PUT /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValuePut: async (projectId: string, value: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdTagsValuePut', 'projectId', projectId)
            // verify required parameter 'value' is not null or undefined
            assertParamExists('projectsProjectIdTagsValuePut', 'value', value)
            const localVarPath = `/v3/projects/{project_id}/tags/{value}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"value"}}`, encodeURIComponent(String(value)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesGet: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesGet', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesGet', 'userId', userId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesHead: async (projectId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesHead', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesHead', 'userId', userId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete grant of role for user on project.  DELETE /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdDelete: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdDelete', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdGet: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdGet', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdGet', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdHead: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdHead', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdHead', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant role for user on project.  PUT /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdPut: async (projectId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'projectId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdPut', 'projectId', projectId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdPut', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('projectsProjectIdUsersUserIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/projects/{project_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"project_id"}}`, encodeURIComponent(String(projectId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProjectsApi - functional programming interface
 * @export
 */
export const ProjectsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProjectsApiAxiosParamCreator(configuration)
    return {
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {boolean} [isDomain] If this is specified as true, then only projects acting as a domain are included. Otherwise, only projects that are not acting as a domain are included.
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [parentId] Filters the response by a parent ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsGet(domainId?: string, enabled?: boolean, isDomain?: boolean, name?: string, parentId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsGet(domainId, enabled, isDomain, name, parentId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create project.  POST /v3/projects
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsPost(project?: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsPost(project, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete project.  DELETE /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdDelete(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGet(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesGet(projectId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesInfos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesGet(projectId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesHead(projectId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesHead(projectId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete grant of role for group on project.  DELETE /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Grant role for group on project.  PUT /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdGroupsGroupIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdHead(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdHead(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update project.  PATCH /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdPatch(projectId: string, project?: Project, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Project>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdPatch(projectId, project, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete all tags associated with a given project.  DELETE /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsDelete(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsDelete(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsGet(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsTagsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsGet(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsHead(projectId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsHead(projectId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update all tags associated with a given project.  PUT /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsPut(projectId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProjectsTagsPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsPut(projectId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a single tag from a project.  /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsValueDelete(projectId: string, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsValueDelete(projectId, value, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsValueDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsValueGet(projectId: string, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsValueGet(projectId, value, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsValueGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsValueHead(projectId: string, value: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsValueHead(projectId, value, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsValueHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Add a single tag to a project.  PUT /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdTagsValuePut(projectId: string, value: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdTagsValuePut(projectId, value, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdTagsValuePut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesGet(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesInfos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesGet(projectId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesHead(projectId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesHead(projectId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete grant of role for user on project.  DELETE /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesRoleIdGet(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesRoleIdGet(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesRoleIdHead(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesRoleIdHead(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Grant role for user on project.  PUT /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async projectsProjectIdUsersUserIdRolesRoleIdPut(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.projectsProjectIdUsersUserIdRolesRoleIdPut(projectId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ProjectsApi.projectsProjectIdUsersUserIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ProjectsApi - factory interface
 * @export
 */
export const ProjectsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProjectsApiFp(configuration)
    return {
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {boolean} [isDomain] If this is specified as true, then only projects acting as a domain are included. Otherwise, only projects that are not acting as a domain are included.
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [parentId] Filters the response by a parent ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsGet(domainId?: string, enabled?: boolean, isDomain?: boolean, name?: string, parentId?: string, options?: any): AxiosPromise<ProjectsGetResponse> {
            return localVarFp.projectsGet(domainId, enabled, isDomain, name, parentId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsHead(options?: any): AxiosPromise<void> {
            return localVarFp.projectsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create project.  POST /v3/projects
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsPost(project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsPost(project, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete project.  DELETE /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdDelete(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGet(projectId: string, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsProjectIdGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesGet(projectId: string, groupId: string, options?: any): AxiosPromise<RolesInfos> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesGet(projectId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesHead(projectId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesHead(projectId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete grant of role for group on project.  DELETE /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant role for group on project.  PUT /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdHead(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdHead(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update project.  PATCH /v3/projects/{project_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
         * @param {Project} [project] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdPatch(projectId: string, project?: Project, options?: any): AxiosPromise<Project> {
            return localVarFp.projectsProjectIdPatch(projectId, project, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete all tags associated with a given project.  DELETE /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsDelete(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdTagsDelete(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsGet(projectId: string, options?: any): AxiosPromise<ProjectsTagsGetResponse> {
            return localVarFp.projectsProjectIdTagsGet(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsHead(projectId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdTagsHead(projectId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update all tags associated with a given project.  PUT /v3/projects/{project_id}/tags
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsPut(projectId: string, body?: any, options?: any): AxiosPromise<ProjectsTagsPutResponse> {
            return localVarFp.projectsProjectIdTagsPut(projectId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a single tag from a project.  /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueDelete(projectId: string, value: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdTagsValueDelete(projectId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueGet(projectId: string, value: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdTagsValueGet(projectId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValueHead(projectId: string, value: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdTagsValueHead(projectId, value, options).then((request) => request(axios, basePath));
        },
        /**
         * Add a single tag to a project.  PUT /v3/projects/{project_id}/tags/{value}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdTagsValuePut(projectId: string, value: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.projectsProjectIdTagsValuePut(projectId, value, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesGet(projectId: string, userId: string, options?: any): AxiosPromise<RolesInfos> {
            return localVarFp.projectsProjectIdUsersUserIdRolesGet(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesHead(projectId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdRolesHead(projectId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete grant of role for user on project.  DELETE /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdGet(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdRolesRoleIdGet(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdHead(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdRolesRoleIdHead(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant role for user on project.  PUT /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
         * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
         * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        projectsProjectIdUsersUserIdRolesRoleIdPut(projectId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.projectsProjectIdUsersUserIdRolesRoleIdPut(projectId, userId, roleId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProjectsApi - object-oriented interface
 * @export
 * @class ProjectsApi
 * @extends {BaseAPI}
 */
export class ProjectsApi extends BaseAPI {
    /**
     * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
     * @param {string} [domainId] Filters the response by a domain ID.
     * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
     * @param {boolean} [isDomain] If this is specified as true, then only projects acting as a domain are included. Otherwise, only projects that are not acting as a domain are included.
     * @param {string} [name] Filters the response by a resource name.
     * @param {string} [parentId] Filters the response by a parent ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsGet(domainId?: string, enabled?: boolean, isDomain?: boolean, name?: string, parentId?: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsGet(domainId, enabled, isDomain, name, parentId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsHead(options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create project.  POST /v3/projects
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsPost(project?: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsPost(project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete project.  DELETE /v3/projects/{project_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdDelete(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesGet(projectId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesGet(projectId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List grants for group on project.  GET/HEAD /v3/projects/{project_id}/groups/{group_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesHead(projectId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesHead(projectId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete grant of role for group on project.  DELETE /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesRoleIdDelete(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesRoleIdGet(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check grant for project, group, role.  GET/HEAD /v3/projects/{project_id/groups/{group_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesRoleIdHead(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant role for group on project.  PUT /v3/projects/{project_id}/groups/{group_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} groupId group_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdGroupsGroupIdRolesRoleIdPut(projectId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get project or list projects.  GET/HEAD /v3/projects GET/HEAD /v3/projects/{project_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdHead(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdHead(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update project.  PATCH /v3/projects/{project_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id} API
     * @param {Project} [project] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdPatch(projectId: string, project?: Project, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdPatch(projectId, project, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete all tags associated with a given project.  DELETE /v3/projects/{project_id}/tags
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsDelete(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsDelete(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsGet(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsGet(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List tags associated with a given project.  GET /v3/projects/{project_id}/tags
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsHead(projectId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsHead(projectId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update all tags associated with a given project.  PUT /v3/projects/{project_id}/tags
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsPut(projectId: string, body?: any, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsPut(projectId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a single tag from a project.  /v3/projects/{project_id}/tags/{value}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsValueDelete(projectId: string, value: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsValueDelete(projectId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsValueGet(projectId: string, value: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsValueGet(projectId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get information for a single tag associated with a given project.  GET /v3/projects/{project_id}/tags/{value}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsValueHead(projectId: string, value: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsValueHead(projectId, value, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Add a single tag to a project.  PUT /v3/projects/{project_id}/tags/{value}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {string} value value parameter for /v3/projects/{project_id}/tags/{value} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdTagsValuePut(projectId: string, value: string, body?: any, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdTagsValuePut(projectId, value, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesGet(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesGet(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List grants for user on project.  GET/HEAD /v3/projects/{project_id}/users/{user_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesHead(projectId: string, userId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesHead(projectId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete grant of role for user on project.  DELETE /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesRoleIdDelete(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesRoleIdGet(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesRoleIdGet(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check grant for project, user, role.  GET/HEAD /v3/projects/{project_id/users/{user_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesRoleIdHead(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesRoleIdHead(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant role for user on project.  PUT /v3/projects/{project_id}/users/{user_id}/roles/{role_id}
     * @param {string} projectId project_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} userId user_id parameter for /v3/projects/{project_id}/users/{user_id}/roles API
     * @param {string} roleId role_id parameter for /v3/projects/{project_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProjectsApi
     */
    public projectsProjectIdUsersUserIdRolesRoleIdPut(projectId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return ProjectsApiFp(this.configuration).projectsProjectIdUsersUserIdRolesRoleIdPut(projectId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegionsApi - axios parameter creator
 * @export
 */
export const RegionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/regions
         * @param {string} [parentRegionId] Filters the response by a parent region, by ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGet: async (parentRegionId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (parentRegionId !== undefined) {
                localVarQueryParameter['parent_region_id'] = parentRegionId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/regions
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPost: async (region?: Region, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/regions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdDelete: async (regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('regionsRegionIdDelete', 'regionId', regionId)
            const localVarPath = `/v3/regions/{region_id}`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdGet: async (regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('regionsRegionIdGet', 'regionId', regionId)
            const localVarPath = `/v3/regions/{region_id}`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdHead: async (regionId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('regionsRegionIdHead', 'regionId', regionId)
            const localVarPath = `/v3/regions/{region_id}`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdPatch: async (regionId: string, region?: Region, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('regionsRegionIdPatch', 'regionId', regionId)
            const localVarPath = `/v3/regions/{region_id}`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(region, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PUT operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdPut: async (regionId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'regionId' is not null or undefined
            assertParamExists('regionsRegionIdPut', 'regionId', regionId)
            const localVarPath = `/v3/regions/{region_id}`
                .replace(`{${"region_id"}}`, encodeURIComponent(String(regionId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegionsApi - functional programming interface
 * @export
 */
export const RegionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegionsApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/regions
         * @param {string} [parentRegionId] Filters the response by a parent region, by ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsGet(parentRegionId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegionsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsGet(parentRegionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/regions
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsPost(region?: Region, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsPost(region, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsRegionIdDelete(regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsRegionIdDelete(regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsRegionIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsRegionIdGet(regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsRegionIdGet(regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsRegionIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsRegionIdHead(regionId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsRegionIdHead(regionId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsRegionIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsRegionIdPatch(regionId: string, region?: Region, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Region>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsRegionIdPatch(regionId, region, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsRegionIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PUT operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async regionsRegionIdPut(regionId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.regionsRegionIdPut(regionId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegionsApi.regionsRegionIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RegionsApi - factory interface
 * @export
 */
export const RegionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegionsApiFp(configuration)
    return {
        /**
         * GET operation on /v3/regions
         * @param {string} [parentRegionId] Filters the response by a parent region, by ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsGet(parentRegionId?: string, options?: any): AxiosPromise<RegionsGetResponse> {
            return localVarFp.regionsGet(parentRegionId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/regions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsHead(options?: any): AxiosPromise<void> {
            return localVarFp.regionsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/regions
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsPost(region?: Region, options?: any): AxiosPromise<Region> {
            return localVarFp.regionsPost(region, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdDelete(regionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.regionsRegionIdDelete(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdGet(regionId: string, options?: any): AxiosPromise<Region> {
            return localVarFp.regionsRegionIdGet(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdHead(regionId: string, options?: any): AxiosPromise<void> {
            return localVarFp.regionsRegionIdHead(regionId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {Region} [region] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdPatch(regionId: string, region?: Region, options?: any): AxiosPromise<Region> {
            return localVarFp.regionsRegionIdPatch(regionId, region, options).then((request) => request(axios, basePath));
        },
        /**
         * PUT operation on /v3/regions/{region_id}
         * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        regionsRegionIdPut(regionId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.regionsRegionIdPut(regionId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegionsApi - object-oriented interface
 * @export
 * @class RegionsApi
 * @extends {BaseAPI}
 */
export class RegionsApi extends BaseAPI {
    /**
     * GET operation on /v3/regions
     * @param {string} [parentRegionId] Filters the response by a parent region, by ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsGet(parentRegionId?: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsGet(parentRegionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/regions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsHead(options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/regions
     * @param {Region} [region] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsPost(region?: Region, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsPost(region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/regions/{region_id}
     * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsRegionIdDelete(regionId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsRegionIdDelete(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/regions/{region_id}
     * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsRegionIdGet(regionId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsRegionIdGet(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/regions/{region_id}
     * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsRegionIdHead(regionId: string, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsRegionIdHead(regionId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/regions/{region_id}
     * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
     * @param {Region} [region] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsRegionIdPatch(regionId: string, region?: Region, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsRegionIdPatch(regionId, region, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PUT operation on /v3/regions/{region_id}
     * @param {string} regionId region_id parameter for /v3/regions/{region_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegionsApi
     */
    public regionsRegionIdPut(regionId: string, body?: any, options?: RawAxiosRequestConfig) {
        return RegionsApiFp(this.configuration).regionsRegionIdPut(regionId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RegisteredLimitsApi - axios parameter creator
 * @export
 */
export const RegisteredLimitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/registered_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/registered_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/registered_limits
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/registered_limits`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdDelete: async (registeredLimitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registeredLimitId' is not null or undefined
            assertParamExists('registeredLimitsRegisteredLimitIdDelete', 'registeredLimitId', registeredLimitId)
            const localVarPath = `/v3/registered_limits/{registered_limit_id}`
                .replace(`{${"registered_limit_id"}}`, encodeURIComponent(String(registeredLimitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdGet: async (registeredLimitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registeredLimitId' is not null or undefined
            assertParamExists('registeredLimitsRegisteredLimitIdGet', 'registeredLimitId', registeredLimitId)
            const localVarPath = `/v3/registered_limits/{registered_limit_id}`
                .replace(`{${"registered_limit_id"}}`, encodeURIComponent(String(registeredLimitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdHead: async (registeredLimitId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registeredLimitId' is not null or undefined
            assertParamExists('registeredLimitsRegisteredLimitIdHead', 'registeredLimitId', registeredLimitId)
            const localVarPath = `/v3/registered_limits/{registered_limit_id}`
                .replace(`{${"registered_limit_id"}}`, encodeURIComponent(String(registeredLimitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdPatch: async (registeredLimitId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registeredLimitId' is not null or undefined
            assertParamExists('registeredLimitsRegisteredLimitIdPatch', 'registeredLimitId', registeredLimitId)
            const localVarPath = `/v3/registered_limits/{registered_limit_id}`
                .replace(`{${"registered_limit_id"}}`, encodeURIComponent(String(registeredLimitId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RegisteredLimitsApi - functional programming interface
 * @export
 */
export const RegisteredLimitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RegisteredLimitsApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/registered_limits
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsRegisteredLimitIdDelete(registeredLimitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsRegisteredLimitIdDelete(registeredLimitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsRegisteredLimitIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsRegisteredLimitIdGet(registeredLimitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsRegisteredLimitIdGet(registeredLimitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsRegisteredLimitIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsRegisteredLimitIdHead(registeredLimitId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsRegisteredLimitIdHead(registeredLimitId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsRegisteredLimitIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registeredLimitsRegisteredLimitIdPatch(registeredLimitId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registeredLimitsRegisteredLimitIdPatch(registeredLimitId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RegisteredLimitsApi.registeredLimitsRegisteredLimitIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RegisteredLimitsApi - factory interface
 * @export
 */
export const RegisteredLimitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RegisteredLimitsApiFp(configuration)
    return {
        /**
         * GET operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsGet(options?: any): AxiosPromise<any> {
            return localVarFp.registeredLimitsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/registered_limits
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsHead(options?: any): AxiosPromise<void> {
            return localVarFp.registeredLimitsHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/registered_limits
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.registeredLimitsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdDelete(registeredLimitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.registeredLimitsRegisteredLimitIdDelete(registeredLimitId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdGet(registeredLimitId: string, options?: any): AxiosPromise<any> {
            return localVarFp.registeredLimitsRegisteredLimitIdGet(registeredLimitId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdHead(registeredLimitId: string, options?: any): AxiosPromise<void> {
            return localVarFp.registeredLimitsRegisteredLimitIdHead(registeredLimitId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/registered_limits/{registered_limit_id}
         * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registeredLimitsRegisteredLimitIdPatch(registeredLimitId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.registeredLimitsRegisteredLimitIdPatch(registeredLimitId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RegisteredLimitsApi - object-oriented interface
 * @export
 * @class RegisteredLimitsApi
 * @extends {BaseAPI}
 */
export class RegisteredLimitsApi extends BaseAPI {
    /**
     * GET operation on /v3/registered_limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsGet(options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/registered_limits
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsHead(options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/registered_limits
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsPost(body?: any, options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/registered_limits/{registered_limit_id}
     * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsRegisteredLimitIdDelete(registeredLimitId: string, options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsRegisteredLimitIdDelete(registeredLimitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/registered_limits/{registered_limit_id}
     * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsRegisteredLimitIdGet(registeredLimitId: string, options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsRegisteredLimitIdGet(registeredLimitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/registered_limits/{registered_limit_id}
     * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsRegisteredLimitIdHead(registeredLimitId: string, options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsRegisteredLimitIdHead(registeredLimitId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/registered_limits/{registered_limit_id}
     * @param {string} registeredLimitId registered_limit_id parameter for /v3/registered_limits/{registered_limit_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RegisteredLimitsApi
     */
    public registeredLimitsRegisteredLimitIdPatch(registeredLimitId: string, body?: any, options?: RawAxiosRequestConfig) {
        return RegisteredLimitsApiFp(this.configuration).registeredLimitsRegisteredLimitIdPatch(registeredLimitId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoleAssignmentsApi - axios parameter creator
 * @export
 */
export const RoleAssignmentsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {any | null} [effective] Returns the effective assignments, including any assignments gained by virtue of group membership.
         * @param {any | null} [includeNames] If set, then the names of any entities returned will be include as well as their IDs. Any value other than 0 (including no value) will be interpreted as true.
         * @param {any | null} [includeSubtree] If set, then relevant assignments in the project hierarchy below the project specified in the scope.project_id query parameter are also included in the response. Any value other than 0 (including no value) for include_subtree will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleAssignmentsGet: async (groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, effective?: any | null, includeNames?: any | null, includeSubtree?: any | null, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/role_assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['group.id'] = groupId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role.id'] = roleId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user.id'] = userId;
            }

            if (scopeDomainId !== undefined) {
                localVarQueryParameter['scope.domain.id'] = scopeDomainId;
            }

            if (scopeProjectId !== undefined) {
                localVarQueryParameter['scope.project.id'] = scopeProjectId;
            }

            if (scopeOSINHERITinheritedTo !== undefined) {
                localVarQueryParameter['scope.OS-INHERIT:inherited_to'] = scopeOSINHERITinheritedTo;
            }

            if (effective !== undefined) {
                for (const [key, value] of Object.entries(effective)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (includeNames !== undefined) {
                for (const [key, value] of Object.entries(includeNames)) {
                    localVarQueryParameter[key] = value;
                }
            }

            if (includeSubtree !== undefined) {
                for (const [key, value] of Object.entries(includeSubtree)) {
                    localVarQueryParameter[key] = value;
                }
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleAssignmentsHead: async (groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/role_assignments`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (groupId !== undefined) {
                localVarQueryParameter['group.id'] = groupId;
            }

            if (roleId !== undefined) {
                localVarQueryParameter['role.id'] = roleId;
            }

            if (userId !== undefined) {
                localVarQueryParameter['user.id'] = userId;
            }

            if (scopeDomainId !== undefined) {
                localVarQueryParameter['scope.domain.id'] = scopeDomainId;
            }

            if (scopeProjectId !== undefined) {
                localVarQueryParameter['scope.project.id'] = scopeProjectId;
            }

            if (scopeOSINHERITinheritedTo !== undefined) {
                localVarQueryParameter['scope.OS-INHERIT:inherited_to'] = scopeOSINHERITinheritedTo;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleAssignmentsApi - functional programming interface
 * @export
 */
export const RoleAssignmentsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleAssignmentsApiAxiosParamCreator(configuration)
    return {
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {any | null} [effective] Returns the effective assignments, including any assignments gained by virtue of group membership.
         * @param {any | null} [includeNames] If set, then the names of any entities returned will be include as well as their IDs. Any value other than 0 (including no value) will be interpreted as true.
         * @param {any | null} [includeSubtree] If set, then relevant assignments in the project hierarchy below the project specified in the scope.project_id query parameter are also included in the response. Any value other than 0 (including no value) for include_subtree will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleAssignmentsGet(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, effective?: any | null, includeNames?: any | null, includeSubtree?: any | null, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleAssignmentsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleAssignmentsGet(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, effective, includeNames, includeSubtree, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoleAssignmentsApi.roleAssignmentsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleAssignmentsHead(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleAssignmentsHead(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoleAssignmentsApi.roleAssignmentsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RoleAssignmentsApi - factory interface
 * @export
 */
export const RoleAssignmentsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleAssignmentsApiFp(configuration)
    return {
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {any | null} [effective] Returns the effective assignments, including any assignments gained by virtue of group membership.
         * @param {any | null} [includeNames] If set, then the names of any entities returned will be include as well as their IDs. Any value other than 0 (including no value) will be interpreted as true.
         * @param {any | null} [includeSubtree] If set, then relevant assignments in the project hierarchy below the project specified in the scope.project_id query parameter are also included in the response. Any value other than 0 (including no value) for include_subtree will be interpreted as true.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleAssignmentsGet(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, effective?: any | null, includeNames?: any | null, includeSubtree?: any | null, options?: any): AxiosPromise<RoleAssignmentsGetResponse> {
            return localVarFp.roleAssignmentsGet(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, effective, includeNames, includeSubtree, options).then((request) => request(axios, basePath));
        },
        /**
         * List all role assignments.  GET/HEAD /v3/role_assignments
         * @param {string} [groupId] Filters the response by a group ID.
         * @param {string} [roleId] Filters the response by a role ID.
         * @param {string} [userId] Filters the response by a user ID.
         * @param {string} [scopeDomainId] Filters the response by a domain ID.
         * @param {string} [scopeProjectId] Filters the response by a project ID.
         * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleAssignmentsHead(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, options?: any): AxiosPromise<void> {
            return localVarFp.roleAssignmentsHead(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleAssignmentsApi - object-oriented interface
 * @export
 * @class RoleAssignmentsApi
 * @extends {BaseAPI}
 */
export class RoleAssignmentsApi extends BaseAPI {
    /**
     * List all role assignments.  GET/HEAD /v3/role_assignments
     * @param {string} [groupId] Filters the response by a group ID.
     * @param {string} [roleId] Filters the response by a role ID.
     * @param {string} [userId] Filters the response by a user ID.
     * @param {string} [scopeDomainId] Filters the response by a domain ID.
     * @param {string} [scopeProjectId] Filters the response by a project ID.
     * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
     * @param {any | null} [effective] Returns the effective assignments, including any assignments gained by virtue of group membership.
     * @param {any | null} [includeNames] If set, then the names of any entities returned will be include as well as their IDs. Any value other than 0 (including no value) will be interpreted as true.
     * @param {any | null} [includeSubtree] If set, then relevant assignments in the project hierarchy below the project specified in the scope.project_id query parameter are also included in the response. Any value other than 0 (including no value) for include_subtree will be interpreted as true.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    public roleAssignmentsGet(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, effective?: any | null, includeNames?: any | null, includeSubtree?: any | null, options?: RawAxiosRequestConfig) {
        return RoleAssignmentsApiFp(this.configuration).roleAssignmentsGet(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, effective, includeNames, includeSubtree, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all role assignments.  GET/HEAD /v3/role_assignments
     * @param {string} [groupId] Filters the response by a group ID.
     * @param {string} [roleId] Filters the response by a role ID.
     * @param {string} [userId] Filters the response by a user ID.
     * @param {string} [scopeDomainId] Filters the response by a domain ID.
     * @param {string} [scopeProjectId] Filters the response by a project ID.
     * @param {string} [scopeOSINHERITinheritedTo] Filters based on role assignments that are inherited. The only value of inherited_to that is currently supported is projects.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleAssignmentsApi
     */
    public roleAssignmentsHead(groupId?: string, roleId?: string, userId?: string, scopeDomainId?: string, scopeProjectId?: string, scopeOSINHERITinheritedTo?: string, options?: RawAxiosRequestConfig) {
        return RoleAssignmentsApiFp(this.configuration).roleAssignmentsHead(groupId, roleId, userId, scopeDomainId, scopeProjectId, scopeOSINHERITinheritedTo, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoleInferencesApi - axios parameter creator
 * @export
 */
export const RoleInferencesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleInferencesGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/role_inferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleInferencesHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/role_inferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoleInferencesApi - functional programming interface
 * @export
 */
export const RoleInferencesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoleInferencesApiAxiosParamCreator(configuration)
    return {
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleInferencesGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RoleInferencesGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleInferencesGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoleInferencesApi.roleInferencesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async roleInferencesHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.roleInferencesHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RoleInferencesApi.roleInferencesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RoleInferencesApi - factory interface
 * @export
 */
export const RoleInferencesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoleInferencesApiFp(configuration)
    return {
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleInferencesGet(options?: any): AxiosPromise<RoleInferencesGetResponse> {
            return localVarFp.roleInferencesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * List role inference rules.  GET/HEAD /v3/role_inferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        roleInferencesHead(options?: any): AxiosPromise<void> {
            return localVarFp.roleInferencesHead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoleInferencesApi - object-oriented interface
 * @export
 * @class RoleInferencesApi
 * @extends {BaseAPI}
 */
export class RoleInferencesApi extends BaseAPI {
    /**
     * List role inference rules.  GET/HEAD /v3/role_inferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInferencesApi
     */
    public roleInferencesGet(options?: RawAxiosRequestConfig) {
        return RoleInferencesApiFp(this.configuration).roleInferencesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List role inference rules.  GET/HEAD /v3/role_inferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoleInferencesApi
     */
    public roleInferencesHead(options?: RawAxiosRequestConfig) {
        return RoleInferencesApiFp(this.configuration).roleInferencesHead(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RolesApi - axios parameter creator
 * @export
 */
export const RolesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesGet: async (domainId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesGet', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesGet', 'groupId', groupId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesHead: async (domainId: string, groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesHead', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesHead', 'groupId', groupId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from a group on a domain.  DELETE /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdDelete: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdDelete', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdDelete', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdGet: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdGet', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdGet', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdHead: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdHead', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdHead', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a role to a group on a domain.  PUT /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdPut: async (domainId: string, groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdPut', 'domainId', domainId)
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdPut', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdGroupsGroupIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesGet: async (domainId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesGet', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesGet', 'userId', userId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesHead: async (domainId: string, userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesHead', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesHead', 'userId', userId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from user on a domain.  DELETE /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdDelete: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdDelete', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdGet: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdGet', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdGet', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdHead: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdHead', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdHead', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a role to a user on a domain.  PUT /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdPut: async (domainId: string, userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'domainId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdPut', 'domainId', domainId)
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdPut', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('domainsDomainIdUsersUserIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/domains/{domain_id}/users/{user_id}/roles/{role_id}`
                .replace(`{${"domain_id"}}`, encodeURIComponent(String(domainId)))
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGet: async (domainId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (domainId !== undefined) {
                localVarQueryParameter['domain_id'] = domainId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create role.  POST /v3/roles
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPost: async (role?: Role, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/roles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesGet: async (priorRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesGet', 'priorRoleId', priorRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesHead: async (priorRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesHead', 'priorRoleId', priorRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete implied role.  DELETE /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdDelete: async (priorRoleId: string, impliedRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdDelete', 'priorRoleId', priorRoleId)
            // verify required parameter 'impliedRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdDelete', 'impliedRoleId', impliedRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies/{implied_role_id}`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)))
                .replace(`{${"implied_role_id"}}`, encodeURIComponent(String(impliedRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdGet: async (priorRoleId: string, impliedRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdGet', 'priorRoleId', priorRoleId)
            // verify required parameter 'impliedRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdGet', 'impliedRoleId', impliedRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies/{implied_role_id}`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)))
                .replace(`{${"implied_role_id"}}`, encodeURIComponent(String(impliedRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdHead: async (priorRoleId: string, impliedRoleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdHead', 'priorRoleId', priorRoleId)
            // verify required parameter 'impliedRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdHead', 'impliedRoleId', impliedRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies/{implied_role_id}`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)))
                .replace(`{${"implied_role_id"}}`, encodeURIComponent(String(impliedRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create implied role.  PUT /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdPut: async (priorRoleId: string, impliedRoleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'priorRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdPut', 'priorRoleId', priorRoleId)
            // verify required parameter 'impliedRoleId' is not null or undefined
            assertParamExists('rolesPriorRoleIdImpliesImpliedRoleIdPut', 'impliedRoleId', impliedRoleId)
            const localVarPath = `/v3/roles/{prior_role_id}/implies/{implied_role_id}`
                .replace(`{${"prior_role_id"}}`, encodeURIComponent(String(priorRoleId)))
                .replace(`{${"implied_role_id"}}`, encodeURIComponent(String(impliedRoleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete role.  DELETE /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdDelete: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdGet: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdHead: async (roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update role.  PATCH /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdPatch: async (roleId: string, role?: Role, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('rolesRoleIdPatch', 'roleId', roleId)
            const localVarPath = `/v3/roles/{role_id}`
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(role, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RolesApi - functional programming interface
 * @export
 */
export const RolesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RolesApiAxiosParamCreator(configuration)
    return {
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesGet(domainId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesInfos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesGet(domainId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesHead(domainId: string, groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesHead(domainId, groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a role from a group on a domain.  DELETE /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Grant a role to a group on a domain.  PUT /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId, groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdGroupsGroupIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesGet(domainId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesInfos>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesGet(domainId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesHead(domainId: string, userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesHead(domainId, userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a role from user on a domain.  DELETE /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesRoleIdGet(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesRoleIdGet(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesRoleIdHead(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesRoleIdHead(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a role to a user on a domain.  PUT /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async domainsDomainIdUsersUserIdRolesRoleIdPut(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.domainsDomainIdUsersUserIdRolesRoleIdPut(domainId, userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.domainsDomainIdUsersUserIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesGet(domainId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesGet(domainId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create role.  POST /v3/roles
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPost(role?: Role, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPost(role, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesGet(priorRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesImpliesGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesGet(priorRoleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesHead(priorRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesHead(priorRoleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete implied role.  DELETE /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId, impliedRoleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesImpliedRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesImplyGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId, impliedRoleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesImpliedRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId, impliedRoleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesImpliedRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create implied role.  PUT /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId: string, impliedRoleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RolesImplyPutResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId, impliedRoleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesPriorRoleIdImpliesImpliedRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete role.  DELETE /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRoleIdDelete(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRoleIdDelete(roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRoleIdGet(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRoleIdGet(roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRoleIdHead(roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRoleIdHead(roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update role.  PATCH /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async rolesRoleIdPatch(roleId: string, role?: Role, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Role>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.rolesRoleIdPatch(roleId, role, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['RolesApi.rolesRoleIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * RolesApi - factory interface
 * @export
 */
export const RolesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RolesApiFp(configuration)
    return {
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesGet(domainId: string, groupId: string, options?: any): AxiosPromise<RolesInfos> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesGet(domainId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesHead(domainId: string, groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesHead(domainId, groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from a group on a domain.  DELETE /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a role to a group on a domain.  PUT /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId: string, groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId, groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesGet(domainId: string, userId: string, options?: any): AxiosPromise<RolesInfos> {
            return localVarFp.domainsDomainIdUsersUserIdRolesGet(domainId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesHead(domainId: string, userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdUsersUserIdRolesHead(domainId, userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from user on a domain.  DELETE /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdGet(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdUsersUserIdRolesRoleIdGet(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdHead(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdUsersUserIdRolesRoleIdHead(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create a role to a user on a domain.  PUT /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
         * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        domainsDomainIdUsersUserIdRolesRoleIdPut(domainId: string, userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.domainsDomainIdUsersUserIdRolesRoleIdPut(domainId, userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesGet(domainId?: string, options?: any): AxiosPromise<RolesGetResponse> {
            return localVarFp.rolesGet(domainId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesHead(options?: any): AxiosPromise<void> {
            return localVarFp.rolesHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create role.  POST /v3/roles
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPost(role?: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesPost(role, options).then((request) => request(axios, basePath));
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesGet(priorRoleId: string, options?: any): AxiosPromise<RolesImpliesGetResponse> {
            return localVarFp.rolesPriorRoleIdImpliesGet(priorRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesHead(priorRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolesPriorRoleIdImpliesHead(priorRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete implied role.  DELETE /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId: string, impliedRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId, impliedRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId: string, impliedRoleId: string, options?: any): AxiosPromise<RolesImplyGetResponse> {
            return localVarFp.rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId, impliedRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId: string, impliedRoleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId, impliedRoleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create implied role.  PUT /v3/roles/{prior_role_id}/implies/{implied_role_id}
         * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId: string, impliedRoleId: string, body?: any, options?: any): AxiosPromise<RolesImplyPutResponse> {
            return localVarFp.rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId, impliedRoleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete role.  DELETE /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdDelete(roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolesRoleIdDelete(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdGet(roleId: string, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesRoleIdGet(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdHead(roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.rolesRoleIdHead(roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Update role.  PATCH /v3/roles/{role_id}
         * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
         * @param {Role} [role] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        rolesRoleIdPatch(roleId: string, role?: Role, options?: any): AxiosPromise<Role> {
            return localVarFp.rolesRoleIdPatch(roleId, role, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RolesApi - object-oriented interface
 * @export
 * @class RolesApi
 * @extends {BaseAPI}
 */
export class RolesApi extends BaseAPI {
    /**
     * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesGet(domainId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesGet(domainId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all domain grats for a specific group.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesHead(domainId: string, groupId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesHead(domainId, groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from a group on a domain.  DELETE /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesRoleIdDelete(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesRoleIdGet(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a group has a specific role on a domain.  GET/HEAD /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesRoleIdHead(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a role to a group on a domain.  PUT /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} groupId group_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId: string, groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdGroupsGroupIdRolesRoleIdPut(domainId, groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesGet(domainId: string, userId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesGet(domainId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get user grant.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesHead(domainId: string, userId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesHead(domainId, userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from user on a domain.  DELETE /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesRoleIdDelete(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesRoleIdGet(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesRoleIdGet(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user has a specific role on the domain.  GET/HEAD /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesRoleIdHead(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesRoleIdHead(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a role to a user on a domain.  PUT /v3/domains/{domain_id}/users/{user_id}/roles/{role_id}
     * @param {string} domainId domain_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} userId user_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/domains/{domain_id}/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public domainsDomainIdUsersUserIdRolesRoleIdPut(domainId: string, userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).domainsDomainIdUsersUserIdRolesRoleIdPut(domainId, userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
     * @param {string} [domainId] Filters the response by a domain ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesGet(domainId?: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesGet(domainId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesHead(options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create role.  POST /v3/roles
     * @param {Role} [role] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPost(role?: Role, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPost(role, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesGet(priorRoleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesGet(priorRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List Implied Roles.  GET/HEAD /v3/roles/{prior_role_id}/implies
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesHead(priorRoleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesHead(priorRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete implied role.  DELETE /v3/roles/{prior_role_id}/implies/{implied_role_id}
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesImpliedRoleIdDelete(priorRoleId, impliedRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesImpliedRoleIdGet(priorRoleId, impliedRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get implied role.  GET/HEAD /v3/roles/{prior_role_id}/implies/{implied_role_id}
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId: string, impliedRoleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesImpliedRoleIdHead(priorRoleId, impliedRoleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create implied role.  PUT /v3/roles/{prior_role_id}/implies/{implied_role_id}
     * @param {string} priorRoleId prior_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {string} impliedRoleId implied_role_id parameter for /v3/roles/{prior_role_id}/implies/{implied_role_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId: string, impliedRoleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesPriorRoleIdImpliesImpliedRoleIdPut(priorRoleId, impliedRoleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete role.  DELETE /v3/roles/{role_id}
     * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesRoleIdDelete(roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesRoleIdDelete(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
     * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesRoleIdGet(roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesRoleIdGet(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role or list roles.  GET/HEAD /v3/roles GET/HEAD /v3/roles/{role_id}
     * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesRoleIdHead(roleId: string, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesRoleIdHead(roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update role.  PATCH /v3/roles/{role_id}
     * @param {string} roleId role_id parameter for /v3/roles/{role_id} API
     * @param {Role} [role] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RolesApi
     */
    public rolesRoleIdPatch(roleId: string, role?: Role, options?: RawAxiosRequestConfig) {
        return RolesApiFp(this.configuration).rolesRoleIdPatch(roleId, role, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * S3tokensApi - axios parameter creator
 * @export
 */
export const S3tokensApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/s3tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/s3tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authenticate s3token.  POST /v3/s3tokens
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensPost: async (body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/s3tokens`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * S3tokensApi - functional programming interface
 * @export
 */
export const S3tokensApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = S3tokensApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async s3tokensGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.s3tokensGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['S3tokensApi.s3tokensGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async s3tokensHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.s3tokensHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['S3tokensApi.s3tokensHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Authenticate s3token.  POST /v3/s3tokens
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async s3tokensPost(body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.s3tokensPost(body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['S3tokensApi.s3tokensPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * S3tokensApi - factory interface
 * @export
 */
export const S3tokensApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = S3tokensApiFp(configuration)
    return {
        /**
         * GET operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensGet(options?: any): AxiosPromise<any> {
            return localVarFp.s3tokensGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/s3tokens
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensHead(options?: any): AxiosPromise<void> {
            return localVarFp.s3tokensHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Authenticate s3token.  POST /v3/s3tokens
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        s3tokensPost(body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.s3tokensPost(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * S3tokensApi - object-oriented interface
 * @export
 * @class S3tokensApi
 * @extends {BaseAPI}
 */
export class S3tokensApi extends BaseAPI {
    /**
     * GET operation on /v3/s3tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3tokensApi
     */
    public s3tokensGet(options?: RawAxiosRequestConfig) {
        return S3tokensApiFp(this.configuration).s3tokensGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/s3tokens
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3tokensApi
     */
    public s3tokensHead(options?: RawAxiosRequestConfig) {
        return S3tokensApiFp(this.configuration).s3tokensHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authenticate s3token.  POST /v3/s3tokens
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof S3tokensApi
     */
    public s3tokensPost(body?: any, options?: RawAxiosRequestConfig) {
        return S3tokensApiFp(this.configuration).s3tokensPost(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ServicesApi - axios parameter creator
 * @export
 */
export const ServicesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3/services
         * @param {string} [service] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet: async (service?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (service !== undefined) {
                localVarQueryParameter['service'] = service;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/services
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost: async (service?: Service, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/services`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(service, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * DELETE operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdDelete: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdDelete', 'serviceId', serviceId)
            const localVarPath = `/v3/services/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdGet: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdGet', 'serviceId', serviceId)
            const localVarPath = `/v3/services/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdHead: async (serviceId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdHead', 'serviceId', serviceId)
            const localVarPath = `/v3/services/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * PATCH operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdPatch: async (serviceId: string, service?: Service, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'serviceId' is not null or undefined
            assertParamExists('servicesServiceIdPatch', 'serviceId', serviceId)
            const localVarPath = `/v3/services/{service_id}`
                .replace(`{${"service_id"}}`, encodeURIComponent(String(serviceId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(service, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ServicesApi - functional programming interface
 * @export
 */
export const ServicesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ServicesApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3/services
         * @param {string} [service] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesGet(service?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ServicesGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesGet(service, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/services
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesPost(service?: Service, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesPost(service, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * DELETE operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdDelete(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdDelete(serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesServiceIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdGet(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdGet(serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesServiceIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdHead(serviceId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdHead(serviceId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesServiceIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * PATCH operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async servicesServiceIdPatch(serviceId: string, service?: Service, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Service>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.servicesServiceIdPatch(serviceId, service, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['ServicesApi.servicesServiceIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * ServicesApi - factory interface
 * @export
 */
export const ServicesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ServicesApiFp(configuration)
    return {
        /**
         * GET operation on /v3/services
         * @param {string} [service] Filters the response by a domain ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesGet(service?: string, options?: any): AxiosPromise<ServicesGetResponse> {
            return localVarFp.servicesGet(service, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/services
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesHead(options?: any): AxiosPromise<void> {
            return localVarFp.servicesHead(options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/services
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesPost(service?: Service, options?: any): AxiosPromise<Service> {
            return localVarFp.servicesPost(service, options).then((request) => request(axios, basePath));
        },
        /**
         * DELETE operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdDelete(serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.servicesServiceIdDelete(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdGet(serviceId: string, options?: any): AxiosPromise<Service> {
            return localVarFp.servicesServiceIdGet(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdHead(serviceId: string, options?: any): AxiosPromise<void> {
            return localVarFp.servicesServiceIdHead(serviceId, options).then((request) => request(axios, basePath));
        },
        /**
         * PATCH operation on /v3/services/{service_id}
         * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
         * @param {Service} [service] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        servicesServiceIdPatch(serviceId: string, service?: Service, options?: any): AxiosPromise<Service> {
            return localVarFp.servicesServiceIdPatch(serviceId, service, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ServicesApi - object-oriented interface
 * @export
 * @class ServicesApi
 * @extends {BaseAPI}
 */
export class ServicesApi extends BaseAPI {
    /**
     * GET operation on /v3/services
     * @param {string} [service] Filters the response by a domain ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesGet(service?: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesGet(service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/services
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesHead(options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/services
     * @param {Service} [service] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesPost(service?: Service, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesPost(service, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * DELETE operation on /v3/services/{service_id}
     * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdDelete(serviceId: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesServiceIdDelete(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/services/{service_id}
     * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdGet(serviceId: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesServiceIdGet(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/services/{service_id}
     * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdHead(serviceId: string, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesServiceIdHead(serviceId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * PATCH operation on /v3/services/{service_id}
     * @param {string} serviceId service_id parameter for /v3/services/{service_id} API
     * @param {Service} [service] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ServicesApi
     */
    public servicesServiceIdPatch(serviceId: string, service?: Service, options?: RawAxiosRequestConfig) {
        return ServicesApiFp(this.configuration).servicesServiceIdPatch(serviceId, service, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * SystemApi - axios parameter creator
 * @export
 */
export const SystemApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesGet: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesGet', 'groupId', groupId)
            const localVarPath = `/v3/system/groups/{group_id}/roles`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesHead: async (groupId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesHead', 'groupId', groupId)
            const localVarPath = `/v3/system/groups/{group_id}/roles`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from the group on the system.  DELETE /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdDelete: async (groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdDelete', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/system/groups/{group_id}/roles/{role_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdGet: async (groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdGet', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/system/groups/{group_id}/roles/{role_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdHead: async (groupId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdHead', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/system/groups/{group_id}/roles/{role_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a role to a group on the system.  PUT /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdPut: async (groupId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'groupId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdPut', 'groupId', groupId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemGroupsGroupIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/system/groups/{group_id}/roles/{role_id}`
                .replace(`{${"group_id"}}`, encodeURIComponent(String(groupId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesGet', 'userId', userId)
            const localVarPath = `/v3/system/users/{user_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesHead', 'userId', userId)
            const localVarPath = `/v3/system/users/{user_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Revoke a role from user on the system.  DELETE /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdDelete: async (userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdDelete', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdDelete', 'roleId', roleId)
            const localVarPath = `/v3/system/users/{user_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdGet: async (userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdGet', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/system/users/{user_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdHead: async (userId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdHead', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/system/users/{user_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Grant a role to a user on the system.  PUT /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdPut: async (userId: string, roleId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdPut', 'userId', userId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('systemUsersUserIdRolesRoleIdPut', 'roleId', roleId)
            const localVarPath = `/v3/system/users/{user_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SystemApi - functional programming interface
 * @export
 */
export const SystemApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SystemApiAxiosParamCreator(configuration)
    return {
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesGet(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesGet(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesHead(groupId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesHead(groupId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a role from the group on the system.  DELETE /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesRoleIdDelete(groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesRoleIdDelete(groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesRoleIdGet(groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesRoleIdGet(groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesRoleIdHead(groupId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesRoleIdHead(groupId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Grant a role to a group on the system.  PUT /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemGroupsGroupIdRolesRoleIdPut(groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemGroupsGroupIdRolesRoleIdPut(groupId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemGroupsGroupIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Revoke a role from user on the system.  DELETE /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesRoleIdDelete(userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesRoleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesRoleIdGet(userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesRoleIdGet(userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesRoleIdHead(userId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesRoleIdHead(userId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Grant a role to a user on the system.  PUT /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async systemUsersUserIdRolesRoleIdPut(userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.systemUsersUserIdRolesRoleIdPut(userId, roleId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['SystemApi.systemUsersUserIdRolesRoleIdPut']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * SystemApi - factory interface
 * @export
 */
export const SystemApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SystemApiFp(configuration)
    return {
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesGet(groupId: string, options?: any): AxiosPromise<any> {
            return localVarFp.systemGroupsGroupIdRolesGet(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesHead(groupId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemGroupsGroupIdRolesHead(groupId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from the group on the system.  DELETE /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdDelete(groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemGroupsGroupIdRolesRoleIdDelete(groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdGet(groupId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.systemGroupsGroupIdRolesRoleIdGet(groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdHead(groupId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemGroupsGroupIdRolesRoleIdHead(groupId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a role to a group on the system.  PUT /system/groups/{group_id}/roles/{role_id}
         * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemGroupsGroupIdRolesRoleIdPut(groupId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.systemGroupsGroupIdRolesRoleIdPut(groupId, roleId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesGet(userId: string, options?: any): AxiosPromise<any> {
            return localVarFp.systemUsersUserIdRolesGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemUsersUserIdRolesHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Revoke a role from user on the system.  DELETE /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemUsersUserIdRolesRoleIdDelete(userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdGet(userId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.systemUsersUserIdRolesRoleIdGet(userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdHead(userId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.systemUsersUserIdRolesRoleIdHead(userId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Grant a role to a user on the system.  PUT /system/users/{user_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        systemUsersUserIdRolesRoleIdPut(userId: string, roleId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.systemUsersUserIdRolesRoleIdPut(userId, roleId, body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SystemApi - object-oriented interface
 * @export
 * @class SystemApi
 * @extends {BaseAPI}
 */
export class SystemApi extends BaseAPI {
    /**
     * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesGet(groupId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesGet(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all system grants for a specific group.  GET/HEAD /system/groups/{group_id}/roles
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesHead(groupId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesHead(groupId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from the group on the system.  DELETE /system/groups/{group_id}/roles/{role_id}
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesRoleIdDelete(groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesRoleIdDelete(groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesRoleIdGet(groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesRoleIdGet(groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a group has a specific role on the system.  GET/HEAD /system/groups/{group_id}/roles/{role_id}
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesRoleIdHead(groupId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesRoleIdHead(groupId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a role to a group on the system.  PUT /system/groups/{group_id}/roles/{role_id}
     * @param {string} groupId group_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/groups/{group_id}/roles/{role_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemGroupsGroupIdRolesRoleIdPut(groupId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemGroupsGroupIdRolesRoleIdPut(groupId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesGet(userId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List all system grants for a specific user.  GET/HEAD /system/users/{user_id}/roles
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesHead(userId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Revoke a role from user on the system.  DELETE /system/users/{user_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesRoleIdDelete(userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesRoleIdDelete(userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesRoleIdGet(userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesRoleIdGet(userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if a user has a specific role on the system.  GET/HEAD /system/users/{user_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesRoleIdHead(userId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesRoleIdHead(userId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Grant a role to a user on the system.  PUT /system/users/{user_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/system/users/{user_id}/roles/{role_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SystemApi
     */
    public systemUsersUserIdRolesRoleIdPut(userId: string, roleId: string, body?: any, options?: RawAxiosRequestConfig) {
        return SystemApiFp(this.configuration).systemUsersUserIdRolesRoleIdPut(userId, roleId, body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {string} [protocolId] Filters the response by a protocol ID.
         * @param {string} [uniqueId] Filters the response by a unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet: async (domainId?: string, enabled?: boolean, id?: string, name?: string, passwordExpiresAt?: string, protocolId?: string, uniqueId?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (domainId !== undefined) {
                localVarQueryParameter['domain_id'] = domainId;
            }

            if (enabled !== undefined) {
                localVarQueryParameter['enabled'] = enabled;
            }

            if (id !== undefined) {
                localVarQueryParameter['id'] = id;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            if (passwordExpiresAt !== undefined) {
                localVarQueryParameter['password_expires_at'] = (passwordExpiresAt as any instanceof Date) ?
                    (passwordExpiresAt as any).toISOString() :
                    passwordExpiresAt;
            }

            if (protocolId !== undefined) {
                localVarQueryParameter['protocol_id'] = protocolId;
            }

            if (uniqueId !== undefined) {
                localVarQueryParameter['unique_id'] = uniqueId;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create a user.  POST /v3/users
         * @param {UsersPostRequest} [usersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost: async (usersPostRequest?: UsersPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete access rule resource.  DELETE /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdDelete: async (userId: string, accessRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdDelete', 'userId', userId)
            // verify required parameter 'accessRuleId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdDelete', 'accessRuleId', accessRuleId)
            const localVarPath = `/v3/users/{user_id}/access_rules/{access_rule_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_rule_id"}}`, encodeURIComponent(String(accessRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdGet: async (userId: string, accessRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdGet', 'userId', userId)
            // verify required parameter 'accessRuleId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdGet', 'accessRuleId', accessRuleId)
            const localVarPath = `/v3/users/{user_id}/access_rules/{access_rule_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_rule_id"}}`, encodeURIComponent(String(accessRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdHead: async (userId: string, accessRuleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdHead', 'userId', userId)
            // verify required parameter 'accessRuleId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesAccessRuleIdHead', 'accessRuleId', accessRuleId)
            const localVarPath = `/v3/users/{user_id}/access_rules/{access_rule_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_rule_id"}}`, encodeURIComponent(String(accessRuleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesGet', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/access_rules`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdAccessRulesHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/access_rules`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete application credential resource.  DELETE /v3/users/{user_id}/application_credentials/        {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdDelete: async (userId: string, applicationCredentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdDelete', 'userId', userId)
            // verify required parameter 'applicationCredentialId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdDelete', 'applicationCredentialId', applicationCredentialId)
            const localVarPath = `/v3/users/{user_id}/application_credentials/{application_credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"application_credential_id"}}`, encodeURIComponent(String(applicationCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdGet: async (userId: string, applicationCredentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdGet', 'userId', userId)
            // verify required parameter 'applicationCredentialId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdGet', 'applicationCredentialId', applicationCredentialId)
            const localVarPath = `/v3/users/{user_id}/application_credentials/{application_credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"application_credential_id"}}`, encodeURIComponent(String(applicationCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdHead: async (userId: string, applicationCredentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdHead', 'userId', userId)
            // verify required parameter 'applicationCredentialId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsApplicationCredentialIdHead', 'applicationCredentialId', applicationCredentialId)
            const localVarPath = `/v3/users/{user_id}/application_credentials/{application_credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"application_credential_id"}}`, encodeURIComponent(String(applicationCredentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} [name] The name of the application credential. Must be unique to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsGet: async (name?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3/users/{user_id}/application_credentials`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/application_credentials`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create application credential.  POST /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {UsersApplicationCredentialsPostRequest} [usersApplicationCredentialsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsPost: async (userId: string, usersApplicationCredentialsPostRequest?: UsersApplicationCredentialsPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdApplicationCredentialsPost', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/application_credentials`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersApplicationCredentialsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a specific EC2 credential.  DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdDelete: async (userId: string, credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdDelete', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdDelete', 'credentialId', credentialId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2/{credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdGet: async (userId: string, credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdGet', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdGet', 'credentialId', credentialId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2/{credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdHead: async (userId: string, credentialId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdHead', 'userId', userId)
            // verify required parameter 'credentialId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2CredentialIdHead', 'credentialId', credentialId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2/{credential_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"credential_id"}}`, encodeURIComponent(String(credentialId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Get: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2Get', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Head: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2Head', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Create EC2 Credential for user.  POST /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Post: async (userId: string, body?: any, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdCredentialsOSEC2Post', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/credentials/OS-EC2`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete a user.  DELETE /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdDelete', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdGet', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdGroupsGet', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/groups`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdGroupsHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/groups`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Delete specific access token.  DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete: async (userId: string, accessTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete', 'accessTokenId', accessTokenId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet: async (userId: string, accessTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet', 'accessTokenId', accessTokenId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead: async (userId: string, accessTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead', 'accessTokenId', accessTokenId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet: async (userId: string, accessTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet', 'accessTokenId', accessTokenId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead: async (userId: string, accessTokenId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead', 'accessTokenId', accessTokenId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet: async (userId: string, accessTokenId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet', 'accessTokenId', accessTokenId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet', 'roleId', roleId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead: async (userId: string, accessTokenId: string, roleId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead', 'userId', userId)
            // verify required parameter 'accessTokenId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead', 'accessTokenId', accessTokenId)
            // verify required parameter 'roleId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead', 'roleId', roleId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"access_token_id"}}`, encodeURIComponent(String(accessTokenId)))
                .replace(`{${"role_id"}}`, encodeURIComponent(String(roleId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensGet', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdOSOAUTH1AccessTokensHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/OS-OAUTH1/access_tokens`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * POST operation on /v3/users/{user_id}/password
         * @param {string} userId user_id parameter for /v3/users/{user_id}/password API
         * @param {UsersPasswordPostRequest} [usersPasswordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPasswordPost: async (userId: string, usersPasswordPostRequest?: UsersPasswordPostRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPasswordPost', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/password`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(usersPasswordPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update a user.  PATCH /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {UserPatchRequest} [userPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPatch: async (userId: string, userPatchRequest?: UserPatchRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdPatch', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userPatchRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * GET operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdProjectsGet: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdProjectsGet', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/projects`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdProjectsHead: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('usersUserIdProjectsHead', 'userId', userId)
            const localVarPath = `/v3/users/{user_id}/projects`
                .replace(`{${"user_id"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {string} [protocolId] Filters the response by a protocol ID.
         * @param {string} [uniqueId] Filters the response by a unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersGet(domainId?: string, enabled?: boolean, id?: string, name?: string, passwordExpiresAt?: string, protocolId?: string, uniqueId?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersGet(domainId, enabled, id, name, passwordExpiresAt, protocolId, uniqueId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create a user.  POST /v3/users
         * @param {UsersPostRequest} [usersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPost(usersPostRequest?: UsersPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPost(usersPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete access rule resource.  DELETE /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdAccessRulesAccessRuleIdDelete(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdAccessRulesAccessRuleIdDelete(userId, accessRuleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdAccessRulesAccessRuleIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdAccessRulesAccessRuleIdGet(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersAccessRuleGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdAccessRulesAccessRuleIdGet(userId, accessRuleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdAccessRulesAccessRuleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdAccessRulesAccessRuleIdHead(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdAccessRulesAccessRuleIdHead(userId, accessRuleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdAccessRulesAccessRuleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdAccessRulesGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersAccessRulesGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdAccessRulesGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdAccessRulesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdAccessRulesHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdAccessRulesHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdAccessRulesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete application credential resource.  DELETE /v3/users/{user_id}/application_credentials/        {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId, applicationCredentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsApplicationCredentialIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersApplicationCredentialGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId, applicationCredentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsApplicationCredentialIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId, applicationCredentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsApplicationCredentialIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} [name] The name of the application credential. Must be unique to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsGet(name?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersApplicationCredentialsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsGet(name, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create application credential.  POST /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {UsersApplicationCredentialsPostRequest} [usersApplicationCredentialsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdApplicationCredentialsPost(userId: string, usersApplicationCredentialsPostRequest?: UsersApplicationCredentialsPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersApplicationCredentialsPostResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdApplicationCredentialsPost(userId, usersApplicationCredentialsPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdApplicationCredentialsPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a specific EC2 credential.  DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2CredentialIdDelete(userId: string, credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2CredentialIdDelete(userId, credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2CredentialIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2CredentialIdGet(userId: string, credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2CredentialIdGet(userId, credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2CredentialIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2CredentialIdHead(userId: string, credentialId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2CredentialIdHead(userId, credentialId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2CredentialIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2Get(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2Get(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2Get']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2Head(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2Head(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2Head']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Create EC2 Credential for user.  POST /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdCredentialsOSEC2Post(userId: string, body?: any, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdCredentialsOSEC2Post(userId, body, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdCredentialsOSEC2Post']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete a user.  DELETE /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdDelete(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdDelete(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdGroupsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersGroupsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdGroupsGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdGroupsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdGroupsHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdGroupsHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdGroupsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Delete specific access token.  DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId, accessTokenId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId, accessTokenId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId, accessTokenId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId, accessTokenId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId, accessTokenId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId: string, accessTokenId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId, accessTokenId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId: string, accessTokenId: string, roleId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId, accessTokenId, roleId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdOSOAUTH1AccessTokensHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdOSOAUTH1AccessTokensHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdOSOAUTH1AccessTokensHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * POST operation on /v3/users/{user_id}/password
         * @param {string} userId user_id parameter for /v3/users/{user_id}/password API
         * @param {UsersPasswordPostRequest} [usersPasswordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPasswordPost(userId: string, usersPasswordPostRequest?: UsersPasswordPostRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPasswordPost(userId, usersPasswordPostRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdPasswordPost']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * Update a user.  PATCH /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {UserPatchRequest} [userPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdPatch(userId: string, userPatchRequest?: UserPatchRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPatchResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdPatch(userId, userPatchRequest, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdPatch']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * GET operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdProjectsGet(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersProjectsGetResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdProjectsGet(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdProjectsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUserIdProjectsHead(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUserIdProjectsHead(userId, options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['UsersApi.usersUserIdProjectsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} [domainId] Filters the response by a domain ID.
         * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
         * @param {string} [id] Filter for Identity Providers’ ID attribute
         * @param {string} [name] Filters the response by a resource name.
         * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
         * @param {string} [protocolId] Filters the response by a protocol ID.
         * @param {string} [uniqueId] Filters the response by a unique ID.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersGet(domainId?: string, enabled?: boolean, id?: string, name?: string, passwordExpiresAt?: string, protocolId?: string, uniqueId?: string, options?: any): AxiosPromise<UsersGetResponse> {
            return localVarFp.usersGet(domainId, enabled, id, name, passwordExpiresAt, protocolId, uniqueId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersHead(options?: any): AxiosPromise<void> {
            return localVarFp.usersHead(options).then((request) => request(axios, basePath));
        },
        /**
         * Create a user.  POST /v3/users
         * @param {UsersPostRequest} [usersPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPost(usersPostRequest?: UsersPostRequest, options?: any): AxiosPromise<any> {
            return localVarFp.usersPost(usersPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete access rule resource.  DELETE /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdDelete(userId: string, accessRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdAccessRulesAccessRuleIdDelete(userId, accessRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdGet(userId: string, accessRuleId: string, options?: any): AxiosPromise<UsersAccessRuleGetResponse> {
            return localVarFp.usersUserIdAccessRulesAccessRuleIdGet(userId, accessRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesAccessRuleIdHead(userId: string, accessRuleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdAccessRulesAccessRuleIdHead(userId, accessRuleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesGet(userId: string, options?: any): AxiosPromise<UsersAccessRulesGetResponse> {
            return localVarFp.usersUserIdAccessRulesGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
         * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdAccessRulesHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdAccessRulesHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete application credential resource.  DELETE /v3/users/{user_id}/application_credentials/        {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId: string, applicationCredentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId, applicationCredentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId: string, applicationCredentialId: string, options?: any): AxiosPromise<UsersApplicationCredentialGetResponse> {
            return localVarFp.usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId, applicationCredentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId: string, applicationCredentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId, applicationCredentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} [name] The name of the application credential. Must be unique to a user.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsGet(name?: string, options?: any): AxiosPromise<UsersApplicationCredentialsGetResponse> {
            return localVarFp.usersUserIdApplicationCredentialsGet(name, options).then((request) => request(axios, basePath));
        },
        /**
         * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdApplicationCredentialsHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create application credential.  POST /v3/users/{user_id}/application_credentials
         * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
         * @param {UsersApplicationCredentialsPostRequest} [usersApplicationCredentialsPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdApplicationCredentialsPost(userId: string, usersApplicationCredentialsPostRequest?: UsersApplicationCredentialsPostRequest, options?: any): AxiosPromise<UsersApplicationCredentialsPostResponse> {
            return localVarFp.usersUserIdApplicationCredentialsPost(userId, usersApplicationCredentialsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a specific EC2 credential.  DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdDelete(userId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdCredentialsOSEC2CredentialIdDelete(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdGet(userId: string, credentialId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdCredentialsOSEC2CredentialIdGet(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2CredentialIdHead(userId: string, credentialId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdCredentialsOSEC2CredentialIdHead(userId, credentialId, options).then((request) => request(axios, basePath));
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Get(userId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdCredentialsOSEC2Get(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Head(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdCredentialsOSEC2Head(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Create EC2 Credential for user.  POST /v3/users/{user_id}/credentials/OS-EC2
         * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
         * @param {any} [body] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdCredentialsOSEC2Post(userId: string, body?: any, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdCredentialsOSEC2Post(userId, body, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete a user.  DELETE /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdDelete(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdDelete(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGet(userId: string, options?: any): AxiosPromise<UserGetResponse> {
            return localVarFp.usersUserIdGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsGet(userId: string, options?: any): AxiosPromise<UsersGroupsGetResponse> {
            return localVarFp.usersUserIdGroupsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
         * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdGroupsHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdGroupsHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * Delete specific access token.  DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId: string, accessTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId, accessTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId: string, accessTokenId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId, accessTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId: string, accessTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId, accessTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId: string, accessTokenId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId, accessTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId: string, accessTokenId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId, accessTokenId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId: string, accessTokenId: string, roleId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId, accessTokenId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId: string, accessTokenId: string, roleId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId, accessTokenId, roleId, options).then((request) => request(axios, basePath));
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensGet(userId: string, options?: any): AxiosPromise<any> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
         * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdOSOAUTH1AccessTokensHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdOSOAUTH1AccessTokensHead(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * POST operation on /v3/users/{user_id}/password
         * @param {string} userId user_id parameter for /v3/users/{user_id}/password API
         * @param {UsersPasswordPostRequest} [usersPasswordPostRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPasswordPost(userId: string, usersPasswordPostRequest?: UsersPasswordPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdPasswordPost(userId, usersPasswordPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update a user.  PATCH /v3/users/{user_id}
         * @param {string} userId user_id parameter for /v3/users/{user_id} API
         * @param {UserPatchRequest} [userPatchRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdPatch(userId: string, userPatchRequest?: UserPatchRequest, options?: any): AxiosPromise<UserPatchResponse> {
            return localVarFp.usersUserIdPatch(userId, userPatchRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * GET operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdProjectsGet(userId: string, options?: any): AxiosPromise<UsersProjectsGetResponse> {
            return localVarFp.usersUserIdProjectsGet(userId, options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3/users/{user_id}/projects
         * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUserIdProjectsHead(userId: string, options?: any): AxiosPromise<void> {
            return localVarFp.usersUserIdProjectsHead(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
     * @param {string} [domainId] Filters the response by a domain ID.
     * @param {boolean} [enabled] If set to true, then only enabled projects will be returned. Any value other than 0 (including no value) will be interpreted as true.
     * @param {string} [id] Filter for Identity Providers’ ID attribute
     * @param {string} [name] Filters the response by a resource name.
     * @param {string} [passwordExpiresAt] Filter results based on which user passwords have expired. The query should include an operator and a timestamp with a colon (:) separating the two, for example: &#x60;password_expires_at&#x3D;{operator}:{timestamp}&#x60;. Valid operators are: &#x60;lt&#x60;, &#x60;lte&#x60;, &#x60;gt&#x60;, &#x60;gte&#x60;, &#x60;eq&#x60;, and &#x60;neq&#x60;. Valid timestamps are of the form: YYYY-MM-DDTHH:mm:ssZ.
     * @param {string} [protocolId] Filters the response by a protocol ID.
     * @param {string} [uniqueId] Filters the response by a unique ID.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersGet(domainId?: string, enabled?: boolean, id?: string, name?: string, passwordExpiresAt?: string, protocolId?: string, uniqueId?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersGet(domainId, enabled, id, name, passwordExpiresAt, protocolId, uniqueId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersHead(options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersHead(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create a user.  POST /v3/users
     * @param {UsersPostRequest} [usersPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPost(usersPostRequest?: UsersPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPost(usersPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete access rule resource.  DELETE /v3/users/{user_id}/access_rules/{access_rule_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdAccessRulesAccessRuleIdDelete(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdAccessRulesAccessRuleIdDelete(userId, accessRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdAccessRulesAccessRuleIdGet(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdAccessRulesAccessRuleIdGet(userId, accessRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get access rule resource.  GET/HEAD /v3/users/{user_id}/access_rules/{access_rule_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {string} accessRuleId access_rule_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdAccessRulesAccessRuleIdHead(userId: string, accessRuleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdAccessRulesAccessRuleIdHead(userId, accessRuleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
     * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdAccessRulesGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdAccessRulesGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List access rules for user.  GET/HEAD /v3/users/{user_id}/access_rules
     * @param {string} userId user_id parameter for /v3/users/{user_id}/access_rules/{access_rule_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdAccessRulesHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdAccessRulesHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete application credential resource.  DELETE /v3/users/{user_id}/application_credentials/        {application_credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsApplicationCredentialIdDelete(userId, applicationCredentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsApplicationCredentialIdGet(userId, applicationCredentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get application credential resource.  GET/HEAD /v3/users/{user_id}/application_credentials/          {application_credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {string} applicationCredentialId application_credential_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId: string, applicationCredentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsApplicationCredentialIdHead(userId, applicationCredentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
     * @param {string} [name] The name of the application credential. Must be unique to a user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsGet(name?: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsGet(name, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List application credentials for user.  GET/HEAD /v3/users/{user_id}/application_credentials
     * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create application credential.  POST /v3/users/{user_id}/application_credentials
     * @param {string} userId user_id parameter for /v3/users/{user_id}/application_credentials/{application_credential_id} API
     * @param {UsersApplicationCredentialsPostRequest} [usersApplicationCredentialsPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdApplicationCredentialsPost(userId: string, usersApplicationCredentialsPostRequest?: UsersApplicationCredentialsPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdApplicationCredentialsPost(userId, usersApplicationCredentialsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a specific EC2 credential.  DELETE /users/{user_id}/credentials/OS-EC2/{credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2CredentialIdDelete(userId: string, credentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2CredentialIdDelete(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2CredentialIdGet(userId: string, credentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2CredentialIdGet(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a specific EC2 credential.  GET/HEAD /users/{user_id}/credentials/OS-EC2/{credential_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {string} credentialId credential_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2CredentialIdHead(userId: string, credentialId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2CredentialIdHead(userId, credentialId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2Get(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2Get(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List EC2 Credentials for user.  GET/HEAD /v3/users/{user_id}/credentials/OS-EC2
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2Head(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2Head(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Create EC2 Credential for user.  POST /v3/users/{user_id}/credentials/OS-EC2
     * @param {string} userId user_id parameter for /v3/users/{user_id}/credentials/OS-EC2/{credential_id} API
     * @param {any} [body] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdCredentialsOSEC2Post(userId: string, body?: any, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdCredentialsOSEC2Post(userId, body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete a user.  DELETE /v3/users/{user_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdDelete(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdDelete(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
     * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdGroupsGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdGroupsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get groups for a user.  GET/HEAD /v3/users/{user_id}/groups
     * @param {string} userId user_id parameter for /v3/users/{user_id}/groups API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdGroupsHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdGroupsHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get a user resource or list users.  GET/HEAD /v3/users GET/HEAD /v3/users/{user_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Delete specific access token.  DELETE /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdDelete(userId, accessTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdGet(userId, accessTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get specific access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdHead(userId, accessTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesGet(userId, accessTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List roles for a user access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId: string, accessTokenId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesHead(userId, accessTokenId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId: string, accessTokenId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdGet(userId, accessTokenId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Get role for access token.  GET/HEAD /v3/users/{user_id}/OS-OAUTH1/access_tokens/          {access_token_id}/roles/{role_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} accessTokenId access_token_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {string} roleId role_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id}/roles/{role_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId: string, accessTokenId: string, roleId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensAccessTokenIdRolesRoleIdHead(userId, accessTokenId, roleId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * List OAuth1 Access Tokens for user.  GET /v3/users/{user_id}/OS-OAUTH1/access_tokens
     * @param {string} userId user_id parameter for /v3/users/{user_id}/OS-OAUTH1/access_tokens/{access_token_id} API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdOSOAUTH1AccessTokensHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdOSOAUTH1AccessTokensHead(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * POST operation on /v3/users/{user_id}/password
     * @param {string} userId user_id parameter for /v3/users/{user_id}/password API
     * @param {UsersPasswordPostRequest} [usersPasswordPostRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdPasswordPost(userId: string, usersPasswordPostRequest?: UsersPasswordPostRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdPasswordPost(userId, usersPasswordPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update a user.  PATCH /v3/users/{user_id}
     * @param {string} userId user_id parameter for /v3/users/{user_id} API
     * @param {UserPatchRequest} [userPatchRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdPatch(userId: string, userPatchRequest?: UserPatchRequest, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdPatch(userId, userPatchRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * GET operation on /v3/users/{user_id}/projects
     * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdProjectsGet(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdProjectsGet(userId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3/users/{user_id}/projects
     * @param {string} userId user_id parameter for /v3/users/{user_id}/projects API
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUserIdProjectsHead(userId: string, options?: RawAxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUserIdProjectsHead(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * V3Api - axios parameter creator
 * @export
 */
export const V3ApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v3`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * V3Api - functional programming interface
 * @export
 */
export const V3ApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = V3ApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['V3Api.versionGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['V3Api.versionHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * V3Api - factory interface
 * @export
 */
export const V3ApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = V3ApiFp(configuration)
    return {
        /**
         * GET operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionGet(options?: any): AxiosPromise<object> {
            return localVarFp.versionGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /v3
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionHead(options?: any): AxiosPromise<void> {
            return localVarFp.versionHead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * V3Api - object-oriented interface
 * @export
 * @class V3Api
 * @extends {BaseAPI}
 */
export class V3Api extends BaseAPI {
    /**
     * GET operation on /v3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V3Api
     */
    public versionGet(options?: RawAxiosRequestConfig) {
        return V3ApiFp(this.configuration).versionGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /v3
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof V3Api
     */
    public versionHead(options?: RawAxiosRequestConfig) {
        return V3ApiFp(this.configuration).versionHead(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VersionApi - axios parameter creator
 * @export
 */
export const VersionApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * GET operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * HEAD operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsHead: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'HEAD', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication ApiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "X-Auth-Token", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VersionApi - functional programming interface
 * @export
 */
export const VersionApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VersionApiAxiosParamCreator(configuration)
    return {
        /**
         * GET operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionsGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionsGet(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VersionApi.versionsGet']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
        /**
         * HEAD operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async versionsHead(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.versionsHead(options);
            const index = configuration?.serverIndex ?? 0;
            const operationBasePath = operationServerMap['VersionApi.versionsHead']?.[index]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, operationBasePath || basePath);
        },
    }
};

/**
 * VersionApi - factory interface
 * @export
 */
export const VersionApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VersionApiFp(configuration)
    return {
        /**
         * GET operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsGet(options?: any): AxiosPromise<object> {
            return localVarFp.versionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * HEAD operation on /
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        versionsHead(options?: any): AxiosPromise<void> {
            return localVarFp.versionsHead(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VersionApi - object-oriented interface
 * @export
 * @class VersionApi
 * @extends {BaseAPI}
 */
export class VersionApi extends BaseAPI {
    /**
     * GET operation on /
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public versionsGet(options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).versionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * HEAD operation on /
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VersionApi
     */
    public versionsHead(options?: RawAxiosRequestConfig) {
        return VersionApiFp(this.configuration).versionsHead(options).then((request) => request(this.axios, this.basePath));
    }
}



